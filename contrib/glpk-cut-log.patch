%% This patch is taken from https://github.com/timothy-king/glpk-cut-log and
%% has the following license:
%%
%% GLPK is free software: you can redistribute it and/or modify it under the
%% terms of the GNU General Public License as published by the Free Software
%% Foundation, either version 3 of the License, or (at your option) any later
%% version.
%%
From cf84e3855d8c5676557daaca434b42b2fc17dc29 Mon Sep 17 00:00:00 2001
From: Tim King <taking@cs.nyu.edu>
Date: Sat, 14 Dec 2013 16:03:35 -0500
Subject: [PATCH] Adding a function for returning the iteration count.

Adding GLP_ICUTADDED callback:
- Adds a new callback location that is called after every cut is added to the pool.
- During this callback users can request a copy of this cut and query what kind of cut it is.
- GMI cuts also support returning what row in the tableau it came from. Users can use this to replay how the cut was generated.

Logging MIR Cuts
- Changed the IOSAUX to be defined as a linear sum of input rows.
  This is visible from the interface
- Logging the multipliers used to create the aggregate row in MIR.
- Logging the delta selected by final successful cmir_sep call.
- Logging the cset selected by final successful cmir_sep call.
- The delta and cset are not yet user visible.

The extra mir logging information is now user visible.

Adding GLP_ICUTSELECT callback:
- ios_process_cuts marks the cuts as selected after turning the cut into a row.
- This callback happens after ios_process_cuts marks and before the pool is
  cleared by ios_clear_pool.

Cleaning up the git directory to not track autogenerated files.

Branch logging
- Adds to the integer interface a callback function for when branches are made.
  This is called after branch_on.
- Added a public function glp_ios_branch_log.
  This returns the structural variable for the branch as well as the value
  branched on, and the ids of the nodes for the down and up branches.
  If both branches are infeasible, the ids are -1 for both dn and up.
  If one branch is infeasible (and no branch is done), this returns -1 for
  the infeasible branch and the current node id for the up branch.
- Each node now has a unique ordinal associated with it.
- Added a public function to convert the id of an active node to the unique
  node ordinal.
- Added a callback for when a node is closed due to being linearly infeasible.

Improved the mir cut logging facilities to now include:
- the rid id used for virtual lower/upper bound selection,
- and the subst map,
- Changed the size of the cset array to be the same as the new arrays (m+n)
- Fixed a bug in returning the cset selected.

Fixing a bug selecting the correct branch.

Added a callback for tracking row deletion.

Adding notes to node freeze and revive functions.

Commenting out a few debugging printfs for gomory cuts.

Changing an overly aggressive assert in MIR generate when an assignment is outside of the bounds to skipping the application of the mir rule.

Removing some printfs.

Weakening assert to a failure.

Adding a stability failure limit to simplex.

Updating the installation instructions.

---
diff --git a/configure.ac b/configure.ac
index cbdb724..ba642ba 100644
--- a/configure.ac
+++ b/configure.ac
@@ -6,7 +6,7 @@ AC_CONFIG_SRCDIR([src/glpk.h])
 
 AC_CONFIG_MACRO_DIR([m4])
 
-AM_INIT_AUTOMAKE
+AM_INIT_AUTOMAKE([subdir-objects])
 
 AC_CONFIG_HEADERS([config.h])
 
diff --git a/src/Makefile.am b/src/Makefile.am
index 48dff15..d04b547 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -27,6 +27,7 @@ libglpk_la_LDFLAGS = \
 ${NOUNDEFINED}
 
 libglpk_la_SOURCES = \
+cutlog01.c \
 amd/amd_1.c \
 amd/amd_2.c \
 amd/amd_aat.c \
diff --git a/src/cutlog01.c b/src/cutlog01.c
new file mode 100644
index 0000000..c8818df
--- /dev/null
+++ b/src/cutlog01.c
@@ -0,0 +1,446 @@
+/* cutlog01.c (api extension routines) */
+
+#include "env.h"
+#include "ios.h"
+#include "npp.h"
+#include "glpk.h"
+#include "ios.h"
+
+int glp_ios_get_cut(glp_tree *T, int i, int* ind, double* val, int* klass, int* type, double* rhs){
+  xassert(T != NULL);
+
+  IOSCUT* cut;
+  int len;
+  IOSAIJ* aij;
+  glp_prob* prob;
+
+  if (T->reason != GLP_ICUTADDED){
+    xerror("glp_ios_get_cut: not called during cut added.\n");
+  }
+  cut = ios_find_row(T->local, i);
+  if ( cut == NULL ) {
+    xerror("glp_ios_get_cut: called with an invalid index.");
+  }
+  len = 0;
+  for(len = 0, aij = cut->ptr; aij != NULL; aij = aij->next)
+  {
+    len++;
+    if(ind != NULL){ ind[len] = aij->j; }
+    if(val != NULL){ val[len] = aij->val; }
+  }
+  if(klass != NULL){ *klass = cut->klass; }
+  if(type != NULL){ *type = cut->type; }
+  if(rhs != NULL){ *rhs = cut->rhs; }
+  return len;
+}
+
+
+IOSAUX *ios_create_aux(int n, const int rows[], const double coeffs[]){
+  IOSAUX *aux;
+  int i;
+  aux = xmalloc(sizeof(IOSAUX));
+  aux->nrows = n;
+  aux->rows = xcalloc(1+n, sizeof(int));
+  aux->mult = xcalloc(1+n, sizeof(double));
+  aux->selected = -1;
+  aux->mir_cset = NULL;
+
+  for ( i = 1; i <= n; i++)
+  {  aux->rows[i] = rows[i];
+     aux->mult[i] = coeffs[i];
+  }
+
+  return aux;
+}
+
+void ios_delete_aux(IOSAUX *aux){
+  xassert(aux != NULL);
+  xfree(aux->rows);
+  xfree(aux->mult);
+  if( aux->mir_cset != NULL ){
+    xfree(aux->mir_cset);
+     xfree(aux->mir_subst);
+     xfree(aux->mir_vlb_rows);
+     xfree(aux->mir_vub_rows);
+  }
+  xfree(aux);
+  return;
+}
+
+static void cut_set_aux(IOSCUT *cut, int n,
+                        const int rows[], const double coeffs[]){
+  int i;
+  xassert( cut != NULL );
+  if( cut->aux != NULL ) {
+    ios_delete_aux(cut-> aux);
+  }
+
+  cut->aux = ios_create_aux(n, rows, coeffs);
+  xassert( cut->aux->nrows == n );
+}
+
+static void cut_set_aux_mir(IOSAUX *aux, double delta, int m, int n,
+                            const char cset[], const char subst[],
+                            const int vlbrs[], const int vubrs[]){
+  int i;
+  xassert( aux != NULL );
+  if ( aux->mir_cset != NULL )
+  {  xfree(aux->mir_cset);
+     xfree(aux->mir_subst);
+     xfree(aux->mir_vlb_rows);
+     xfree(aux->mir_vub_rows);
+  }
+
+  aux->mir_cset     = xcalloc(1+n+m, sizeof(char));
+  aux->mir_subst    = xcalloc(1+n+m, sizeof(char));
+  aux->mir_vlb_rows = xcalloc(1+n+m, sizeof(int));
+  aux->mir_vub_rows = xcalloc(1+n+m, sizeof(int));
+
+  for ( i = 1; i <= n+m; i++)
+  {  aux->mir_cset[i] = cset[i];
+     aux->mir_subst[i] = subst[i];
+     aux->mir_vlb_rows[i] = vlbrs[i];
+     aux->mir_vub_rows[i] = vubrs[i];
+  }
+
+  aux->mir_delta = delta;
+}
+
+void ios_cut_set_aux_mir(glp_tree *T, int ord, double delta,
+                         const char cset[], const char subst[],
+                         const int vlbrs[], const int vubrs[]){
+  int m, n;
+  IOSCUT *cut;
+  glp_prob *mip;
+  mip = T->mip;
+  m = mip->m;
+  n = mip->n;
+  cut = ios_find_row(T->local, ord);
+  xassert(cut != NULL);
+  cut_set_aux_mir(cut->aux, delta, m, n, cset, subst, vlbrs, vubrs);
+}
+
+void ios_cut_set_single_aux(glp_tree *T, int ord, int j){
+  IOSCUT *cut;
+  cut = ios_find_row(T->local, ord);
+  xassert(cut != NULL);
+
+  /* set up arrays */
+  int ind[1+1];
+  double coeffs[1+1];
+  ind[1] = j;
+  coeffs[1] = +1.0;
+
+  /* call general procedure */
+  cut_set_aux(cut, 1, ind, coeffs);
+}
+
+void ios_cut_set_aux(glp_tree *T, int ord, int n,
+                     const int rows[], const double coeffs[]){
+  IOSCUT *cut;
+  cut = ios_find_row(T->local, ord);
+  xassert(cut != NULL);
+  cut_set_aux(cut, n, rows, coeffs);
+}
+
+int glp_ios_cut_get_aux_nrows(glp_tree *tree, int ord){
+  IOSCUT *cut;
+  IOSAUX *aux;
+  if (tree->reason != GLP_ICUTADDED){
+    xerror("glp_ios_cut_get_aux_nrows: not called during cut added.\n");
+  }
+  cut = ios_find_row(tree->local, ord);
+  if ( cut == NULL ){
+    xerror("glp_ios_cut_get_aux_nrows: not called on a valid cut.\n");
+  }
+  aux = cut->aux;
+  return (aux == NULL) ? 0 : aux->nrows;
+}
+
+void glp_ios_cut_get_aux_rows(glp_tree *tree, int ord,
+                              int rows[], double coeffs[]){
+  IOSCUT *cut;
+  IOSAUX *aux;
+  int j, nrows;
+  if (tree->reason != GLP_ICUTADDED){
+    xerror("glp_ios_cut_get_aux_rows: not called during cut added.\n");
+  }
+  cut = ios_find_row(tree->local, ord);
+  if ( cut == NULL ){
+    xerror("glp_ios_cut_get_aux_rows: not called on a valid cut.\n");
+  }
+  aux = cut->aux;
+  if( aux != NULL ){
+    nrows = aux->nrows;
+    for ( j = 1; j <= nrows; j++ )
+    {  if ( rows != NULL ) { rows[j] = aux->rows[j]; }
+       if ( coeffs != NULL ) { coeffs[j] = aux->mult[j]; }
+    }
+  }
+  return;
+}
+
+
+void glp_ios_cut_get_mir_subst(glp_tree *tree, int ord, char subst[]);
+/* gets mir cut substition information. */
+void glp_ios_cut_get_mir_virtual_rows(glp_tree *tree, int ord,
+                                      int vlb[], int vub[]);
+/* gets mir cut virtual bounds rows. */
+
+void glp_ios_cut_get_mir_cset(glp_tree *tree, int ord, char *cset){
+  glp_prob *mip;
+  IOSCUT *cut;
+  IOSAUX *aux;
+  int j, n, m;
+  if ( tree->reason != GLP_ICUTADDED ){
+    xerror("glp_ios_cut_get_aux_mir: not called during cut added.\n");
+  }
+  cut = ios_find_row(tree->local, ord);
+  if ( cut == NULL ){
+    xerror("glp_ios_cut_get_aux_mir: not called on a cut.\n");
+  }
+  if ( cut->klass != GLP_RF_MIR ){
+    xerror("glp_ios_cut_get_aux_mir: not called on a mir cut.\n");
+  }
+  aux = cut->aux;
+  mip = tree->mip;
+  m = mip->m;
+  n = mip->n;
+
+  if( cset != NULL ){
+    for ( j=1; j <= n+m; j++ ){
+      cset[j] = (aux->mir_cset == NULL) ? 0 : aux->mir_cset[j];
+    }
+  }
+}
+void glp_ios_cut_get_mir_subst(glp_tree *tree, int ord, char *subst){
+  glp_prob *mip;
+  IOSCUT *cut;
+  IOSAUX *aux;
+  int j, n, m;
+  if ( tree->reason != GLP_ICUTADDED ){
+    xerror("glp_ios_cut_get_aux_mir: not called during cut added.\n");
+  }
+  cut = ios_find_row(tree->local, ord);
+  if ( cut == NULL ){
+    xerror("glp_ios_cut_get_aux_mir: not called on a cut.\n");
+  }
+  if ( cut->klass != GLP_RF_MIR ){
+    xerror("glp_ios_cut_get_aux_mir: not called on a mir cut.\n");
+  }
+  aux = cut->aux;
+  mip = tree->mip;
+  m = mip->m;
+  n = mip->n;
+
+  if( subst != NULL ){
+    for ( j=1; j <= n+m; j++ ){
+      subst[j] = (aux->mir_subst == NULL) ? 0 : aux->mir_subst[j];
+    }
+  }
+}
+void glp_ios_cut_get_mir_virtual_rows(glp_tree *tree, int ord, int vlb_rows[], int vub_rows[]){
+  glp_prob *mip;
+  IOSCUT *cut;
+  IOSAUX *aux;
+  int j, n, m;
+  if ( tree->reason != GLP_ICUTADDED ){
+    xerror("glp_ios_cut_get_aux_mir: not called during cut added.\n");
+  }
+  cut = ios_find_row(tree->local, ord);
+  if ( cut == NULL ){
+    xerror("glp_ios_cut_get_aux_mir: not called on a cut.\n");
+  }
+  if ( cut->klass != GLP_RF_MIR ){
+    xerror("glp_ios_cut_get_aux_mir: not called on a mir cut.\n");
+  }
+  aux = cut->aux;
+  mip = tree->mip;
+  m = mip->m;
+  n = mip->n;
+
+  for ( j=1; j <= n+m; j++ ){
+    vlb_rows[j] = (aux->mir_vlb_rows == NULL) ? 0 : aux->mir_vlb_rows[j];
+    vub_rows[j] = (aux->mir_vub_rows == NULL) ? 0 : aux->mir_vub_rows[j];
+  }
+}
+double glp_ios_cut_get_mir_delta(glp_tree *tree, int ord){
+  glp_prob *mip;
+  IOSCUT *cut;
+  IOSAUX *aux;
+  int j, n, m;
+  if ( tree->reason != GLP_ICUTADDED ){
+    xerror("glp_ios_cut_get_aux_mir: not called during cut added.\n");
+  }
+  cut = ios_find_row(tree->local, ord);
+  if ( cut == NULL ){
+    xerror("glp_ios_cut_get_aux_mir: not called on a cut.\n");
+  }
+  if ( cut->klass != GLP_RF_MIR ){
+    xerror("glp_ios_cut_get_aux_mir: not called on a mir cut.\n");
+  }
+  aux = cut->aux;
+  return aux->mir_delta;
+}
+
+
+void ios_cut_set_selected(IOSCUT *cut, int sel){
+#ifdef CUT_DEBUG
+  static int i = 0;
+  ++i;
+  printf("ios_cut_set_selected: %d %d %p\n", i, sel, cut);
+#endif
+
+  IOSAUX *aux;
+  aux = cut->aux;
+  if ( aux != NULL ){
+    aux->selected = sel;
+  }
+}
+
+int glp_ios_selected_cuts(glp_tree *tree, int ords[], int sel[]){
+  int len, j, N, s;
+  IOSPOOL* pool;
+  IOSCUT* cut;
+  IOSAUX* aux;
+  if ( tree == NULL ){
+    xerror("glp_ios_selected_cuts: not called with a valid tree.\n");
+  }
+  if ( tree->reason != GLP_ICUTSELECT ){
+    xerror("glp_ios_selected_cuts: not called during cut selected.\n");
+  }
+
+  pool = tree->local;
+  if ( pool == NULL ){
+    xerror("glp_ios_selected_cuts: called on a malformed tree.\n");
+  }
+
+  for (len = 0, j = 1, cut = pool->head; cut != NULL; cut = cut->next, j++)
+  {  aux = cut->aux;
+#ifdef CUT_DEBUG
+     printf("glp_ios_selected_cuts: %d %p\n", j, cut);
+#endif
+     if ( aux != NULL )
+     { s = aux->selected;
+       if ( s >= 0 )
+       {  len++;
+          if (ords != NULL) { ords[len] = j; }
+          if (sel != NULL)  { sel[len] = s; }
+       }
+     }
+  }
+  return len;
+}
+
+int glp_ios_branch_log(glp_tree *tree, double *br_val, int* parent, int* dn, int* up){
+  IOSNPD *node;
+  int br_result, br_var;
+  int p, d, u;
+  double v;
+  glp_prob *mip;
+  if ( tree == NULL ){
+    xerror("glp_ios_branch_log: not called with a valid tree \n");
+  }
+  if ( tree->reason != GLP_LI_BRANCH ){
+    xerror("glp_ios_branch_log: not called during GLP_LI_BRANCH \n");
+  }
+  mip = tree->mip;
+  if ( mip == NULL ){
+    xerror("glp_ios_branch_log: not called with a valid tree\n");
+  }
+  br_result = tree->br_result;
+  br_var = tree->br_var;
+  switch(br_result){
+  case 0:
+    p = tree->br_node;
+    node = tree->slot[p].node;
+    break;
+  case 1:
+  case 2:
+    node = tree->curr;
+    p = node->p;
+    break;
+  default:
+    xerror("glp_ios_branch_log: br_result is not properly set \n");
+  }
+  if( node == NULL ){
+    xerror("glp_ios_branch_log: not called with a valid tree \n");
+  }
+  switch(br_result){
+  case 0:
+    v = node->br_val;
+    d = tree->dn_child;
+    u = tree->up_child;
+    break;
+  case 1:
+    v = mip->col[br_var]->prim;
+    if(tree->br_to_up){
+      d = -1;
+      u = p;
+    }else{
+      d = p;
+      u = -1;
+    }
+    break;
+  case 2:
+    v = mip->col[br_var]->prim;
+    d = -1;
+    u = -1;
+    break;
+  default:
+    xerror("glp_ios_branch_log: not called with a valid tree \n");
+  }
+
+  if(br_val != NULL){ *br_val = v; }
+  if(parent != NULL){ *parent = p; }
+  if(dn != NULL){ *dn = d; }
+  if(up != NULL){ *up = u; }
+
+  return br_var;
+}
+
+int glp_ios_node_ord(glp_tree *tree, int p){
+  IOSNPD *node;
+  if ( tree == NULL ){
+    xerror("glp_ios_node_ord: not called with a valid tree.\n");
+  }
+  if (!(1 <= p && p <= tree->nslots)){
+    xerror("glp_ios_node_ord: not called with a valid p.\n");
+  }
+  node = tree->slot[p].node;
+  return node->ord;
+}
+
+void ios_cb_rows_deleted(glp_tree *T, int n, const int* rows){
+  if (T->parm->cb_func != NULL)
+  {
+    xassert(T->reason == 0);
+    xassert(T->deleting_rows == NULL);
+    xassert(T->num_deleting_rows == 0);
+    T->num_deleting_rows = n;
+    T->deleting_rows = rows;
+
+    T->reason = GLP_LI_DELROW;
+    T->parm->cb_func(T, T->parm->cb_info);
+    T->reason = 0;
+    T->num_deleting_rows = 0;
+    T->deleting_rows = NULL;
+  }
+}
+
+int glp_ios_rows_deleted(glp_tree *tree, int* rows){
+  if ( tree == NULL ){
+    xerror("glp_ios_rows_deleted: not called with a valid tree.\n");
+  }
+  if ( tree->reason != GLP_LI_DELROW ){
+    xerror("glp_ios_rows_deleted: not called with a valid reason.\n");
+  }
+
+  int j;
+  if(rows != NULL){
+    for(j=1; j <= tree->num_deleting_rows; j++){
+      rows[j] = tree->deleting_rows[j];
+    }
+  }
+  return tree->num_deleting_rows;
+}
diff --git a/src/draft/glpapi06.c b/src/draft/glpapi06.c
index 635662e..ad6d55a 100644
--- a/src/draft/glpapi06.c
+++ b/src/draft/glpapi06.c
@@ -524,6 +524,7 @@ void glp_init_smcp(glp_smcp *parm)
       parm->shift = GLP_ON;
       parm->aorn = GLP_USE_NT;
 #endif
+      parm->stability_lmt = 200;
       return;
 }
 
diff --git a/src/draft/glpapi13.c b/src/draft/glpapi13.c
index 0ca2adf..c5d4af6 100644
--- a/src/draft/glpapi13.c
+++ b/src/draft/glpapi13.c
@@ -451,8 +451,14 @@ void glp_ios_row_attr(glp_tree *tree, int i, glp_attr *attr)
 
 int glp_ios_pool_size(glp_tree *tree)
 {     /* determine current size of the cut pool */
-      if (tree->reason != GLP_ICUTGEN)
-         xerror("glp_ios_pool_size: operation not allowed\n");
+      switch(tree->reason)
+      {  case GLP_ICUTGEN:
+         case GLP_ICUTADDED:
+         case GLP_ICUTSELECT:
+           break;
+         default:
+           xerror("glp_ios_pool_size: operation not allowed\n");
+      }
       xassert(tree->local != NULL);
 #ifdef NEW_LOCAL /* 02/II-2018 */
       return tree->local->m;
diff --git a/src/draft/ios.h b/src/draft/ios.h
index e2b47c6..2e61fdc 100644
--- a/src/draft/ios.h
+++ b/src/draft/ios.h
@@ -24,7 +24,7 @@
 
 #include "prob.h"
 
-#if 1 /* 02/II-2018 */
+#if 0 /* 02/II-2018 */ /* cvc5; NEW_LOCAL is not compatible with cut logging */
 #define NEW_LOCAL 1
 #endif
 
@@ -46,6 +46,9 @@ typedef struct IOSPOOL IOSPOOL;
 typedef struct IOSCUT IOSCUT;
 #endif
 
+
+typedef struct IOSAUX IOSAUX;
+
 struct glp_tree
 {     /* branch-and-bound tree */
       int magic;
@@ -223,6 +226,19 @@ struct glp_tree
          GLP_NO_BRNCH - use general selection technique */
       int child;
       /* subproblem reference number corresponding to br_sel */
+
+      /* start of cut log extras */
+      int br_result;
+      int br_to_up;
+      int br_node;
+      /* subproblem reference number for the just branched node.*/
+      int dn_child;
+      /* subproblem reference number for the just created down node */
+      int up_child;
+      /* subproblem reference number for the just created up node */
+
+      const int* deleting_rows;
+      int num_deleting_rows;
 };
 
 struct IOSLOT
@@ -235,6 +251,8 @@ struct IOSLOT
 
 struct IOSNPD
 {     /* node subproblem descriptor */
+      int ord;
+      /* this is a unique ordinal for each subproblem  */
       int p;
       /* subproblem reference number (it is the index to corresponding
          slot, i.e. slot[p] points to this descriptor) */
@@ -406,9 +424,47 @@ struct IOSCUT
       /* pointer to previous cut */
       IOSCUT *next;
       /* pointer to next cut */
+
+      IOSAUX *aux;
+      /* cut auxillary source information */
 };
 #endif
 
+struct IOSAUX
+{
+      /* aux (auxillary source information for each cut)
+       * Each cut operates on a sum of rows
+       * Each cut operates on a row that can be described using
+       * a current row or a previous cut.
+       * To generalize, we assume each row is a sum of two rows:
+       *   row[r]* r_mult + pool[c] * c_mult
+       */
+      int nrows;
+      int *rows;
+      double *mult;
+
+      int selected;
+      /* when < 0 this has not yet been turned into a row
+         when >=0 this is the id of the row added. */
+
+      double mir_delta;
+      /* the delta selected by a mir cut */
+
+      char *mir_cset;
+      /* complimented set */
+      /* if this is NULL, it is implicitly all 0s */
+
+      char *mir_subst;
+      /* the substition vectors */
+
+      int *mir_vlb_rows;
+      /* the substition vectors */
+
+      int *mir_vub_rows;
+      /* the substition vectors */
+};
+
+
 #define ios_create_tree _glp_ios_create_tree
 glp_tree *ios_create_tree(glp_prob *mip, const glp_iocp *parm);
 /* create branch-and-bound tree */
@@ -539,6 +595,31 @@ int ios_choose_node(glp_tree *T);
 int ios_choose_var(glp_tree *T, int *next);
 /* select variable to branch on */
 
+/* functions added to retrieve information */
+IOSAUX *ios_create_aux(int n, const int rows[], const double coeffs[]);
+/* creates an aux with n rows */
+
+void ios_delete_aux(IOSAUX *aux);
+/* deletes an aux */
+
+void ios_cut_set_single_aux(glp_tree *T, int ord, int j);
+/* sets the aux of row ord to be a single row j */
+
+
+void ios_cut_set_aux(glp_tree *T, int ord, int n,
+                     const int rows[], const double coeffs[]);
+/* sets an arbitrary aux sum */
+
+void ios_cut_set_aux_mir(glp_tree *T, int ord, double delta,
+                         const char cset[], const char subst[],
+                         const int vlbrs[], const int vubrs[]);
+/* sets the extra mir information */
+
+void ios_cut_set_selected(IOSCUT *cut, int i);
+/* the cut has been added as row i */
+
+void ios_cb_rows_deleted(glp_tree *T, int n, const int* rows);
+
 #endif
 
 /* eof */
diff --git a/src/draft/glpios01.c b/src/draft/glpios01.c
index f1ee43a..f32867d 100644
--- a/src/draft/glpios01.c
+++ b/src/draft/glpios01.c
@@ -175,6 +175,16 @@ glp_tree *ios_create_tree(glp_prob *mip, const glp_iocp *parm)
       tree->stop = 0;
       /* create the root subproblem, which initially is identical to
          the original MIP */
+
+      tree->br_result = 0;
+      tree->br_to_up = 0;
+      tree->br_node = 0;
+      tree->dn_child = 0;
+      tree->up_child = 0;
+
+      tree->deleting_rows = NULL;
+      tree->num_deleting_rows = 0;
+
       new_node(tree, NULL);
       return tree;
 }
@@ -294,6 +304,7 @@ void ios_revive_node(glp_tree *tree, int p)
             double *val;
             ind = xcalloc(1+n, sizeof(int));
             val = xcalloc(1+n, sizeof(double));
+            /* maintains the row order during revival */
             for (r = node->r_ptr; r != NULL; r = r->next)
             {  i = glp_add_rows(mip, 1);
                glp_set_row_name(mip, i, r->name);
@@ -473,6 +484,13 @@ void ios_freeze_node(glp_tree *tree)
             double *val;
             ind = xcalloc(1+n, sizeof(int));
             val = xcalloc(1+n, sizeof(double));
+            /* Added rows are stored in the same order!
+             * This is done by 2 reversals.
+             * - Going from i = m down pred_m.
+             * - Storing the list by a stack "push"
+             *   node->r_ptr = r;
+             *   r->next = node->r_ptr;
+             */
             for (i = m; i > pred_m; i--)
             {  GLPROW *row = mip->row[i];
                IOSROW *r;
@@ -517,6 +535,8 @@ void ios_freeze_node(glp_tree *tree)
             xassert(nrs > 0);
             num = xcalloc(1+nrs, sizeof(int));
             for (i = 1; i <= nrs; i++) num[i] = root_m + i;
+            /* To not call ios_cb_rows_deleted here.
+               These rows have been saved earlier. */
             glp_del_rows(mip, nrs, num);
             xfree(num);
          }
@@ -652,6 +672,9 @@ static IOSNPD *new_node(glp_tree *tree, IOSNPD *parent)
       tree->a_cnt++;
       tree->n_cnt++;
       tree->t_cnt++;
+
+      node->ord = tree->t_cnt;
+
       /* increase the number of child subproblems */
       if (parent == NULL)
          xassert(p == 1);
@@ -834,6 +857,8 @@ void ios_delete_tree(glp_tree *tree)
          xassert(nrs > 0);
          num = xcalloc(1+nrs, sizeof(int));
          for (i = 1; i <= nrs; i++) num[i] = tree->orig_m + i;
+         /* Do not call ios_cb_rows_deleted here.
+            This does not help log information. */
          glp_del_rows(mip, nrs, num);
          xfree(num);
       }
@@ -1477,6 +1502,7 @@ int ios_add_row(glp_tree *tree, IOSPOOL *pool,
       cut->rhs = rhs;
       cut->prev = pool->tail;
       cut->next = NULL;
+      cut->aux = NULL;
       if (cut->prev == NULL)
          pool->head = cut;
       else
@@ -1591,6 +1617,11 @@ void ios_del_row(glp_tree *tree, IOSPOOL *pool, int i)
          cut->ptr = aij->next;
          dmp_free_atom(tree->pool, aij, sizeof(IOSAIJ));
       }
+
+      if (cut->aux != NULL){
+        ios_delete_aux(cut->aux);
+      }
+
       dmp_free_atom(tree->pool, cut, sizeof(IOSCUT));
       pool->size--;
       return;
@@ -1624,6 +1655,10 @@ void ios_clear_pool(glp_tree *tree, IOSPOOL *pool)
             cut->ptr = aij->next;
             dmp_free_atom(tree->pool, aij, sizeof(IOSAIJ));
          }
+
+         if (cut->aux != NULL){
+           ios_delete_aux(cut->aux);
+         }
          dmp_free_atom(tree->pool, cut, sizeof(IOSCUT));
       }
       pool->size = 0;
@@
@@ glpios08 was split into src/cglib/{cfg2.c, clqcut.c} in GLPK 4.59
@@
@@ This code applies against glpios03 around GLPK 4.65.
@@
diff --git a/src/draft/glpios03.c b/src/draft/glpios03.c
index 2c1180f..a79c1c3 100644
--- a/src/draft/glpios03.c
+++ b/src/draft/glpios03.c
@@ -359,12 +394,12 @@ static void fix_by_red_cost(glp_tree *T)
 *  2 - both branches are hopeless and have been pruned; new subproblem
 *      selection is needed to continue the search. */
 
-static int branch_on(glp_tree *T, int j, int next)
+static int branch_on(glp_tree *T, int j, int next, int clone[], int* to_up)
 {     glp_prob *mip = T->mip;
       IOSNPD *node;
       int m = mip->m;
       int n = mip->n;
-      int type, dn_type, up_type, dn_bad, up_bad, p, ret, clone[1+2];
+      int type, dn_type, up_type, dn_bad, up_bad, p, ret;
       double lb, ub, beta, new_ub, new_lb, dn_lp, up_lp, dn_bnd, up_bnd;
       /* determine bounds and value of x[j] in optimal solution to LP
          relaxation of the current subproblem */
@@ -432,6 +467,7 @@ static int branch_on(glp_tree *T, int j, int next)
          else
             xassert(mip != mip);
          ret = 1;
+         *to_up = 0; /* up is bad. Do not go to up. */
          goto done;
       }
       else if (dn_bad)
@@ -450,6 +486,7 @@ static int branch_on(glp_tree *T, int j, int next)
          else
             xassert(mip != mip);
          ret = 1;
+         *to_up = 1; /* down is bad. Go to up. */
          goto done;
       }
       /* both down- and up-branches seem to be hopeful */
@@ -728,6 +765,15 @@ static void clq_gen(glp_tree *T, glp_cfg *G)
       if (len > 0)
          glp_ios_add_row(T, NULL, GLP_RF_CLQ, 0, len, ind, val, GLP_UP,
             val[0]);
+
+      /** callback for a cut being added to the cut pool */
+      if (T->parm->cb_func != NULL)
+      {  xassert(T->reason == GLP_ICUTGEN);
+         T->reason = GLP_ICUTADDED;
+         T->parm->cb_func(T, T->parm->cb_info);
+         T->reason = GLP_ICUTGEN;
+      }
+
       tfree(ind);
       tfree(val);
       return;
@@ -814,7 +860,8 @@ static void remove_cuts(glp_tree *T)
          }
       }
       if (cnt > 0)
-      {  glp_del_rows(T->mip, cnt, num);
+      {  ios_cb_rows_deleted(T, cnt, num);
+         glp_del_rows(T->mip, cnt, num);
 #if 0
          xprintf("%d inactive cut(s) removed\n", cnt);
 #endif
@@ -896,6 +943,7 @@ static void display_cut_info(glp_tree *T)
 
 int ios_driver(glp_tree *T)
 {     int p, curr_p, p_stat, d_stat, ret;
+      int branch_clones[1 + 2];
 #if 1 /* carry out to glp_tree */
       int pred_p = 0;
       /* if the current subproblem has been just created due to
@@ -1164,6 +1212,12 @@ more: /* minor loop starts here */
          if (T->parm->msg_lev >= GLP_MSG_DBG)
             xprintf("LP relaxation has no feasible solution\n");
          /* prune the branch */
+         if (T->parm->cb_func != NULL)
+         {  xassert(T->reason == 0);
+            T->reason = GLP_LI_CLOSE;
+            T->parm->cb_func(T, T->parm->cb_info);
+            T->reason = 0;
+         }
          goto fath;
       }
       else
@@ -1398,6 +1452,14 @@ more: /* minor loop starts here */
          ios_process_cuts(T);
          T->reason = 0;
       }
+      /* if the local cut pool is not empty and the callback func is there,
+         this gives the callback the chance to see what was selected. */
+      if (T->parm->cb_func != NULL && T->local->size > 0)
+      {  xassert(T->reason == 0);
+         T->reason = GLP_ICUTSELECT;
+         T->parm->cb_func(T, T->parm->cb_info);
+         T->reason = 0;
+      }
       /* clear the local cut pool */
       ios_clear_pool(T, T->local);
       /* perform re-optimization, if necessary */
@@ -1442,7 +1504,34 @@ more: /* minor loop starts here */
          T->br_var = ios_choose_var(T, &T->br_sel);
       /* perform actual branching */
       curr_p = T->curr->p;
-      ret = branch_on(T, T->br_var, T->br_sel);
+      xassert(T->br_to_up == 0);
+      ret = branch_on(T, T->br_var, T->br_sel, branch_clones, &T->br_to_up);
+      if (T->parm->cb_func != NULL)
+      {  xassert(T->reason == 0);
+         xassert(T->br_node == 0);
+         xassert(T->dn_child == 0);
+         xassert(T->up_child == 0);
+         // record a branch here
+         T->reason = GLP_LI_BRANCH;
+         // at this point T->br_var is the branching variable
+         T->br_node = curr_p;
+         T->br_result = ret;
+         if(ret == 0){
+           T->dn_child = branch_clones[1];
+           T->up_child = branch_clones[2];
+         }
+         T->parm->cb_func(T, T->parm->cb_info);
+         T->reason = 0;
+         T->br_node = 0;
+         T->dn_child = 0;
+         T->up_child = 0;
+         if (T->stop)
+         {  ret = GLP_ESTOP;
+            goto done;
+         }
+      }
+      T->br_to_up = 0;
+
       T->br_var = T->br_sel = 0;
       if (ret == 0)
       {  /* both branches have been created */
diff --git a/src/intopt/covgen.c b/src/intopt/covgen.c
index 986cf88..bfe708c 100644
--- a/src/intopt/covgen.c
+++ b/src/intopt/covgen.c
@@ -572,14 +572,14 @@ glp_cov *glp_cov_init(glp_prob *P)
       /* the set of "0-1 knapsack" inequalities has been built */
       if (csa.set->m == 0)
       {  /* the set is empty */
-         xprintf("No 0-1 knapsack inequalities detected\n");
+         /* xprintf("No 0-1 knapsack inequalities detected\n"); */
          cov = NULL;
          glp_delete_prob(csa.set);
       }
       else
       {  /* create the cover cut generator working area */
-         xprintf("Number of 0-1 knapsack inequalities = %d\n",
-            csa.set->m);
+         /* xprintf("Number of 0-1 knapsack inequalities = %d\n",
+            csa.set->m); */
          cov = talloc(1, glp_cov);
          cov->n = P->n;
          cov->set = csa.set;
%%
%% glpios05 was split into src/cglib/{gmicut.c, gmigen.c}
%% in GLPK 4.59
%%
%% src/cglib was renamed into src/intopt in GLPK 4.65
%%
diff --git a/src/intopt/gmicut.c b/src/intopt/gmicut.c
index ae75a8c..779beac 100644
--- a/src/intopt/gmicut.c
+++ b/src/intopt/gmicut.c
@@ -21,6 +21,7 @@
 
 #include "env.h"
 #include "prob.h"
+#include "ios.h"
 
 /***********************************************************************
 *  NAME
@@ -104,6 +105,9 @@ int glp_gmi_cut(glp_prob *P, int j,
       GLPAIJ *aij;
       int i, k, len, kind, stat;
       double lb, ub, alfa, beta, ksi, phi1, rhs;
+      int input_j;
+      input_j = j;
+
       /* sanity checks */
       if (!(P->m == 0 || P->valid))
       {  /* current basis factorization is not valid */
@@ -202,6 +206,7 @@ int glp_gmi_cut(glp_prob *P, int j,
                /* y[j] is integer */
                if (fabs(alfa - floor(alfa + 0.5)) < 1e-10)
                {  /* alfa[i,j] is close to nearest integer; skip it */
+                  /* printf("(skip)"); */
                   goto skip;
                }
                else if (f(alfa) <= f(beta))
@@ -237,6 +242,13 @@ int glp_gmi_cut(glp_prob *P, int j,
          }
 skip:    ;
       }
+      /* printf("\n"); */
+      /* for (i = 1; i <= m+n; i++) */
+      /* { */
+      /*   printf("%i %f, ", i, phi[i]); */
+      /* } */
+      /* printf("\n"); */
+
       /* now the cut has the form sum_k phi[k] * x[k] >= rho, where cut
        * coefficients are stored in the array phi in dense format;
        * x[1,...,m] are auxiliary variables, x[m+1,...,m+n] are struc-
@@ -276,6 +288,21 @@ skip:    ;
          rhs = 0.0;
       ind[0] = 0, val[0] = rhs;
       /* the cut has been successfully generated */
+
+      glp_tree *tree = P->tree;
+      int ord;
+      ord = glp_ios_add_row(tree, NULL, GLP_RF_GMI, 0, len, ind, val,
+                            GLP_LO, rhs);
+      /* printf("ord: % d beta %f\n", ord, beta); */
+      ios_cut_set_single_aux(tree, ord, input_j);
+
+      /** callback for a cut being added to the cut pool */
+      if (tree->parm->cb_func != NULL)
+      {  xassert(tree->reason == GLP_ICUTGEN);
+         tree->reason = GLP_ICUTADDED;
+         tree->parm->cb_func(tree, tree->parm->cb_info);
+         tree->reason = GLP_ICUTGEN;
+      }
       return len;
 }
 
diff --git a/src/intopt/mirgen.c b/src/intopt/mirgen.c
index 4467189..4b03dcb 100644
--- a/src/intopt/mirgen.c
+++ b/src/intopt/mirgen.c
@@ -123,6 +123,29 @@ struct glp_mir
       /* sparse vector of cutting plane coefficients, alpha[k] */
       double cut_rhs;
       /* right-hand size of the cutting plane, beta */
+
+      /*-------------------------------------------------------------*/
+      /* Extras I've added to reproduce a cut externally */
+      double cut_delta;
+      /* the delta used for generating the cut */
+      char *cut_cset; /* char cut_vec[1+m+n]; */
+      /* cut_cset[k], 1 <= k <= m+n, is set to true if structural
+         variable x[k] was complemented in the cut:
+         0 - x[k] has been not been complemented
+         non 0 - x[k] has been complemented */
+      int *vlb_rows; /* int vlb_rows[1+m+n]; */
+      /* vlb_rows[k], 1 <= k <= m+n,
+       * vlb_rows[k] <= 0 if virtual lower bound has not been set
+       * vlb_rows[k] = r if virtual lower bound was set using the row r
+       */
+      int *vub_rows; /* int vub_rows[1+m+n]; */
+      /* vub_rows[k], 1 <= k <= m+n,
+       * vub_rows[k] <= 0 if virtual upper bound has not been set
+       * vub_rows[k] = r if virtual upper bound was set using the row r
+       */
+
+      double *agg_coeffs;
+      /* coefficients used to multiply agg_coeffs */
 };
 
 /***********************************************************************
@@ -166,6 +189,7 @@ static void set_row_attrib(glp_prob *mip, glp_mir *mir)
                xassert(row != row);
          }
          mir->vlb[k] = mir->vub[k] = 0;
+         mir->vlb_rows[k] = mir->vub_rows[k] = 0;
       }
       return;
 }
@@ -200,6 +224,7 @@ static void set_col_attrib(glp_prob *mip, glp_mir *mir)
                xassert(col != col);
          }
          mir->vlb[k] = mir->vub[k] = 0;
+         mir->vlb_rows[k] = mir->vub_rows[k] = 0;
       }
       return;
 }
@@ -248,6 +273,7 @@ static void set_var_bounds(glp_prob *mip, glp_mir *mir)
             {  /* set variable lower bound for x1 */
                mir->lb[k1] = - a2 / a1;
                mir->vlb[k1] = k2;
+               mir->vlb_rows[k1]  = i;
                /* the row should not be used */
                mir->skip[i] = 1;
             }
@@ -258,6 +284,7 @@ static void set_var_bounds(glp_prob *mip, glp_mir *mir)
             {  /* set variable upper bound for x1 */
                mir->ub[k1] = - a2 / a1;
                mir->vub[k1] = k2;
+               mir->vub_rows[k1]  = i;
                /* the row should not be used */
                mir->skip[i] = 1;
             }
@@ -329,6 +356,13 @@ glp_mir *glp_mir_init(glp_prob *mip)
       mir->subst = xcalloc(1+m+n, sizeof(char));
       mir->mod_vec = spv_create_vec(m+n);
       mir->cut_vec = spv_create_vec(m+n);
+
+      /* added */
+      mir->cut_cset = xcalloc(1+m+n, sizeof(char));
+      mir->vlb_rows = xcalloc(1+m+n, sizeof(int));
+      mir->vub_rows = xcalloc(1+m+n, sizeof(int));
+      mir->agg_coeffs = xcalloc(1+MAXAGGR, sizeof(double));
+
       /* set global row attributes */
       set_row_attrib(mip, mir);
       /* set global column attributes */
@@ -426,6 +460,9 @@ static void initial_agg_row(glp_prob *mip, glp_mir *mir, int i)
       mir->skip[i] = 2;
       mir->agg_cnt = 1;
       mir->agg_row[1] = i;
+
+      mir->agg_coeffs[1] = +1.0;
+
       /* use x[i] - sum a[i,j] * x[m+j] = 0, where x[i] is auxiliary
          variable of row i, x[m+j] are structural variables */
       spv_clear_vec(mir->agg_vec);
@@ -805,19 +842,19 @@ static int CDECL cmir_cmp(const void *p1, const void *p2)
 
 static double cmir_sep(const int n, const double a[], const double b,
       const double u[], const double x[], const double s,
-      double alpha[], double *beta, double *gamma)
+      double alpha[], double *beta, double *gamma,
+      double* delta, char cset[])
 {     int fail, j, k, nv, v;
-      double delta, eps, d_try[1+3], r, r_best;
-      char *cset;
+      double eps, d_try[1+3], r, r_best;
       struct vset *vset;
       /* allocate working arrays */
-      cset = xcalloc(1+n, sizeof(char));
+      //cset = xcalloc(1+n, sizeof(char));
       vset = xcalloc(1+n, sizeof(struct vset));
       /* choose initial C */
       for (j = 1; j <= n; j++)
          cset[j] = (char)(x[j] >= 0.5 * u[j]);
       /* choose initial delta */
-      r_best = delta = 0.0;
+      r_best = (*delta) = 0.0;
       for (j = 1; j <= n; j++)
       {  xassert(a[j] != 0.0);
          /* if x[j] is close to its bounds, skip it */
@@ -830,16 +867,16 @@ static double cmir_sep(const int n, const double a[], const double b,
          /* compute violation */
          r = - (*beta) - (*gamma) * s;
          for (k = 1; k <= n; k++) r += alpha[k] * x[k];
-         if (r_best < r) r_best = r, delta = fabs(a[j]);
+         if (r_best < r) r_best = r, (*delta) = fabs(a[j]);
       }
       if (r_best < 0.001) r_best = 0.0;
       if (r_best == 0.0) goto done;
-      xassert(delta > 0.0);
+      xassert((*delta) > 0.0);
       /* try to increase violation by dividing delta by 2, 4, and 8,
          respectively */
-      d_try[1] = delta / 2.0;
-      d_try[2] = delta / 4.0;
-      d_try[3] = delta / 8.0;
+      d_try[1] = (*delta) / 2.0;
+      d_try[2] = (*delta) / 4.0;
+      d_try[3] = (*delta) / 8.0;
       for (j = 1; j <= 3; j++)
       {  /* construct c-MIR inequality */
          fail = cmir_ineq(n, a, b, u, cset, d_try[j], alpha, beta,
@@ -848,7 +885,7 @@ static double cmir_sep(const int n, const double a[], const double b,
          /* compute violation */
          r = - (*beta) - (*gamma) * s;
          for (k = 1; k <= n; k++) r += alpha[k] * x[k];
-         if (r_best < r) r_best = r, delta = d_try[j];
+         if (r_best < r) r_best = r, (*delta) = d_try[j];
       }
       /* build subset of variables lying strictly between their bounds
          and order it by nondecreasing values of |x[j] - u[j]/2| */
@@ -870,7 +907,7 @@ static double cmir_sep(const int n, const double a[], const double b,
          /* replace x[j] by its complement or vice versa */
          cset[j] = (char)!cset[j];
          /* construct c-MIR inequality */
-         fail = cmir_ineq(n, a, b, u, cset, delta, alpha, beta, gamma);
+         fail = cmir_ineq(n, a, b, u, cset, (*delta), alpha, beta, gamma);
          /* restore the variable */
          cset[j] = (char)!cset[j];
          /* do not replace the variable in case of failure */
@@ -881,10 +918,11 @@ static double cmir_sep(const int n, const double a[], const double b,
          if (r_best < r) r_best = r, cset[j] = (char)!cset[j];
       }
       /* construct the best c-MIR inequality chosen */
-      fail = cmir_ineq(n, a, b, u, cset, delta, alpha, beta, gamma);
+      fail = cmir_ineq(n, a, b, u, cset, (*delta), alpha, beta, gamma);
       xassert(!fail);
+
 done: /* free working arrays */
-      xfree(cset);
+
       xfree(vset);
       /* return to the calling routine */
       return r_best;
@@ -895,7 +933,8 @@ static double generate(glp_mir *mir)
       int m = mir->m;
       int n = mir->n;
       int j, k, kk, nint;
-      double s, *u, *x, *alpha, r_best = 0.0, b, beta, gamma;
+      double s, *u, *x, *alpha, r_best = 0.0, b, beta, gamma, delta;
+      char *cset;
       spv_copy_vec(mir->cut_vec, mir->mod_vec);
       mir->cut_rhs = mir->mod_rhs;
       /* remove small terms, which can appear due to substitution of
@@ -944,6 +983,7 @@ static double generate(glp_mir *mir)
       u = xcalloc(1+nint, sizeof(double));
       x = xcalloc(1+nint, sizeof(double));
       alpha = xcalloc(1+nint, sizeof(double));
+      cset = xcalloc(1+nint, sizeof(char));
       /* determine u and x */
       for (j = 1; j <= nint; j++)
       {  k = mir->cut_vec->ind[j];
@@ -1010,7 +1050,7 @@ static double generate(glp_mir *mir)
       /* apply heuristic to obtain most violated c-MIR inequality */
       b = mir->cut_rhs;
       r_best = cmir_sep(nint, mir->cut_vec->val, b, u, x, s, alpha,
-         &beta, &gamma);
+         &beta, &gamma, &delta, cset);
       if (r_best == 0.0) goto skip;
       xassert(r_best > 0.0);
       /* convert to raw cut */
@@ -1025,10 +1065,22 @@ static double generate(glp_mir *mir)
 #if MIR_DEBUG
       spv_check_vec(mir->cut_vec);
 #endif
+      /* added */
+      mir->cut_delta = delta;
+      // this is not a great place for resetting the array,
+      // but it should be sufficient
+      for (j = 1; j <= n+m;  j++)
+         mir->cut_cset[j] = 0;
+      for (j = 1; j <= nint; j++)
+      {  k = mir->cut_vec->ind[j];
+         xassert(m <= k  && k <= m+n);
+         mir->cut_cset[k] = cset[j];
+      }
 skip: /* free working arrays */
       xfree(u);
       xfree(x);
       xfree(alpha);
+      xfree(cset);
 done: return r_best;
 }
 
@@ -1236,8 +1288,25 @@ static void add_cut(glp_mir *mir, glp_prob *pool)
       ios_add_cut_row(tree, pool, GLP_RF_MIR, len, ind, val, GLP_UP,
          mir->cut_rhs);
 #else
-      glp_ios_add_row(tree, NULL, GLP_RF_MIR, 0, len, ind, val, GLP_UP,
+      int ord;
+      ord = glp_ios_add_row(tree, NULL, GLP_RF_MIR, 0, len, ind, val, GLP_UP,
          mir->cut_rhs);
+      ios_cut_set_aux(tree, ord, mir->agg_cnt, mir->agg_row, mir->agg_coeffs);
+      ios_cut_set_aux_mir(tree, ord, mir->cut_delta,
+                          mir->cut_cset, mir->subst,
+                          mir->vlb_rows, mir->vub_rows);
+
+      /** callback for a cut being added to the cut pool */
+      /* printf("mir tree parm %p %d\n", tree->parm->cb_func, ord); */
+      /* printf("  agg_rhs %f\n", mir->agg_rhs); */
+      /* printf("  mod_rhs %f\n", mir->mod_rhs); */
+      /* printf("  cut_rhs %f\n", mir->cut_rhs); */
+      if (tree->parm->cb_func != NULL)
+      {  xassert(tree->reason == GLP_ICUTGEN);
+         tree->reason = GLP_ICUTADDED;
+         tree->parm->cb_func(tree, tree->parm->cb_info);
+         tree->reason = GLP_ICUTGEN;
+      }
 #endif
 #else
       {  int i;
@@ -1265,6 +1334,7 @@ static int aggregate_row(glp_prob *mip, glp_mir *mir, SPV *v)
 #endif
       int ii, j, jj, k, kk, kappa = 0, ret = 0;
       double d1, d2, d, d_max = 0.0;
+      double guass_coeff;
       /* choose appropriate structural variable in the aggregated row
          to be substituted */
       for (j = 1; j <= mir->agg_vec->nnz; j++)
@@ -1369,8 +1439,9 @@ static int aggregate_row(glp_prob *mip, glp_mir *mir, SPV *v)
       xassert(j != 0);
       jj = v->pos[kappa];
       xassert(jj != 0);
-      spv_linear_comb(mir->agg_vec,
-         - mir->agg_vec->val[j] / v->val[jj], v);
+      guass_coeff = - mir->agg_vec->val[j] / v->val[jj];
+      mir->agg_coeffs[mir->agg_cnt] = guass_coeff;
+      spv_linear_comb(mir->agg_vec, guass_coeff, v);
 #if 0 /* 29/II-2016 by Chris */
       ios_delete_vec(v);
 #endif
@@ -1520,6 +1591,13 @@ void glp_mir_free(glp_mir *mir)
       xfree(mir->subst);
       spv_delete_vec(mir->mod_vec);
       spv_delete_vec(mir->cut_vec);
+
+      /* added */
+      xfree(mir->cut_cset);
+      xfree(mir->vlb_rows);
+      xfree(mir->vub_rows);
+      xfree(mir->agg_coeffs);
+
       xfree(mir);
       return;
 }
diff --git a/src/draft/glpios07.c b/src/draft/glpios07.c
index b8e700e..a246634 100644
--- a/src/draft/glpios07.c
+++ b/src/draft/glpios07.c
@@ -537,6 +537,14 @@ void ios_cov_gen(glp_tree *tree)
          /* add the cut to the cut pool */
          glp_ios_add_row(tree, NULL, GLP_RF_COV, 0, len, ind, val,
             GLP_UP, val[0]);
+
+         /** callback for a cut being added to the cut pool */
+         if (tree->parm->cb_func != NULL)
+         {  xassert(tree->reason == GLP_ICUTGEN);
+            tree->reason = GLP_ICUTADDED;
+            tree->parm->cb_func(tree, tree->parm->cb_info);
+            tree->reason = GLP_ICUTGEN;
+         }
       }
       /* free working arrays */
       xfree(ind);
diff --git a/src/draft/glpios11.c b/src/draft/glpios11.c
index e23b97f..13978d1 100644
--- a/src/draft/glpios11.c
+++ b/src/draft/glpios11.c
@@ -324,6 +324,9 @@ void ios_process_cuts(glp_tree *T)
          glp_set_mat_row(T->mip, i, len, ind, val);
          xassert(cut->type == GLP_LO || cut->type == GLP_UP);
          glp_set_row_bnds(T->mip, i, cut->type, cut->rhs, cut->rhs);
+
+         /* setting this as selected */
+         ios_cut_set_selected(cut, i);
       }
       /* free working arrays */
       xfree(info);
diff --git a/src/glpk.h b/src/glpk.h
index ea79ec2..5034199 100644
--- a/src/glpk.h
+++ b/src/glpk.h
@@ -140,6 +140,7 @@ typedef struct
       int aorn;               /* option to use A or N: */
 #define GLP_USE_AT         1  /* use A matrix in row-wise format */
 #define GLP_USE_NT         2  /* use N matrix in row-wise format */
+      int stability_lmt;      /* maximum number of check stability failures before stopping */
       double foo_bar[33];     /* (reserved) */
 #endif
 } glp_smcp;
@@ -238,6 +239,11 @@ typedef struct
 #define GLP_IBRANCH     0x05  /* request for branching */
 #define GLP_ISELECT     0x06  /* request for subproblem selection */
 #define GLP_IPREPRO     0x07  /* request for preprocessing */
+#define GLP_ICUTADDED   0x08  /* cut was added to the pool */
+#define GLP_ICUTSELECT  0x09  /* cuts were selected as rows */
+#define GLP_LI_BRANCH   0x10  /* a branch was made */
+#define GLP_LI_CLOSE    0x11  /* an active node was closed */
+#define GLP_LI_DELROW   0x12  /* an active node was closed */
 
 /* branch selection indicator: */
 #define GLP_NO_BRNCH       0  /* select no branch */
@@ -1164,6 +1170,54 @@ int glp_top_sort(glp_graph *G, int v_num);
 int glp_wclique_exact(glp_graph *G, int v_wgt, double *sol, int v_set);
 /* find maximum weight clique with exact algorithm */
 
+/*******************************************/
+/***               CUT LOG               ***/
+/*******************************************/
+
+int glp_get_it_cnt(glp_prob *P);
+/* get the iteration count of the current problem */
+
+
+int glp_ios_get_cut(glp_tree *T, int i, int ind[], double val[], int* klass, int* type, double* rhs);
+/* determine reason for calling the callback routine */
+
+int glp_ios_cut_get_aux_nrows(glp_tree *tree, int ord);
+/* gets the number of rows used to generate a cut. */
+
+
+void glp_ios_cut_get_aux_rows(glp_tree *tree, int ord,
+                              int rows[], double coeffs[]);
+/* gets a cut as an input sequence of rows times coefficients. */
+
+
+void glp_ios_cut_get_mir_cset(glp_tree *tree, int ord, char cset[]);
+/* gets mir cut complement set. */
+double glp_ios_cut_get_mir_delta(glp_tree *tree, int ord);
+/* gets mir cut delta. */
+void glp_ios_cut_get_mir_subst(glp_tree *tree, int ord, char subst[]);
+/* gets mir cut substition information. */
+void glp_ios_cut_get_mir_virtual_rows(glp_tree *tree, int ord,
+                                      int vlb_rows[], int vub_rows[]);
+/* gets mir cut virtual bounds rows. */
+
+int glp_ios_selected_cuts(glp_tree *tree, int ords[], int sel[]);
+/* gets the list of selected cuts.
+   Can only be called when GLP_ICUTSELECT */
+
+
+int glp_ios_branch_log(glp_tree *tree, double *val, int* parent, int* dn, int* up);
+/* can only be called when GLP_LI_BRANCH.
+ * If id is non-null, returns the id of the structural variable branched upon.
+ * If val is non-null, it is set to the value branched upon.
+ * If parent is non-null, it is set to node id of the node branched upon.
+ * If dn is non-null, it is set to node id of the newly created down node.
+ * If up is non-null, it is set to node id of the newly created up node.
+ */
+
+int glp_ios_node_ord(glp_tree *tree, int node_p);
+
+int glp_ios_rows_deleted(glp_tree *tree, int* rows);
+
 #ifdef __cplusplus
 }
 #endif
%%
%% Primal simplex method was reimplemented in 4.56
%%
diff --git a/src/simplex/spxprim.c b/src/simplex/spxprim.c
index d004197..31a1c7b 100644
--- a/src/simplex/spxprim.c
+++ b/src/simplex/spxprim.c
@@ -182,6 +182,10 @@ struct csa
       int ns_cnt, ls_cnt;
       /* normal and long-step iteration counts */
 #endif
+
+      /** Things Tim has added. */
+      int stability_failures;
+      int stability_lmt;
 };
 
 /***********************************************************************
@@ -1213,6 +1217,11 @@ loop: /* main loop starts here */
          if (perturb <= 0)
          {  if (check_feas(csa, csa->phase, tol_bnd, tol_bnd1))
             {  /* excessive bound violations due to round-off errors */
+               csa->stability_failures++;
+               if (csa->stability_failures >= csa->stability_lmt){
+                  ret = GLP_EINSTAB;
+                  goto fini;
+               }
 #if 1 /* 01/VII-2017 */
                if (perturb < 0)
                {  if (msg_lev >= GLP_MSG_ALL)
@@ -1760,6 +1769,8 @@ int spx_primal(glp_prob *P, const glp_smcp *parm)
 #if 1 /* 23/VI-2017 */
       csa->ns_cnt = csa->ls_cnt = 0;
 #endif
+      csa->stability_failures = 0;
+      csa->stability_lmt = parm->stability_lmt;
       /* try to solve working LP */
       ret = primal_simplex(csa);
       /* return basis factorization back to problem object */
%%
%% Dual simplex method was reimplemented in 4.57
%%
diff --git a/src/simplex/spydual.c b/src/simplex/spydual.c
index 770b621..f04afa7 100644
--- a/src/simplex/spydual.c
+++ b/src/simplex/spydual.c
@@ -197,6 +197,10 @@ struct csa
       int ns_cnt, ls_cnt;
       /* normal and long-step iteration count */
 #endif
+
+      /** Things Tim has added. */
+      int stability_failures;
+      int stability_lmt;
 };
 
 /***********************************************************************
@@ -1329,6 +1333,11 @@ loop: /* main loop starts here */
          {  if (check_feas(csa, tol_dj, tol_dj1, 0))
             {  /* dual feasibility is broken due to excessive round-off
                 * errors */
+               csa->stability_failures++;
+               if (csa->stability_failures >= csa->stability_lmt){
+                  ret = GLP_EINSTAB;
+                  goto fini;
+               }
                if (perturb < 0)
                {  if (msg_lev >= GLP_MSG_ALL)
                      xprintf("Perturbing LP to avoid instability [%d].."
@@ -2004,6 +2013,8 @@ int spy_dual(glp_prob *P, const glp_smcp *parm)
 #if 1 /* 23/III-2016 */
       csa->ns_cnt = csa->ls_cnt = 0;
 #endif
+      csa->stability_failures = 0;
+      csa->stability_lmt = parm->stability_lmt;
       /* try to solve working LP */
       ret = dual_simplex(csa);
       /* return basis factorization back to problem object */
