/******************************************************************************
 * Top contributors (to current version):
 *   Diego Della Rocca de Camargos
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2021 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * The module for printing dot proofs.
 */

#include "cvc5_private.h"

#ifndef CVC5__PROOF__DOT__DOT_PRINTER_H
#define CVC5__PROOF__DOT__DOT_PRINTER_H

#include <iostream>
#include <stack>

#include "printer/let_binding.h"
#include "proof/proof_node.h"

namespace cvc5::internal {
namespace proof {

/**
 * An enumeration for nodes clusterS type. Each type defines in which cluster
 * the node will be inserted when printed.
 */
enum class NodeClusterType : uint8_t
{
  // ======== First Scope
  // Type of node cluster that is always in the root of the graph.
  // The rule is always SCOPE.
  FIRST_SCOPE = 0,
  // ======== SAT
  // Type of node cluster that is between First Scope and CNF.
  // The rules are: CHAIN_RESOLUTION, FACTORING and REORDERING.
  SAT,
  // ======== CNF
  // Type of node cluster that is below SAT and above THEORY_LEMMA or
  // PRE_PROCESSING.
  // The rules are in the range between NOT_NOT_ELIM and CNF_ITE_NEG3.
  CNF,
  // ======== THEORY_LEMMA
  // Type of node cluster that is composed only by SCOPE nodes and stays in the
  // middle of the proof. The rules are always SCOPE.
  THEORY_LEMMA,
  // ======== PRE_PROCESSING
  // Type of node cluster that is in the middle of the proof.
  // The rules can be any type. The root node of this cluster can't be a SCOPE.
  // node.
  PRE_PROCESSING,
  // ======== INPUT
  // Type of node cluster that is always a leaf.
  // The rules are always ASSUME.
  INPUT,
  // ======== NOT_DEFINED
  NOT_DEFINED
};

class DotPrinter
{
 public:
  DotPrinter();
  ~DotPrinter();

  /**
   * Print the full proof of assertions => false by pn using the dot format.
   * @param out the output stream
   * @param pn the root node of the proof to print
   */
  void print(std::ostream& out, const ProofNode* pn);

 private:
  /**
   * Print the nodes of the proof in the format:
   * $NODE_ID [ label = "{$CONCLUSION|$RULE_NAME($RULE_ARGUMENTS)}",
   * $COLORS_AND_CLASSES_RELATED_TO_THE_RULE ]; and then for each child of the
   * node $CHILD_ID -> $NODE_ID; and then recursively calls the function with
   * the child as argument.
   * @param out the output stream
   * @param pn the proof node to print
   * @param pfLet the map of the hashs of proof nodes already printed to their
   * ids
   * @param parentType the type of the parent node
   * @param scopeCounter counter of how many SCOPE were already depth-first
   * traversed in the proof up to this point
   * @param inPropositionalView flag used to mark the proof node being traversed
   * was generated by the SAT solver and thus belong to the propositional view
   * @return the id of the proof node printed
   */
  uint64_t printInternal(std::ostream& out,
                         const ProofNode* pn,
                         std::map<size_t, uint64_t>& pfLet,
                         NodeClusterType parentType,
                         uint64_t scopeCounter,
                         bool inPropositionalView);

  /**
   * Print the nodes of the proof in the format:
   * $NODE_ID [ label = "{$CONCLUSION|$RULE_NAME($RULE_ARGUMENTS)}",
   * $COLORS_AND_CLASSES_RELATED_TO_THE_RULE ];
   * @param out the output stream
   * @param pn the proof node to print
   * @param currentRuleID the current rule ID
   * @param scopeCounter counter of how many SCOPE were already depth-first
   * traversed in the proof up to this point
   * @param inPropositionalView flag used to mark the proof node being traversed
   * was generated by the SAT solver and thus belong to the propositional view
   */
  inline void printNodeInfo(std::ostream& out,
                            const ProofNode* pn,
                            uint64_t currentRuleID,
                            uint64_t& scopeCounter,
                            bool& inPropositionalView);

  /**
   * Return the arguments of a ProofNode
   * @param currentArguments an ostringstream that will store the arguments of
   * pn formatted as "$ARG[0], $ARG[1], ..., $ARG[N-1]"
   * @param pn a ProofNode
   */
  void ruleArguments(std::ostringstream& currentArguments, const ProofNode* pn);

  /** Add an escape character before special characters of the given string.
   * @param s The string to have the characters processed.
   * @return The string with the special characters escaped.
   */
  static std::string sanitizeString(const std::string& s);

  /** As above, but quotes are doubly escaped. */
  static std::string sanitizeStringDoubleQuotes(const std::string& s);

  /** Traverse proof node and populate d_subpfCounter, mapping each proof node
   * to the number of subproofs it contains, including itself
   *
   * @param pn the proof node to be traversed
   */
  void countSubproofs(const ProofNode* pn);

  /** Traverse proof node and populate d_lbind
   *
   * @param pn The proof node to be traversed
   */
  void letifyResults(const ProofNode* pn);

  /** Define the proof node type and populate d_nodesClusterType and
   * d_scopesArgs.
   * @param pn The proof node to categorized.
   * @return the current node type
   */
  NodeClusterType defineNodeType(const ProofNode* pn, NodeClusterType last);

  /** Verify if the proof node is an input node
   * @param pn The proof node to be verified.
   * @return The bool indicating if the proof node is or not an input.
   */
  inline bool isInput(const ProofNode* pn);

  /** Verify if the rule is in the SAT range
   * @param pn The rule to be verified.
   * @return The bool indicating if the rule is or not in the SAT range.
   */
  inline bool isSat(const PfRule& rule);

  /** Verify if the rule is in the CNF range
   * @param pn The rule to be verified.
   * @return The bool indicating if the rule is or not in the CNF range.
   */
  inline bool isCNF(const PfRule& rule);

  /** Verify if the rule is a SCOPE
   * @param pn The rule to be verified.
   * @return The bool indicating if the rule is or not a SCOPE.
   */
  inline bool isSCOPE(const PfRule& rule);

  /** Verify if the rule is a ASSUME
   * @param pn The rule to be verified.
   * @return The bool indicating if the rule is or not an ASSUME.
   */
  inline bool isASSUME(const PfRule& rule);

  /** All unique subproofs of a given proof node (counting itself). */
  std::map<const ProofNode*, size_t> d_subpfCounter;

  /** Let binder for terms in proof nodes */
  LetBinding d_lbind;

  /** Counter that indicates the current rule ID */
  uint64_t d_ruleID;

  /** Vector that holds all the scopes args */
  std::vector<std::reference_wrapper<const std::vector<Node>>> d_scopesArgs;

  /** Array with all the subgraphs description strings */
  std::vector<std::ostringstream> d_subgraphsStr;
};

}  // namespace proof
}  // namespace cvc5::internal

#endif
