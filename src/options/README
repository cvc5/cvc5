Each options module starts with the following required attributes:

  id     ... (string) ID of the module (e.g., "ARITH")
  name   ... (string) name of the module (e.g., "Arithmetic Theory")
  header ... (string) name of the options header to generated (e.g., "options/arith_options.h")

Options can be defined with the [[option]] tag, the required attributes for an
option are:

  category ... (string) common | expert | regular | undocumented
  type     ... (string) C++ type of the option

Optional attributes are:

  name       ... (string) option name that is used to access via options::<name>()
  smt_name   ... (string) alternative name to access option via set-option/get-option commands
  short      ... (string) short option name consisting of one character (no - prefix required)
  long       ... (string) long option name (required if short is specified, no -- prefix required)
  default    ... (string) default value of type 'type'
  handler    ... (string) handler for parsing custom types
  predicates ... (list)   functions that check whether given value is valid
  includes   ... (list)   header files required by handler/predicates
  notifies   ... (list)   notifications to call when option is set
  links      ... (list)   additional options to set after this option is set
  read_only  ... (bool)   false if option can be set, true if option is read-only (default is false)
  alternate  ... (bool)   create --no- alternative option for bool options (default is true)
  help       ... (string) documentation (required for if category is not undocumented)


Note that if an option defines a long option name and type 'bool', mkoptions.py
automatically generates a --no-<long> option to set the option to false.
However, this does not consider linked options defined via attribute links.
TODO: use alias to overwrite default --no-<long> for adding --no- links.


Example:

  [[option]]
    name       = "outputLanguage"
    smt_name   = "output-language"
    category   = "common"
    short      = ""
    long       = "output-lang=LANG"
    type       = "OutputLanguage"
    default    = "language::output::LANG_AUTO"
    handler    = "stringToOutputLanguage"
    predicates = []
    includes   = ["options/language.h"]
    notifies   = []
    links      = []
    read_only  = false
    help       = "force output language (default is \"auto\"; see --output-lang help)"



Aliases can be defined with the [[alias]] tag, which creates a long option and
binds it to the list of long options specified via the 'links' attributes.

Example:

  [[alias]]
    category   = "regular"
    long       = "smtlib-strict"
    links      = ["--lang=smt2", "--output-lang=smt2", "--strict-parsing", "--default-expr-depth=-1", "--print-success", "--incremental", "--abstract-values"]
    help       = "SMT-LIBv2 compliance mode (implies other options)"


This example creates a regular option with the long option name 'smtlib-strict',
which links to the long options given as a list 'links'.
Calling

  --smtlib-strict

is equivalent to specifying the options

  --lang=smt2 --output-lang=smt2 --strict-parsing --default-expr-depth=-1 --print-success --incremental --abstract-values





The required attributes are:

#     The alias command creates a new short or long option, and binds it
#     to act the same way as if the options to the right of "=" were passed.
#     For example, if there are options to --disable-warning-1 and
#     --disable-warning-2, etc., a useful alias might be:
#
#       alias --disable-all-warnings = --disable-warning-1 --disable-warning-2
#
#     It's also possible to pass an argument through to another option.
#     This alias makes "--output-language" synonymous with "--output-lang".
#     Without the "=L" parts, --output-language would not take an argument,
#     and option processing would fail (because --output-lang expects one).
#
#       alias --output-language=L = --output-lang=L
#
#     You can also ignore such an argument:
#
#       alias --some-option=VALUE = --other-option --option2=foo --option3=bar
#
#     or use it for multiple options on the right-hand side, etc.

  category ... (string) common | expert | regular | undocumented
  long     ... (string) long option name
  links    ... (list)   list of long options to set

Optional attributes are:

  help     ... (string) documentation (required for if category is not undocumented)



Example:

[[option]]
  name       = "outputLanguage"
  smt_name   = "output-language"
  category   = "common"
  short      = ""
  long       = "output-lang=LANG"
  type       = "OutputLanguage"
  default    = "language::output::LANG_AUTO"
  handler    = "stringToOutputLanguage"
  predicates = []
  includes   = ["options/language.h"]
  notifies   = []
  links      = []
  read_only  = false
  help       = "force output language (default is \"auto\"; see --output-lang help)"

[[alias]]
  category   = "regular"
  long       = "smtlib-strict"
  links      = ["--lang=smt2", "--output-lang=smt2", "--strict-parsing", "--default-expr-depth=-1", "--print-success", "--incremental", "--abstract-values"]
  help       = "SMT-LIBv2 compliance mode (implies other options)"





Documentation from the old mkoptions script:

#
# Option specification file for CVC4
#
# This is essentially a shell script interpreted with special commands.
#
# Lines starting with whitespace are special.  They are passed in their entirety
# (minus the first whitespace char) to the "doc" command.  Lines starting with a
# single slash are stripped of this initial character and interpreted by the
# "doc-alt" command.  A period "." in the first column of a line, followed
# optionally by whitespace but without any other content on the line, is
# interpreted as an empty string passed to doc.  (This allows multi-paragraph
# documentation for options.)  Lines may be continued with a backslash (\) at the
# end of a line.
#
# commands are:
#
#   module ID "include-file" name
#
#     Identifies the module.  Must be the first command in the file.  ID is a
#     suitable identifier for a preprocessor definition, and should be unique;
#     name is a "pretty" name used for the benefit of the end CVC4 user in, e.g.,
#     option listings.
#
#   common-option SPECIFICATION
#   option SPECIFICATION
#   expert-option SPECIFICATION
#   undocumented-option SPECIFICATION
#
#     These commands declare (respectively) common options presented first to the
#     user, standard options that the user might want to see with "--help"
#     documentation, expert options that should be marked as expert-only, and
#     options that should not appear in normal option documentation (even if
#     documentation is included here).
#
#     SPECIFICATIONs take this form:
#
#       SPECIFICATION ::= (internal-name | -) [smt-option-name] [-short-option/-alternate-short-option] [--long-option/--alternate-long-option] C++-type [ATTRIBUTEs...]
#       ATTRIBUTE ::=   :include include-files..
#                     | :default C++-expression
#                     | :handler custom-option-handlers..
#                     | :handler-include include-files..
#                     | :predicate custom-option-handlers..
#                     | :predicate-include include-files..
#                     | :notify custom-option-notifications..
#                     | :read-only
#                     | :read-write
#                     | :link linked-options..
#                     | :link-smt linked-option [value]
#
#   common-alias ALIAS_SPECIFICATION
#   alias ALIAS_SPECIFICATION
#   expert-alias ALIAS_SPECIFICATION
#   undocumented-alias ALIAS_SPECIFICATION
#
#       ALIAS_SPECIFICATION ::=   (-short-option | --long-option) = (-option[=argument] | --long-option[=argument])+
#                               | (-short-option=ARG | --long-option=ARG) = (-option[=ARG|argument] | --long-option[=ARG|argument])+
#
#     The alias command creates a new short or long option, and binds it
#     to act the same way as if the options to the right of "=" were passed.
#     For example, if there are options to --disable-warning-1 and
#     --disable-warning-2, etc., a useful alias might be:
#
#       alias --disable-all-warnings = --disable-warning-1 --disable-warning-2
#
#     It's also possible to pass an argument through to another option.
#     This alias makes "--output-language" synonymous with "--output-lang".
#     Without the "=L" parts, --output-language would not take an argument,
#     and option processing would fail (because --output-lang expects one).
#
#       alias --output-language=L = --output-lang=L
#
#     You can also ignore such an argument:
#
#       alias --some-option=VALUE = --other-option --option2=foo --option3=bar
#
#     or use it for multiple options on the right-hand side, etc.
#
#   warning message
#
#     Warn about something during processing (like a FIXME).
#
#   endmodule
#
#     This file should end with the "endmodule" command, and nothing should
#     follow it.
#
#
#  The options/ package supports a wide range of operations for responding to
#  an option being set. Roughly the three major concepts are:
#  - :handler is to parse an option before setting its value.
#  - :predicate is to reject bad values for the option.
#  - :notify is used for dynamic dispatch after an option is assigned.
#
#  More details on each class of custom handlers.
#   :handler custom-option-handler
#    Handlers provide support for parsing custom types and parsing for options.
#    The signature for a handler call is:
#       T custom-option-handler(std::string option, std::string optarg,
#                               OptionsHandler* handler);
#    where T is the type of the option. The suggested implementation is to
#    implement custom-handler as a dispatch into a function on handler with the
#    signature:
#       T OptionsHandler::custom-option-handler(std::string option,
#                                               std::string optarg);
#    The handlers are run before predicates and notifications.
#    Having multiple handlers is considered bad practice and is unsupported.
#    Handlers may have arbitrary side effects, but should call no code
#    inaccessible to liboptions. For side effects that are not required in order
#    to parse the option, using :predicate is recommended. Use :notify to
#    achieve dynamic dispatch outside of base/, lib/, and options/. Memory
#    management done by a handler needs to either be encapsulated by the type
#    and the destructor for the type or should *always* be owned by handler. More
#    elaborate memory management schemes are not currently supported.
#
#   :predicate custom-predicate
#    Predicates provide support for checking whether or not the value of an
#    is acceptable. Predicates are run after handlers and before notifications.
#    The signature for a predicate call is:
#      void custom-predicate(std::string option, T value,
#                            OptionsHandler* handler);
#    where T is the type of the option. The suggested implementation is to
#    implement custom-predicate as a dispatch into a function on handler with the
#    signature:
#      void OptionsHandler::custom-predicate(std::string option, T value);
#    The predicates are run after handlers and before notifications. Multiple
#    predicates may be defined for the same option, but the order they are run
#    is not guaranteed. Predicates may have arbitrary side effects, but should
#    call no code inaccessible to liboptions. Use :notify to
#    achieve dynamic dispatch outside of base/, lib/, and options/.
#    Predicates are expected to reject bad value for the option by throwing an
#    OptionsException.
#
#   :notify custom-notification
#    This allows for the installation of custom post-processing callbacks using
#    the Listener infrastructure. custom-option-notification is a C++ function
#    that is called after the assignment of the option is updated.
#    The normal usage of an notify is to call a Listener that is registered for
#    this specific option. This is how dynamic dispatch outside of the
#    liboptions package should always be done.
#    The signature of custom-option-notification should take an option name as
#    well as an OptionsHandler*.
#      void custom-notification(
#        const std::string& option, CVC4::options::OptionsHandler* handler);
#    The name is provided so multiple options can use the same notification
#    implementation.
#    This is called after all handlers and predicates have been run.
#    Formally, this is always placed at the end of either the generated
#    Options::assign or Options::assignBool function for the option.
#    Because of this :notify cannot be used with void type options.
#    Users of this feature should *always* check the code generated in
#    builds/src/options/options.cpp for the correctness of the placement of the
#    generated code. The Listener notify() function is allowed to throw
#    an arbitrary std::exception.
#
