
; -- Core Normalization Rules --


; Note that the extract semantics (extract j i x)
; extracts the range [i..j]. Vide https://smtlib.cs.uiowa.edu/theories-FixedSizeBitVectors.shtml
; Also concat is big-endian.

(define-rule* ConcatFlatten
  ((xs ?BitVec :list)
   (s ?BitVec)
   (ys ?BitVec :list)
   (zs ?BitVec :list))
  (concat xs (concat s ys) zs)
  (concat xs s ys zs))
(define-rule ConcatExtractMerge
  ((xs ?BitVec :list)
   (s ?BitVec)
   (ys ?BitVec :list)
   (i Int) (j Int) (k Int)
  )
  (concat xs (extract k (+ j 1) s) (extract j i s) ys)
  (concat xs (extract k i s) ys))
; x[i..j][k..l] = x[i+k..i+l]
(define-rule* ExtractExtract
  ((x ?BitVec) (i Int) (j Int) (k Int) (l Int))
  (extract l k (extract j i x))
  (extract (+ i l) (+ i k) x))
(define-cond-rule ExtractWhole
  ((x ?BitVec) (n Int))
  (= n (bvsize x))
  (extract (- n 1) 0 x)
  x)
; Case 1: (< j n) so the extract is self contained
(define-cond-rule ExtractConcat1
  ((x ?BitVec) (xs ?BitVec :list)
  (i Int) (j Int))
  (<= j (bvsize x))
  (extract j i (concat xs x))
  (concat xs (extract j i x))
  )
; Case 2: (< i n) but (>= j n), the extract crosses the boundary into the next one.
; Note that we do not know the size of the element after x, so we leave it in (extract (concat ...)) form
(define-cond-rule ExtractConcat2
  ((x ?BitVec) (xs ?BitVec :list)
  (i Int) (j Int))
  (and (< i (bvsize x)) (>= j (bvsize x)))
  (extract j i (concat xs x))
  (concat
    (extract (- j (bvsize x)) 0 (concat xs))
    (extract (- (bvsize x) 1) i x))
  )
; Case 3: (>= i n) and (>= j n), extract elides x
(define-cond-rule ExtractConcat3
  ((x ?BitVec) (xs ?BitVec :list)
  (i Int) (j Int))
  (>= i (bvsize x))
  (extract j i (concat xs x))
  (extract (- j (bvsize x)) (- i (bvsize x)) (concat xs))
  )

; -- Operator Elimination Rules --

(define-rule UgtEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvugt x y)
  (bvult y x))
(define-rule UgeEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvuge x y)
  (bvule y x))
(define-rule SgtEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvsgt x y)
  (bvslt y x))
(define-rule SgeEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvsge x y)
  (bvsle y x))
(define-rule SltEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvslt x y)
  (bvult
		(bvadd x (bvshl (bv 1 (bvsize x)) (bv (- (bvsize x) 1) (bvsize x))) )
		(bvadd y (bvshl (bv 1 (bvsize x)) (bv (- (bvsize x) 1) (bvsize x))) )
  ))
(define-rule SleEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvsle x y)
  (not (bvslt y x)))

(define-rule RedorEliminate
  ((x ?BitVec))
  (bvredor x)
  (not (bvcomp x (bv 0 (bvsize x)))))
(define-rule RedandEliminate
  ((x ?BitVec))
  (bvredor x)
  (not (bvcomp x (not (bv 0 (bvsize x))))))

(define-rule SubEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvsub x y)
  (bvadd x (bvneg y)))
(define-rule UleEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvule x y)
  (not (bvult y x)))
(define-rule CompEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvcomp x y)
  (bvite (= x y) 1 0))
;TODO: shouldn't this be ite?

(define-cond-rule RepeatEliminate1
  ((x ?BitVec) (n Int))
  (> n 1)
  (repeat n x)
  (concat x (repeat (- n 1) x)))
(define-rule RepeatEliminate2
  ((x ?BitVec))
  (repeat 1 x)
  x)

(define-rule RotateLeftEliminate1
  ((x ?BitVec) (amount Int))
  (rotate_left amount x)
  (concat (extract (- (bvsize x) 1 amount) 0 x) (extract 0 amount x))
  )
(define-rule RotateLeftEliminate2
  ((x ?BitVec))
  (rotate_left 0 x)
  x)
(define-rule RotateRightEliminate1
  ((x ?BitVec) (amount Int))
  (rotate_right amount x)
  (concat (extract (- amount 1) 0 x) (extract (- (bvsize x) 1) amount x))
  )
(define-rule RotateRightEliminate2
  ((x ?BitVec))
  (rotate_right 0 x)
  x)

(define-rule NandEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvnand x y)
  (bvnot (bvand x y)))
(define-rule NorEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvnor x y)
  (bvnot (bvor x y)))
(define-rule XnorEliminate
  ((x ?BitVec) (y ?BitVec))
  (bvxnor x y)
  (bvnot (bvxor x y)))

(define-rule SdivEliminate
	((x ?BitVec) (y ?BitVec))
	(def
		(n (bvsize x))
		(xLt0 (= (extract (- n 1) (- n 1) x) (bv 1 1)))
		(yLt0 (= (extract (- n 1) (- n 1) y) (bv 1 1)))
		(rUdiv (bvudiv (ite xLt0 (bvneg x) x) (ite yLt0 (bvneg y) y)))
	)
	(bvsdiv x y)
	(ite (xor xLt0 yLt0) (bvneg rUdiv) rUdiv)
	)

(define-rule ZeroExtendEliminate
	((x ?BitVec) (n Int))
	(zero_extend n x)
	(concat (bv 0 n) x))
(define-rule SignExtendEliminate
	((x ?BitVec) (n Int))
	(def (s (bvsize x)))
	(sign_extend n x)
	(concat (repeat n (extract (- s 1) (- s 1) x)) x))

(define-rule UaddoEliminate
	((x ?BitVec) (y ?BitVec))
	(bvuaddo x y)
	(= (extract (bvsize x) (bvsize x)
			(bvadd (concat (bv 0 1) x) (concat (bv 0 1) y)))
		(bv 1 1)
	))
(define-rule SaddoEliminate
	((x ?BitVec) (y ?BitVec))
	(bvsaddo x y)
	(= (extract (- (bvsize x) 1) (- (bvsize x) 1)
			(bvadd (concat (bv 0 1) x) (concat (bv 0 1) y)))
		(bv 1 1)
	))

(define-rule SdivoEliminate
	((x ?BitVec) (y ?BitVec))
	(bvsdivo x y)
	(and
		(= x (concat (bv 1 1) (bv 0 (- (bvsize x) 1))))
		(= y (not (bv 0 (bvsize y))))
	))
(define-rule SmodEliminate
	((x ?BitVec) (y ?BitVec))
	(def
		(n (bvsize x))
		(xLt0 (= (extract (- n 1) (- n 1) x) (bv 1 1)))
		(yLt0 (= (extract (- n 1) (- n 1) y) (bv 1 1)))
		(xAbs (bvite xLt0 (bvneg x) x))
		(yAbs (bvite yLt0 (bvneg y) y))
		(u (bvurem xAbs yAbs))
	)
	(bvsmod x y)
	(ite (= u (bv 0 n))
		u
		(ite (and (not xLt0) (not yLt0))
			u
			(ite (and xLt0 (not yLt0))
				(bvadd (bvneg u) y)
				(ite (and (not xLt0) yLt0)
					(bvadd u y)
					(bvneg u)
				)
			)
		)
	))
(define-rule SremEliminate
	((x ?BitVec) (y ?BitVec))
	(def
		(n (bvsize x))
		(xLt0 (= (extract (- n 1) (- n 1) x) (bv 1 1)))
		(yLt0 (= (extract (- n 1) (- n 1) y) (bv 1 1)))
		(xAbs (bvite xLt0 (bvneg x) x))
		(yAbs (bvite yLt0 (bvneg y) y))
		(u (bvurem xAbs yAbs))
	)
	(bvsrem x y)
	(bvite xLt0 (bvneg u) u)
	)
; Unsigned multiplication overflow detection.
; See M.Gok, M.J. Schulte, P.I. Balzola, "Efficient integer multiplication
; overflow detection circuits", 2001.
; http://ieeexplore.ieee.org/document/987767
;(define-rule UmuloEliminate
;	((x ?BitVec) (y ?BitVec))
;	(bvumulo x y)
;
;	)

(define-rule UsuboEliminate
	((x ?BitVec) (y ?BitVec))
	(def
		(n (bvsize x))
		(s (bvsub (zero_extend x 1) (zero_extend y 1)))
	)
	(bvusubo x y)
	(= (extract (- n 1) (- n 1) s) (bv 1 1))
	)
; Overflow occurs when
; 1. (N - P) = P
; 2. (P - N) = N
(define-rule SsuboEliminate
	((x ?BitVec) (y ?BitVec))
	(def
		(n (bvsize x))
		(xLt0 (= (extract (- n 1) (- n 1) x) (bv 1 1)))
		(yLt0 (= (extract (- n 1) (- n 1) y) (bv 1 1)))
		(s (bvsub x y))
		(sLt0 (= (extract (- n 1) (- n 1) s) (bv 1 1)))
	)
	(bvssubo x y)
	(or
		(and xLt0 (not yLt0) (not sLt0))
		(and (not xLt0) yLt0 sLt0)
	))


; -- Simplification Rules --

(define-rule BvIteEqualChildren (
    (c (_ BitVec 1))
    (x ?BitVec)
  )
  (bvite c x x)
  x)
(define-rule BvIteConstChildren1 (
    (c (_ BitVec 1))
  )
  (bvite c (bv 0 1) (bv 1 1))
  (bvnot c))
(define-rule BvIteConstChildren2 (
    (c (_ BitVec 1))
  )
  (bvite c (bv 1 1) (bv 0 1))
  c)
(define-rule BvIteEqualCond1 (
    (c0 (_ BitVec 1))
    (t0 ?BitVec)
    (e0 ?BitVec)
    (e1 ?BitVec)
  )
  (bvite c0 (bvite c0 t0 e0) e1)
  (bvite c0 t0 e1))
(define-rule BvIteEqualCond2 (
    (c0 (_ BitVec 1))
    (t0 ?BitVec)
    (t1 ?BitVec)
    (e1 ?BitVec)
  )
  (bvite c0 t0 (bvite c0 t1 e1))
  (bvite c0 t0 e1))
(define-rule BvIteEqualCond3 (
    (c0 (_ BitVec 1))
    (t0 ?BitVec)
    (e0 ?BitVec)
    (t1 ?BitVec)
    (e1 ?BitVec)
  )
  (bvite c0 (bvite c0 t0 e0) (bvite c0 t1 e1))
  (bvite c0 t0 e1))
(define-rule BvIteMergeThenIf (
    (c0 (_ BitVec 1))
    (c1 ?BitVec)
    (t1 ?BitVec)
    (e1 ?BitVec)
  )
  (bvite c0 (bvite c1 t1 e1) t1)
  (bvite (bvand c0 (bvnot c1)) e1 t1))
(define-rule BvIteMergeElseIf (
    (c0 (_ BitVec 1))
    (c1 ?BitVec)
    (t1 ?BitVec)
    (e1 ?BitVec)
  )
  (bvite c0 (bvite c1 t1 e1) e1)
  (bvite (bvand c0 c1) t1 e1))
(define-rule BvIteMergeThenElse (
    (c0 (_ BitVec 1))
    (c1 ?BitVec)
    (t0 ?BitVec)
    (e1 ?BitVec)
  )
  (bvite c0 t0 (bvite c1 t0 e1))
  (bvite (bvnor c0 c1) e1 t0))
(define-rule BvIteMergeElseElse (
    (c0 (_ BitVec 1))
    (c1 ?BitVec)
    (t1 ?BitVec)
    (t0 ?BitVec)
  )
  (bvite c0 t0 (bvite c1 t1 t0))
  (bvite (bvand (bvnot c0) c1) t1 t0))


(define-cond-rule ShlByConst1
  ((x ?BitVec) (amount Int) (sz Int))
  (def (n (bvsize x)))
  (< amount n)
  (bvshl x (bv amount sz))
	(concat (extract n (- n 1 amount x) (bv 0 n)))
	)
(define-cond-rule ShlByConst2
  ((x ?BitVec) (amount Int) (sz Int))
  (>= amount (bvsize x))
  (bvshl x (bv amount sz))
  (bv 0 x))
(define-cond-rule LshrByConst1
  ((x ?BitVec) (amount Int) (sz Int))
  (def (n (bvsize x)))
  (< amount n)
  (bvlshr x (bv amount sz))
	(concat (bv 0 amount) (extract (- n 1) amount))
	)
(define-cond-rule LshrByConst2
  ((x ?BitVec) (amount Int) (sz Int))
  (>= amount (bvsize x))
  (bvlshr x (bv amount sz))
  (bv 0 x))
(define-cond-rule AshrByConst1
  ((x ?BitVec) (amount Int) (sz Int))
  (def (n (bvsize x)))
  (< amount n)
  (bvlshr x (bv amount sz))
	(concat
		(repeat amount (extract (- n 1) (- n 1) x))
		(extract (- n 1) amount)
	))
(define-cond-rule AshrByConst2
  ((x ?BitVec) (amount Int) (sz Int))
  (def (n (bvsize x)))
  (>= amount (bvsize x))
  (bvlshr x (bv amount sz))
  (repeat n (extract (- n 1) (- n 1) x)))

(define-rule* AndOrXorConcatPullUp1
	((x ?BitVec) (y ?BitVec) (ys ?BitVec :list))
	(def
		(nx (bvsize x))
		(ny (bvsize y))
	)
	(bvand x (concat ys y))
	(concat
		(bvand (extract (- nx 1) ny x) (concat ys)) ; Recur on this
		(bvand (extract (- ny 1) 0 x) y)
	))
(define-rule* AndOrXorConcatPullUp2
	((x ?BitVec) (y ?BitVec) (ys ?BitVec :list))
	(def
		(nx (bvsize x))
		(ny (bvsize y))
	)
	(bvor x (concat ys y))
	(concat
		(bvor (extract (- nx 1) ny x) (concat ys)) ; Recur on this
		(bvor (extract (- ny 1) 0 x) y)
	))
(define-rule* AndOrXorConcatPullUp3
	((x ?BitVec) (y ?BitVec) (ys ?BitVec :list))
	(def
		(nx (bvsize x))
		(ny (bvsize y))
	)
	(bvxor x (concat ys y))
	(concat
		(bvxor (extract (- nx 1) ny x) (concat ys)) ; Recur on this
		(bvxor (extract (- ny 1) 0 x) y)
	))


(define-rule BitwiseIdemp1 (
    (x ?BitVec)
  )
  (bvand x x) x)
(define-rule BitwiseIdemp2 (
    (x ?BitVec)
  )
  (bvor x x) x)

(define-rule XorDuplicate (
    (x ?BitVec)
  )
  (bvxor x x) (bv 0 (bvsize x)))

(define-rule BitwiseNotAnd (
    (x ?BitVec)
  )
  (bvand x (bvnot x)) (bv 0 (bvsize x)))
(define-rule BitwiseNotOr (
    (x ?BitVec)
  )
  (bvor x (bvnot x)) (not (bv 0 (bvsize x))))
(define-rule XorNot (
    (x ?BitVec)
    (y ?BitVec)
  )
  (bvxor (bvnot x) (bvnot y)) (bvxor x y))
(define-rule NotIdemp (
    (x ?BitVec)
  )
  (bvnot (bvnot x)) x)

(define-rule UltZero1
	((x ?BitVec))
	(bvult (bv 0 (bvsize x)) x)
	(distinct (bv 0 (bvsize x)) x)
	)
(define-rule UltZero2
	((x ?BitVec))
	(bvult x (bv 0 (bvsize x)))
	false
	)
(define-rule UltSelf (
    (x ?BitVec)
  )
  (bvult x x) false)
(define-rule SltSelf (
    (x ?BitVec)
  )
  (bvslt x x) false)
(define-rule UleSelf (
    (x ?BitVec)
  )
  (bvule x x) true)
(define-rule UleZero
	((x ?BitVec))
	(bvule x (bv 0 (bvsize x)))
	(= x (bv 0 (bvsize x)))
	)
(define-rule ZeroUle
	((x ?BitVec))
	(bvule (bv 0 (bvsize x)) x)
	true
	)
(define-rule LeSelf (
    (x ?BitVec)
  )
  (bvsle x x) true)

(define-rule UleMax (
    (x ?BitVec)
  )
  (bvule x (bv 1 (bvsize x))) true)
(define-rule NotUlt (
    (x ?BitVec)
    (y ?BitVec)
  )
  (not (bvult x y))
  (bvule y x))
(define-rule NotUle (
    (x ?BitVec)
    (y ?BitVec)
    )
  (not (bvule x y))
  (bvult y x))
(define-rule NotSlt (
    (x ?BitVec)
    (y ?BitVec)
  )
  (not (bvslt x y))
  (bvsle y x))
(define-rule NotSle (
    (x ?BitVec)
    (y ?BitVec)
    )
  (not (bvsle x y))
  (bvslt y x))

;(define-rule MultSlice
;	((x ?BitVec) (y ?BitVec))
;	(def
;		(n (bvsize x))
;		(xBot (extract (- (/ n 2) 1) 0 x))
;		(yBot (extract (- (/ n 2) 1) 0 y))
;		(xTop (extract (- n 1) (/ n 2) x))
;		(yTop (extract (- n 1) (/ n 2) y))
;		(zeros (bv 0 (/ n 2)))
;	)
;	(bvmul x y)
;	(add
;		(bvmul (concat zeros xBot) (concat zeros yBot))
;		(concat (bvmul yTop xBot) zeros)
;		(concat (bvmul xTop yBot) zeros)
;	))
; If the bit-vectors multiplied have enough leading zeros,
; we can determine that the top bits of the multiplication
; are zero and not compute them. Only apply for large bitwidths
; as this can interfere with other mult normalization rewrites such
; as flattening.
;(define-rule ExtractMultLeadingBit
;	(
;		(high Int) (low Int)
;		(x ?BitVec) (x1i Int) (x2 ?BitVec)
;		(y ?BitVec) (y1i Int) (y2 ?BitVec)
;		(x1in Int) (y1in Int)
;	)
;	(def
;		(n (bvsize x))
;	)
;	(and (>= n 64)
;	(extract high low (bvmul (concat (bv x1i x1in) x2) (concat (bv y1i y1in) y2)))
;	(bv 0 (+ (- high low) 1))
;	)


(define-rule NegIdemp (
    (x ?BitVec)
  )
  (bvneg (bvneg x))
  x)

; (x udiv 0) = 111...1
(define-rule UdivZero
	((x ?BitVec))
	(bvudiv x (bv 0 (bvsize x)))
	(bvnot (bv 0 (bvsize x)))
	)
; (x udiv 1) = x
(define-rule UdivOne
	((x ?BitVec))
	(bvudiv x (bv 1 (bvsize x)))
	x
	)
; (x urem 1) = 0
(define-rule UremOne
	((x ?BitVec))
	(bvurem x (bv 1 (bvsize x)))
	(bv 0 (bvsize x))
	)
; (x urem x) = 0
(define-rule UremSelf
	((x ?BitVec))
	(bvudiv x x)
	(bv 0 (bvsize x))
	)
; (0_k >> a) = 0_k
(define-rule ShiftZero1
	((n Int) (a ?BitVec))
	(bvshl (bv 0 n) a)
	(bv 0 n)
	)
(define-rule ShiftZero2
	((n Int) (a ?BitVec))
	(bvlshr (bv 0 n) a)
	(bv 0 n)
	)
(define-rule ShiftZero3
	((n Int) (a ?BitVec))
	(bvashr (bv 0 n) a)
	(bv 0 n)
	)

; (bvugt (bvurem T x) x)
;   ==>  (ite (= x 0_k) (bvugt T x) false)
;   ==>  (and (=> (= x 0_k) (bvugt T x)) (=> (not (= x 0_k)) false))
;   ==>  (and (=> (= x 0_k) (bvugt T x)) (= x 0_k))
;   ==>  (and (bvugt T x) (= x 0_k))
;   ==>  (and (bvugt T 0_k) (= x 0_k))
(define-rule UgtUrem
	((y ?BitVec) (x ?BitVec))
	(bvugt (bvurem y x) x)
	(and
		(bvugt y (bv 0 (bvsize y)))
		(= x (bvsize x))
	))

(define-rule UltOne
	((x ?BitVec))
	(bvult x (bv 1 (bvsize x)))
	(= x (bv 0 (bvsize x)))
	)
(define-rule SltZero
	((x ?BitVec))
	(def (n (bvsize x)))
	(bvslt x (bv 0 n))
	(= (extract (- n 1) (- n 1) x) (bv 1 1))
	)
(define-rule ZeroUlt
	((x ?BitVec))
	(bvult (bv 0 (bvsize x)) x)
	(not (= x (bv 0 (bvsize x))))
	)


; -- Normalization Rules --
(define-rule ExtractBitwiseAnd
	((x ?BitVec) (y ?BitVec) (i Int) (j Int))
	(extract i j (bvand x y))
	(bvand (extract i j x) (extract i j y))
	)
(define-rule ExtractBitwiseOr
	((x ?BitVec) (y ?BitVec) (i Int) (j Int))
	(extract i j (bvor x y))
	(bvor (extract i j x) (extract i j y))
	)
(define-rule ExtractBitwiseXor
	((x ?BitVec) (y ?BitVec) (i Int) (j Int))
	(extract i j (bvxor x y))
	(bvxor (extract i j x) (extract i j y))
	)
(define-rule ExtractNot
	((x ?BitVec) (i Int) (j Int))
	(extract i j (bvnot x))
	(bvnot (extract i j x))
	)

;(define-rule* ExtractArithAdd
;	((xs ?BitVec :list) (x ?BitVec) (ys ?BitVec :list) (zs ?BitVec :list) (i Int))
;	(extract i 0 (bvadd xs ))
;	)

; -- Others --

(define-rule bv-eq-refl ((t ?BitVec)) (= t t) true)
(define-rule bv-eq-symm ((t ?BitVec) (s ?BitVec)) (= t s) (= s t))
