# kinds [for builtin theory]
#
# This "kinds" file is written in TOML for
# declaring cvc5 kinds.  Comments are marked with #, as this line is.
#
# Every kinds file must contain a theory declaration:
#
#   [theory]
#   id = "THEORY_ID"
#   base_class = "T"
#   base_class_header = "header"
#   properties = ["property1", "property2", ...]
#   typechecker_header = "header"
#
#     Thereafter, ID is bound to your theory.  It becomes part of an
#     enumeration that identifies all theories.  If your theory has
#     several, distinct implementations, they still all share a kinds
#     file, a theory ID, all the defined kinds/operators/types for the
#     theory, typechecker, etc.  They should also share a base class
#     (that's the T above).  The header is the header for this base
#     class.
#
#     There are several basic properties, declared as part of the theory.
#     The current set of properties and their meanings are:
#
#       finite            the theory is finite
#       stable-infinite   the theory is stably infinite
#       polite            the theory is polite
#       parametric        the theory is parametric
#
#       check             the theory supports the check() function
#       propagate         the theory supports propagate() (and explain())
#       ppStaticLearn     the theory supports ppStaticLearn()
#       notifyRestart     the theory supports notifyRestart()
#       presolve          the theory supports presolve()
#       postsolve         the theory supports postsolve()
#
#     In the case of the "theory-supports-function" properties, you
#     need to declare these for your theory or the functions will not
#     be called!  This is used to speed up the core where functionality
#     is not needed.
#
#     typechecker_header declares that this theory's typechecker class is defined in the
#     given header.  (#include'd by the TypeChecker class in the expr
#     package.)
#
#   [rewriter] 
#   class  = "T"
#   header = "header"
#
#     This declares a rewriter class T for your theory, declared in
#     header. Your rewriter class provides four functions:
#
#       static void init();
#       static void shutdown();
#       static RewriteResponse preRewrite(TNode node);
#       static RewriteResponse postRewrite(TNode node);
#
#     ...BUT please note that init() and shutdown() may be removed in
#     future, so if possible, do not rely on them being called (and
#     implement them as a no-op).
#
#   The kinds pertaining to the theory will be stored in an array [[kinds]].
#   Every entry of the array [[kinds]] will have a base property type.
#   The other properties will vary according to the kind type being declared.
#   
#   [[kinds]]
#   type    = "variable"
#   name    = "K"
#   comment = "optional comment"
#
#     This declares a kind K that has no operator (it's conceptually a
#     VARIABLE).  This is appropriate for things like VARIABLE and
#     SKOLEM. The property comment is optional.
#
#   [[kinds]]
#   type     = "operator"
#   name     = "K"
#   children = # of children
#   comment  = "optional comment"
#
#     Declares a "built-in" operator kind K. Really this is the same
#     as "variable" except that it has an operator (automatically
#     generated by NodeManager).
#
#     You can specify an exact # of children required as the second
#     argument to the operator command.  In debug mode, assertions are
#     automatically included to ensure that no Nodes can ever be
#     created violating this.  (FIXME: the public Expr stuff should
#     enforce them regardless of whether debugging or not.)  For
#     example, a binary operator could be specified as:
#
#         [[kinds]]
#         type     = "operator"
#         name     = "LESS_THAN"
#         children = 2
#         comment  = "arithmetic comparison, x < y"
#
#     Alternatively, a range can be specified for #children as
#     "LB:[UB]", LB and UB representing lower and upper bounds on the
#     number of children (inclusive).  If there is no lower bound, put
#     a "1" (operators must have at least one child).  If there is no
#     upper bound, leave the colon after LB, but omit UB.  For example,
#     an N-ary operator might be defined as:
#
#         [[kinds]]
#         type     = "operator"
#         name     = "ADD"
#         children = "2:"
#         comment  = "addition on two or more arguments"
#
#   [[kinds]]
#   type     = "parameterized"
#   K1       = "K1"
#   K2       = "K2"
#   children = # of children
#   comment  = "optional comment"
#
#     Declares a "built-in" parameterized operator kind K1.  This is a
#     theory-specific APPLY, e.g., APPLY_UF, which applies its first
#     parameter (say, "f"), to its operands (say, "x" and "y", making
#     the full application "f(x,y)").  Nodes with such a kind will
#     have an operator (Node::hasOperator() returns true, and
#     Node::getOperator() returns the Node of functional type
#     representing "f" here), and the "children" are defined to be
#     this operator's parameters, and don't include the operator
#     itself (here, there are only two children "x" and "y").  The
#     operator ("f") should have kind K2 (and this should be enforced
#     by the custom typechecker, at present this isn't done uniformly
#     by the expression package).
#
#     LB and UB are the same as documented for the operator command,
#     except that parameterized operators may have zero children.  The
#     first parameter (the function being applied) does not count as a
#     child.
#
#     For consistency these should start with "APPLY_", but this is
#     not enforced.
#
#   [[kinds]]
#   type      = "constant"
#   name      = "K"
#   class_key = "class_key"
#   cpp_type  = "cpp_type"
#   hasher    = "hasher"
#   header    = "header"
#   comment   = "optional comment"
#
#     Declares a constant kind K.  class_key is the type of the forward declaration to
#     generate (e.g., `class`, `struct`). If class_key is `skip` then no forward
#     declaration is generated.  cpp_type is the C++ type representing the constant
#     internally (the type is expected to be in the cvc5 namespace), and header
#     is the header needed to define it.  Hasher is a hash functor type defined
#     like this:
#
#       struct MyHashFcn {
#         size_t operator()(const T& val) const;
#       };
#
#     For consistency, constants taking a non-void payload should
#     start with "CONST_", but this is not enforced.
#
#   typerule = "typechecker-class"
#
#     Declares that a kind K is typechecked by the typechecker-class.
#     Such structure can be used as optional part of any declared kind.
#     This class should be defined by the header given to the "typechecker", above.
#     The typechecker-class is used this way by the main TypeChecker code:
#
#       typechecker-class::computeType(NodeManager* nm, TNode n, bool check)
#
#     It returns TypeNode.  It should compute the type of n and return it,
#     and if "check" is true, should actually perform type checking instead
#     of simply type computation.
#     
#     Example of a typerule as part of a kind:
#     
#       [[kinds]]
#       type     = "parameterized"
#       K1       = "TABLE_PROJECT"
#       K2       = "TABLE_PROJECT_OP"
#       children = 1
#       comment  = "table projection"
#       typerule = "::cvc5::internal::theory::bags::TableProjectTypeRule"
#
#   [[kinds]]
#   type         = "sort"
#   name         = "K"
#   cardinality  = "cardinality"
#   well_founded = true or false
#   ground-term  = "ground-term" # if well-founded
#   header       = "header" # if well-founded
#   comment      = "optional comment"
#
#     This creates a kind K that represents a sort (a "type constant").
#     These kinds of types are "atomic" types; if you need to describe
#     a complex type that takes type arguments (like arrays), use
#     "operator"; if you need to describe one that takes "constant"
#     arguments (like bitvectors), use "constant", and if you invent
#     one that takes both, you could try "parameterized".  In those
#     cases, you'll want to provide a cardinality separately for your
#     type.
#
#     The cardinality argument is a nonnegative number (if the sort is
#     finite), or Cardinality::INTEGERS if the sort has the same
#     cardinality as the integers, or Cardinality::REALS if the sort
#     has the same cardinality as the reals.
#
#     If the sort is well-founded (i.e., there exist ground terms),
#     two extra arguments immediately follow---a C++ expression that
#     constructs a ground term (as a Node), and the header that must
#     be #included for that expression to compile.
#
#     For consistency, sorts should end with "_TYPE", but this is not
#     enforced.
#
#   [kinds.cardinality]
#   computer = "computer"
#   header   = "optional header"
#
#     This sub-property does not define a kind; the kind K needs to be
#     defined by one of the other structs above.  This property just
#     provides a cardinality for types of kind K.  The
#     "computer" is a C++ expression that will yield a
#     Cardinality for the type.  In that expression, the sequence of
#     characters "%TYPE%" will be rewritten with a variable containing
#     a TypeNode of kind K.  The optional "header" argument is an
#     include file necessary to compile the cardinality-computer
#     expression.
#
#     If the cardinality need not be computed per-type (i.e., it's the
#     same for all types of kind K, but the "sort" gesture above could
#     not be used---in which case it doesn't already have a registered
#     cardinality), you can simply construct a Cardinality temporary.
#     For example:
#
#       [[kinds]]
#       type     = "MY_TYPE" 
#       [kinds.cardinality]
#       computer = "Cardinality(Cardinality::INTEGERS)"
#
#     If not, you might opt to use a computer; a common place to put it
#     is with your type checker:
#
#       [[kinds]]
#       type     = "MY_TYPE" 
#       [kinds.cardinality]
#       computer = "::cvc5::internal::theory::foo::TheoryFoo::CardinalityComputer(%TYPE%)"
#       header   = "theory/foo/theory_foo_type_rules.h"
#
#   [kinds.well-founded]
#   wellfoundedness-computer = "wellfoundedness-computer"
#   ground-term-computer     = "ground-term-computer"
#   header                   = "optional header"
#
#     Analogous to the "cardinality" command above, the well-founded
#     command provides a well-foundedness computer for the type.  A
#     ground term computer is required unless the
#     wellfoundedness-computer is the constant "false".  The ground
#     term computer should return a Node, and it should return the
#     same Node each time for a given type (although usually it's only
#     ever called once anyway since the result is cached).
#
# The expr package guarantees that Nodes built with kinds have the
# following constraints imposed on them.  (The #children guarantee
# only holds when assertions are turned on.)
#
#   Node meta-kind      has operator?      # children
#   ==================  =================  =======================
#   variable            no                 zero
#   operator            yes                as documented above
#   parameterized       yes                as documented above
#   constant            no                 zero
#

# theory ID T header
[theory]
id                 = "THEORY_BUILTIN"
base_class         = "::cvc5::internal::theory::builtin::TheoryBuiltin"
base_class_header  = "theory/builtin/theory_builtin.h"
properties         = ["stable-infinite"]
typechecker_header = "theory/builtin/theory_builtin_type_rules.h"

# rewriter T header
# Rewriter responsible for all the terms of the theory
[rewriter]
class  = "::cvc5::internal::theory::builtin::TheoryBuiltinRewriter"
header = "theory/builtin/theory_builtin_rewriter.h"

# sort K cardinality [well-founded ground-term header | not-well-founded] ["comment"]
[[kinds]]
type          = "sort"
name          = "BUILTIN_OPERATOR_TYPE"
cardinality   = "Cardinality::INTEGERS"
well_founded  = false
comment       = "the type for built-in operators"

# variable K ["comment"]
[[kinds]]
type    = "variable"
name    = "SORT_TYPE"
comment = "specifies types of user-declared 'uninterpreted' sorts"
# The cardinality of uninterpreted sorts is defined infinite here, although they are given special treatment in TypeNode::getCardinalityClass
# cardinality K cardinality-computer [header]
[kinds.cardinality]
computer = "Cardinality(Cardinality::INTEGERS)"
# well-founded K wellfoundedness-computer ground-term-computer [header]
[kinds.well-founded]
wellfoundedness-computer = "::cvc5::internal::theory::builtin::SortProperties::isWellFounded(%TYPE%)"
ground-term-computer     = "::cvc5::internal::theory::builtin::SortProperties::mkGroundTerm(%TYPE%)"
header                   = "theory/builtin/theory_builtin_type_rules.h"
[kinds.enumerator]
class  = "::cvc5::internal::theory::builtin::UninterpretedSortEnumerator"
header = "theory/builtin/type_enumerator.h"

# an instantiated sort has the same properties as an ordinary uninterpreted sort
[[kinds]]
type     = "operator"
name     = "INSTANTIATED_SORT_TYPE"
children = "1:"
comment  = "instantiated uninterpreted sort"
[kinds.cardinality]
computer = "Cardinality(Cardinality::INTEGERS)"
[kinds.well-founded]
wellfoundedness-computer = "::cvc5::internal::theory::builtin::SortProperties::isWellFounded(%TYPE%)"
ground-term-computer     = "::cvc5::internal::theory::builtin::SortProperties::mkGroundTerm(%TYPE%)"
header                   = "theory/builtin/theory_builtin_type_rules.h"
[kinds.enumerator]
class  = "::cvc5::internal::theory::builtin::UninterpretedSortEnumerator"
header = "theory/builtin/type_enumerator.h"

[[kinds]]
type      = "constant"
name      = "UNINTERPRETED_SORT_VALUE"
class_key = "class"
cpp_type  = "UninterpretedSortValue"
hasher    = "::cvc5::internal::UninterpretedSortValueHashFunction"
header    = "util/uninterpreted_sort_value.h"
comment   = "the kind of expressions representing uninterpreted sort values; payload is an instance of the cvc5::internal::AbstractValue class (used in models)"
typerule  = "::cvc5::internal::theory::builtin::UninterpretedSortValueTypeRule"

# A kind representing "inlined" operators defined with OPERATOR
# Conceptually, (EQUAL a b) is actually an (APPLY EQUAL a b), but it's
# not stored that way.  If you ask for the operator of (EQUAL a b),
# you'll get a special, singleton (BUILTIN EQUAL) Node.
#   constant K F T Hasher header ["comment"]

[[kinds]]
type      = "constant"
name      = "BUILTIN"
class_key = "skip"
cpp_type  = "Kind"
hasher    = "::cvc5::internal::kind::KindHashFunction"
header    = "expr/kind.h"
comment   = "the kind of expressions representing built-in operators"

[[kinds]]
type    = "operator"
name     = "EQUAL"
children = 2 
comment  = "equality (two parameters only, sorts must match)"
typerule = "::cvc5::internal::theory::builtin::EqualityTypeRule"

[[kinds]]
type    = "variable"
name    = "VARIABLE"
comment = "a variable (not permitted in bindings)"

[[kinds]]
type    = "variable"
name    = "BOUND_VARIABLE"
comment = "a bound variable (permitted in bindings and the associated lambda and quantifier bodies only)"

[[kinds]]
type    = "variable"
name    = "SKOLEM"
comment = "a Skolem variable"

[[kinds]]
type    = "variable"
name    = "DUMMY_SKOLEM"
comment = "a Skolem variable (internal only)"

[[kinds]]
type     = "operator"
name     = "SEXPR"
children = "0:"
comment  = "a symbolic expression (any arity)"
typerule = "::cvc5::internal::theory::builtin::SExprTypeRule"

[[kinds]]
type     = "operator"
name     = "WITNESS"
children = "2:3"
comment  = "a witness expression; first parameter is a BOUND_VAR_LIST, second is the witness body"
typerule = "::cvc5::internal::theory::builtin::WitnessTypeRule"

[[kinds]]
type      = "constant"
name      = "TYPE_CONSTANT"
class_key = "skip"
cpp_type  = "TypeConstant"
hasher    = "::cvc5::internal::TypeConstantHashFunction"
header    = "expr/kind.h"
comment   = "a representation for basic types"

[[kinds]]
type         = "sort"
name         = "SEXPR_TYPE"
cardinality  = "Cardinality::INTEGERS"
well_founded = false
comment      = "the type of a symbolic expression"

[[kinds]]
type    = "variable"
name    = "RAW_SYMBOL"
comment = "a variable that is not quoted in the smt2 printer (internal only)"

[[kinds]]
type      = "constant"
name      = "ABSTRACT_TYPE"
class_key = "class"
cpp_type  = "AbstractType"
hasher    = "::cvc5::internal::AbstractTypeHashFunction"
header    = "theory/builtin/abstract_type.h"
comment   = "abstract type"
[kinds.cardinality]
computer  = "Cardinality(Cardinality::INTEGERS)"

[[kinds]]
type      = "constant"
name      = "APPLY_INDEXED_SYMBOLIC_OP"
class_key = "class"
cpp_type  = "GenericOp"
hasher    = "::cvc5::internal::GenericOpHashFunction"
header    = "theory/builtin/generic_op.h"
comment   = "operator for the bit-vector extract; payload is an instance of the cvc5::internal::GenericOp class"
typerule  = "SimpleTypeRule<RBuiltinOperator>"

# parameterized K1 K2 #children ["comment"]
[[kinds]]
type     = "parameterized"
K1       = "APPLY_INDEXED_SYMBOLIC"
K2       = "APPLY_INDEXED_SYMBOLIC_OP" 
children = "1:"
comment  = "generic indexed operator, whose arguments are the list of terms corresponding to (symbolic) indices to the operator followed by its normal arguments"
typerule = "::cvc5::internal::theory::builtin::ApplyIndexedSymbolicTypeRule"

# constants
[[kinds]]
type      = "constant"
name      = "SORT_TO_TERM"
class_key = "class"
cpp_type  = "SortToTerm"
hasher    = "::cvc5::internal::SortToTermHashFunction"
header    = "expr/sort_to_term.h"
comment   = "term representing a sort; payload is an instance of the cvc5::internal::SortToTerm class"
typerule  = "SimpleTypeRule<RBuiltinOperator>"

[[kinds]]
type     = "operator"
name     = "TYPE_OF"
children = 1
comment  = "the type of an expression, used internally for RARE"
typerule = "::cvc5::internal::theory::builtin::TypeOfTypeRule"
