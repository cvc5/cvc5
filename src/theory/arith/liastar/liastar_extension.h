/******************************************************************************
 * Top contributors (to current version):
 *   Mudathir Mohamed
 *
 * This file is part of the cvc5 project.
 *
 * Copyright (c) 2009-2025 by the authors listed in the file AUTHORS
 * in the top-level source directory and their institutional affiliations.
 * All rights reserved.  See the file COPYING in the top-level source
 * directory for licensing information.
 * ****************************************************************************
 *
 * Extension to the theory of arithmetic handling lia star operator.
 */

#ifndef CVC5__THEORY__ARITH__LIASTAR_EXTENSION_H
#define CVC5__THEORY__ARITH__LIASTAR_EXTENSION_H

#include <map>
#include <vector>

#include "expr/node.h"
#include "smt/env_obj.h"
#include "theory/arith/liastar/liastar_ext_theory_callback.h"
#include "theory/ext_theory.h"
#include "theory/theory.h"
#include "util/result.h"

namespace cvc5::internal {
namespace theory {
namespace arith {

class InferenceManager;
class TheoryArith;

namespace liastar {

// Arbitraryâ€‘precision integers.
typedef mpz_class Integer;
// type the constraint matrix
typedef std::vector<std::vector<Integer>> Matrix;
typedef std::vector<Node> Vector;
/** Liastar extension class
 *
 * This class implements model-based refinement schemes
 * for liastar formulas.
 *
 * - Levatich, M., Bjorner, N., Piskac, R., Shoham, S. (2020).
 *   Solving LIA* Using Approximations.
 *   VMCAI 2020.
 *   https://doi.org/10.1007/978-3-030-39322-9_17
 *
 * It's main functionality is a check(...) method,
 * which is called by TheoryArithPrivate either:
 * (1) at full effort with no conflicts or lemmas emitted, or
 * (2) at last call effort.
 * In this method, this class calls d_im.lemma(...)
 * for valid arithmetic theory lemmas, based on the current set of assertions,
 * where d_im is the inference manager of TheoryArith.
 */
class LiaStarExtension : EnvObj
{
  typedef context::CDHashSet<Node> NodeSet;

 public:
  LiaStarExtension(Env& env, TheoryArith& containing);
  ~LiaStarExtension();
  /**
   * Does non-context dependent setup for a node connected to a theory.
   */
  void preRegisterTerm(TNode n);

  /**
   * Performs the main checks for liastar arithmetic, based on the current
   * (linear) arithmetic model from `arithModel`. This method may already send
   * lemmas, but most lemmas are buffered and sent at LAST_CALL effort by
   * TheoryArith. The motivation for this strategy is to allow other
   * non-terminating theories (e.g. quantifiers, strings) to run full effort
   * checks, before sending the lemmas generated by liastar.
   *
   * The argument arithModel is a map of the form { v1 -> c1, ..., vn -> cn }
   * which represents the linear arithmetic theory solver's contribution to the
   * current candidate model where v1, ..., vn are arithmetic variables and
   * c1, ..., cn are constants.
   */
  void checkFullEffort(std::map<Node, Node>& arithModel,
                       const std::set<Node>& termSet);

  /** Does this class need a call to check(...) at last call effort? */
  bool hasLiaStarTerms() const { return d_hasLiaStarTerms; }

 private:
  /** get assertions
   *
   * Let M be the set of assertions known by THEORY_ARITH. This function adds a
   * set of literals M' to assertions such that M' and M are equivalent.
   *
   * Examples of how M' differs with M:
   * (1) M' may not include t < c (in M) if t < c' is in M' for c' < c, where
   * c and c' are constants,
   * (2) M' may contain t = c if both t >= c and t <= c are in M.
   */
  void getAssertions(std::vector<Node>& assertions);

  Node isNotZeroVector(Node v);

  /**
   * Argument n must be a node of the form (int.star-contains ((x1 Int) ... (xn
   * Int)) p v) This functions convert the predicate p (which in QFLIA) to a
   * list of matrices representing a disjunction of set of inequalities in
   * Normaliz matrix form A x b >= 0 where A is a matrix and x = (x1 ... xn 1).
   * This form is used
   */
  const std::vector<std::pair<Matrix, Node>> convertQFLIAToMatrices(Node n);

  /**
   * This function returns a list of matrices representing cones (disjunctions)
   * where the rows of each matrix are constraints of the form a1 x_1 + ... +
   * an_xn + b >= 0
   * @param variables is a node of Kind BOUND_VAR_LIST
   * @param predicate is a LIA predicate in DNF format
   */
  std::vector<std::pair<Matrix, Node>> getMatrices(Node variables,
                                                   Node predicate);

  /** node manager */
  NodeManager* d_nm;
  /** commonly used terms */
  Node d_true;
  Node d_false;
  Node d_zero;
  Node d_one;
  // The theory of arithmetic containing this extension.
  TheoryArith& d_arith;
  /** A reference to the arithmetic state object */
  TheoryState& d_astate;
  InferenceManager& d_im;
  /**
   * The number of times we have the called main check method
   * (modelBasedRefinement). This counter is used for interleaving strategies.
   */
  unsigned d_checkCounter;
  LiaStarExtTheoryCallback d_extTheoryCb;
  /** Extended theory, responsible for context-dependent simplification. */
  ExtTheory d_extTheory;
  /** Do we have any liaStar terms? */
  context::CDO<bool> d_hasLiaStarTerms;
  std::vector<Node> d_processedStarTerms;

}; /* class LiaStarExtension */

}  // namespace liastar
}  // namespace arith
}  // namespace theory
}  // namespace cvc5::internal

#endif /* CVC5__THEORY__ARITH__LIASTAR_EXTENSION_H */
