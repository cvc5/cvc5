(include "../theories/Builtin.eo")
(include "../theories/Arrays.eo")
(include "../theories/Arith.eo")
(include "../theories/Reals.eo")
(include "../theories/Transcendentals.eo")
(include "../theories/BitVectors.eo")
(include "../theories/Strings.eo")
(include "../theories/Sets.eo")

(declare-rule arith-plus-zero ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t1 s2)
  :conclusion (= ($singleton_elim (+ t1 0 s1)) ($singleton_elim (+ t1 s1)))
)
(declare-rule arith-mul-one ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t3 s4)
  :conclusion (= ($singleton_elim (* t1 1 s1)) ($singleton_elim (* t1 s1)))
)
(declare-rule arith-mul-zero ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s1 @T1 :list))
  :args (t5 s6)
  :conclusion (= ($singleton_elim (* t1 0 s1)) 0)
)
(declare-rule arith-div-total ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :premises ((= (= s1 0) false))
  :args (t7 s8)
  :conclusion (= (/ t1 s1) (/_total t1 s1))
)
(declare-rule arith-int-div-total ((t1 Int) (s1 Int))
  :premises ((= (= s1 0) false))
  :args (t9 s10)
  :conclusion (= (div t1 s1) (div_total t1 s1))
)
(declare-rule arith-int-div-total-one ((t1 Int))
  :args (t11)
  :conclusion (= (div_total t1 1) t1)
)
(declare-rule arith-int-div-total-zero ((t1 Int))
  :args (t12)
  :conclusion (= (div_total t1 0) 0)
)
(declare-rule arith-int-mod-total ((t1 Int) (s1 Int))
  :premises ((= (= s1 0) false))
  :args (t13 s14)
  :conclusion (= (mod t1 s1) (mod_total t1 s1))
)
(declare-rule arith-int-mod-total-one ((t1 Int))
  :args (t15)
  :conclusion (= (mod_total t1 1) 0)
)
(declare-rule arith-int-mod-total-zero ((t1 Int))
  :args (t16)
  :conclusion (= (mod_total t1 0) t1)
)
(declare-rule arith-neg-neg-one ((@T0 Type) (t1 @T0))
  :args (t17)
  :conclusion (= (* (- 1) (* (- 1) t1)) t1)
)
(declare-rule arith-elim-uminus ((@T0 Type) (t1 @T0))
  :args (t18)
  :conclusion (= (- t1) (* (- 1) t1))
)
(declare-rule arith-elim-minus ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t19 s20)
  :conclusion (= (- t1 s1) (+ t1 (* (- 1) s1)))
)
(declare-rule arith-elim-gt ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t21 s22)
  :conclusion (= (> t1 s1) (not (<= t1 s1)))
)
(declare-rule arith-elim-lt ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t23 s24)
  :conclusion (= (< t1 s1) (not (>= t1 s1)))
)
(declare-rule arith-elim-int-gt ((t1 Int) (s1 Int))
  :args (t25 s26)
  :conclusion (= (> t1 s1) (>= t1 (+ s1 1)))
)
(declare-rule arith-elim-int-lt ((t1 Int) (s1 Int))
  :args (t27 s28)
  :conclusion (= (< t1 s1) (>= s1 (+ t1 1)))
)
(declare-rule arith-elim-leq ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t29 s30)
  :conclusion (= (<= t1 s1) (>= s1 t1))
)
(declare-rule arith-leq-norm ((t1 Int) (s1 Int))
  :args (t31 s32)
  :conclusion (= (<= t1 s1) (not (>= t1 (+ s1 1))))
)
(declare-rule arith-geq-tighten ((t1 Int) (s1 Int))
  :args (t33 s34)
  :conclusion (= (not (>= t1 s1)) (>= s1 (+ t1 1)))
)
(declare-rule arith-geq-norm1 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t35 s36)
  :conclusion (= (>= t1 s1) (>= (- t1 s1) 0))
)
(declare-rule arith-geq-norm2 ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t37 s38)
  :conclusion (= (>= t1 s1) (<= (- t1) (- s1)))
)
(declare-rule arith-refl-leq ((@T0 Type) (t1 @T0))
  :args (t39)
  :conclusion (= (<= t1 t1) true)
)
(declare-rule arith-refl-lt ((@T0 Type) (t1 @T0))
  :args (t40)
  :conclusion (= (< t1 t1) false)
)
(declare-rule arith-refl-geq ((@T0 Type) (t1 @T0))
  :args (t41)
  :conclusion (= (>= t1 t1) true)
)
(declare-rule arith-refl-gt ((@T0 Type) (t1 @T0))
  :args (t42)
  :conclusion (= (> t1 t1) false)
)
(declare-rule arith-real-eq-elim ((t1 Real) (s1 Real))
  :args (t43 s44)
  :conclusion (= (= t1 s1) (and (>= t1 s1) (<= t1 s1)))
)
(declare-rule arith-int-eq-elim ((t1 Int) (s1 Int))
  :args (t45 s46)
  :conclusion (= (= t1 s1) (and (>= t1 s1) (<= t1 s1)))
)
(declare-rule arith-plus-flatten ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (xs1 @T0 :list) (w1 @T1) (ys1 @T2 :list) (zs1 @T3 :list))
  :args (xs47 w48 ys49 zs50)
  :conclusion (= ($singleton_elim (+ xs1 ($singleton_elim (+ w1 ys1)) zs1)) ($singleton_elim (+ xs1 w1 ys1 zs1)))
)
(declare-rule arith-mult-flatten ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (xs1 @T0 :list) (w1 @T1) (ys1 @T2 :list) (zs1 @T3 :list))
  :args (xs51 w52 ys53 zs54)
  :conclusion (= ($singleton_elim (* xs1 ($singleton_elim (* w1 ys1)) zs1)) ($singleton_elim (* xs1 w1 ys1 zs1)))
)
(declare-rule arith-mult-dist ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x1 @T0) (y1 @T1) (z1 @T2) (w1 @T3 :list))
  :args (x55 y56 z57 w58)
  :conclusion (= (* x1 (+ y1 z1 w1)) (+ (* x1 y1) (* x1 ($singleton_elim (+ z1 w1)))))
)
(declare-rule arith-plus-cancel1 ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (t1 @T0 :list) (x1 @T1) (s1 @T2 :list) (r1 @T3 :list))
  :args (t59 x60 s61 r62)
  :conclusion (= (+ t1 x1 s1 (* (- 1) x1) r1) ($singleton_elim (+ t1 s1 r1)))
)
(declare-rule arith-plus-cancel2 ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (t1 @T0 :list) (x1 @T1) (s1 @T2 :list) (r1 @T3 :list))
  :args (t63 x64 s65 r66)
  :conclusion (= (+ t1 (* (- 1) x1) s1 x1 r1) ($singleton_elim (+ t1 s1 r1)))
)
(declare-rule arith-abs-elim ((@T0 Type) (x1 @T0))
  :args (x67)
  :conclusion (= (abs x1) (ite (< x1 0) (- x1) x1))
)
(declare-rule arith-to-real-elim ((x1 Real))
  :args (x68)
  :conclusion (= (to_real x1) x1)
)
(declare-rule arith-to-int-elim-to-real ((@T0 Type) (x1 @T0))
  :args (x69)
  :conclusion (= (to_int (to_real x1)) (to_int x1))
)
(declare-rule arith-div-elim-to-real1 ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x70 y71)
  :conclusion (= (/ (to_real x1) y1) (/ x1 y1))
)
(declare-rule arith-div-elim-to-real2 ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x72 y73)
  :conclusion (= (/ x1 (to_real y1)) (/ x1 y1))
)
(declare-rule array-read-over-write ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (t1 (Array @T0 @T1)) (i1 @T2) (e1 @T3))
  :args (t84 i85 e86)
  :conclusion (= (select (store t1 i1 e1) i1) e1)
)
(declare-rule array-read-over-write2 ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (@T4 Type) (t1 (Array @T0 @T1)) (i1 @T2) (j1 @T3) (e1 @T4))
  :premises ((= (= i1 j1) false))
  :args (t87 i88 j89 e90)
  :conclusion (= (select (store t1 i1 e1) j1) (select t1 j1))
)
(declare-rule array-store-overwrite ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (@T4 Type) (t1 (Array @T0 @T1)) (i1 @T2) (e1 @T3) (f1 @T4))
  :args (t91 i92 e93 f94)
  :conclusion (= (store (store t1 i1 e1) i1 f1) (store t1 i1 f1))
)
(declare-rule array-store-self ((@T0 Type) (@T1 Type) (@T2 Type) (t1 (Array @T0 @T1)) (i1 @T2))
  :args (t95 i96)
  :conclusion (= (store t1 i1 (select t1 i1)) t1)
)
(declare-rule bool-double-not-elim ((t1 Bool))
  :args (t98)
  :conclusion (= (not (not t1)) t1)
)
(declare-rule bool-not-true ((t1 Bool))
  :premises ((= t1 false))
  :args (t99)
  :conclusion (= (not t1) true)
)
(declare-rule bool-not-false ((t1 Bool))
  :premises ((= t1 true))
  :args (t100)
  :conclusion (= (not t1) false)
)
(declare-rule bool-eq-true ((t1 Bool))
  :args (t101)
  :conclusion (= (= t1 true) t1)
)
(declare-rule bool-eq-false ((t1 Bool))
  :args (t102)
  :conclusion (= (= t1 false) (not t1))
)
(declare-rule bool-eq-nrefl ((x1 Bool))
  :args (x103)
  :conclusion (= (= x1 (not x1)) false)
)
(declare-rule bool-impl-false1 ((t1 Bool))
  :args (t104)
  :conclusion (= (=> t1 false) (not t1))
)
(declare-rule bool-impl-false2 ((t1 Bool))
  :args (t105)
  :conclusion (= (=> false t1) true)
)
(declare-rule bool-impl-true1 ((t1 Bool))
  :args (t106)
  :conclusion (= (=> t1 true) true)
)
(declare-rule bool-impl-true2 ((t1 Bool))
  :args (t107)
  :conclusion (= (=> true t1) t1)
)
(declare-rule bool-impl-elim ((t1 Bool) (s1 Bool))
  :args (t108 s109)
  :conclusion (= (=> t1 s1) (or (not t1) s1))
)
(declare-rule bool-or-true ((xs1 Bool :list) (ys1 Bool :list))
  :args (xs110 ys111)
  :conclusion (= ($singleton_elim (or xs1 true ys1)) true)
)
(declare-rule bool-or-false ((xs1 Bool :list) (ys1 Bool :list))
  :args (xs112 ys113)
  :conclusion (= ($singleton_elim (or xs1 false ys1)) ($singleton_elim (or xs1 ys1)))
)
(declare-rule bool-or-flatten ((xs1 Bool :list) (b1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs114 b115 ys116 zs117)
  :conclusion (= ($singleton_elim (or xs1 ($singleton_elim (or b1 ys1)) zs1)) ($singleton_elim (or xs1 b1 ys1 zs1)))
)
(declare-rule bool-or-dup ((xs1 Bool :list) (b1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs118 b119 ys120 zs121)
  :conclusion (= (or xs1 b1 ys1 b1 zs1) ($singleton_elim (or xs1 b1 ys1 zs1)))
)
(declare-rule bool-and-true ((xs1 Bool :list) (ys1 Bool :list))
  :args (xs122 ys123)
  :conclusion (= ($singleton_elim (and xs1 true ys1)) ($singleton_elim (and xs1 ys1)))
)
(declare-rule bool-and-false ((xs1 Bool :list) (ys1 Bool :list))
  :args (xs124 ys125)
  :conclusion (= ($singleton_elim (and xs1 false ys1)) false)
)
(declare-rule bool-and-flatten ((xs1 Bool :list) (b1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs126 b127 ys128 zs129)
  :conclusion (= ($singleton_elim (and xs1 ($singleton_elim (and b1 ys1)) zs1)) ($singleton_elim (and xs1 b1 ys1 zs1)))
)
(declare-rule bool-and-dup ((xs1 Bool :list) (b1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs130 b131 ys132 zs133)
  :conclusion (= (and xs1 b1 ys1 b1 zs1) ($singleton_elim (and xs1 b1 ys1 zs1)))
)
(declare-rule bool-and-conf ((xs1 Bool :list) (w1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs134 w135 ys136 zs137)
  :conclusion (= (and xs1 w1 ys1 (not w1) zs1) false)
)
(declare-rule bool-or-taut ((xs1 Bool :list) (w1 Bool) (ys1 Bool :list) (zs1 Bool :list))
  :args (xs138 w139 ys140 zs141)
  :conclusion (= (or xs1 w1 ys1 (not w1) zs1) true)
)
(declare-rule bool-or-de-morgan ((x1 Bool) (y1 Bool) (zs1 Bool :list))
  :args (x142 y143 zs144)
  :conclusion (= (not (or x1 y1 zs1)) (and (not x1) (not ($singleton_elim (or y1 zs1)))))
)
(declare-rule bool-implies-de-morgan ((x1 Bool) (y1 Bool))
  :args (x145 y146)
  :conclusion (= (not (=> x1 y1)) (and x1 (not y1)))
)
(declare-rule bool-and-de-morgan ((x1 Bool) (y1 Bool) (zs1 Bool :list))
  :args (x147 y148 zs149)
  :conclusion (= (not (and x1 y1 zs1)) (or (not x1) (not ($singleton_elim (and y1 zs1)))))
)
(declare-rule bool-xor-refl ((x1 Bool))
  :args (x150)
  :conclusion (= (xor x1 x1) false)
)
(declare-rule bool-xor-nrefl ((x1 Bool))
  :args (x151)
  :conclusion (= (xor x1 (not x1)) true)
)
(declare-rule bool-xor-false ((x1 Bool))
  :args (x152)
  :conclusion (= (xor x1 false) x1)
)
(declare-rule bool-xor-true ((x1 Bool))
  :args (x153)
  :conclusion (= (xor x1 true) (not x1))
)
(declare-rule bool-xor-comm ((x1 Bool) (y1 Bool))
  :args (x154 y155)
  :conclusion (= (xor x1 y1) (xor y1 x1))
)
(declare-rule bool-xor-elim ((x1 Bool) (y1 Bool))
  :args (x156 y157)
  :conclusion (= (xor x1 y1) (= (not x1) y1))
)
(declare-rule bool-not-xor-elim ((x1 Bool) (y1 Bool))
  :args (x158 y159)
  :conclusion (= (not (xor x1 y1)) (= x1 y1))
)
(declare-rule bool-not-eq-elim ((x1 Bool) (y1 Bool))
  :args (x160 y161)
  :conclusion (= (not (= x1 y1)) (= (not x1) y1))
)
(declare-rule ite-neg-branch ((c1 Bool) (x1 Bool) (y1 Bool))
  :premises ((= (not y1) x1))
  :args (c162 x163 y164)
  :conclusion (= (ite c1 x1 y1) (= c1 x1))
)
(declare-rule ite-then-true ((c1 Bool) (x1 Bool))
  :args (c165 x166)
  :conclusion (= (ite c1 true x1) (or c1 x1))
)
(declare-rule ite-else-false ((c1 Bool) (x1 Bool))
  :args (c167 x168)
  :conclusion (= (ite c1 x1 false) (and c1 x1))
)
(declare-rule ite-then-false ((c1 Bool) (x1 Bool))
  :args (c169 x170)
  :conclusion (= (ite c1 false x1) (and (not c1) x1))
)
(declare-rule ite-else-true ((c1 Bool) (x1 Bool))
  :args (c171 x172)
  :conclusion (= (ite c1 x1 true) (or (not c1) x1))
)
(declare-rule ite-then-lookahead-self ((c1 Bool) (x1 Bool))
  :args (c173 x174)
  :conclusion (= (ite c1 c1 x1) (ite c1 true x1))
)
(declare-rule ite-else-lookahead-self ((c1 Bool) (x1 Bool))
  :args (c175 x176)
  :conclusion (= (ite c1 x1 c1) (ite c1 x1 false))
)
(declare-rule bool-not-ite-elim ((c1 Bool) (x1 Bool) (y1 Bool))
  :args (c177 x178 y179)
  :conclusion (= (not (ite c1 x1 y1)) (ite c1 (not x1) (not y1)))
)
(declare-rule ite-true-cond ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x190 y191)
  :conclusion (= (ite true x1 y1) x1)
)
(declare-rule ite-false-cond ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x192 y193)
  :conclusion (= (ite false x1 y1) y1)
)
(declare-rule ite-not-cond ((@T0 Type) (@T1 Type) (c1 Bool) (x1 @T0) (y1 @T1))
  :args (c194 x195 y196)
  :conclusion (= (ite (not c1) x1 y1) (ite c1 y1 x1))
)
(declare-rule ite-eq-branch ((@T0 Type) (c1 Bool) (x1 @T0))
  :args (c197 x198)
  :conclusion (= (ite c1 x1 x1) x1)
)
(declare-rule ite-then-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c199 x200 y201 z202)
  :conclusion (= (ite c1 (ite c1 x1 y1) z1) (ite c1 x1 z1))
)
(declare-rule ite-else-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c203 x204 y205 z206)
  :conclusion (= (ite c1 x1 (ite c1 y1 z1)) (ite c1 x1 z1))
)
(declare-rule ite-then-neg-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c207 x208 y209 z210)
  :conclusion (= (ite c1 (ite (not c1) x1 y1) z1) (ite c1 y1 z1))
)
(declare-rule ite-else-neg-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c1 Bool) (x1 @T0) (y1 @T1) (z1 @T2))
  :args (c211 x212 y213 z214)
  :conclusion (= (ite c1 x1 (ite (not c1) y1 z1)) (ite c1 x1 y1))
)
(declare-rule bv-concat-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (s1 (BitVec @n1)) (ys1 (BitVec @n2) :list) (zs1 (BitVec @n3) :list))
  :args (xs216 s217 ys218 zs219)
  :conclusion (= ($singleton_elim (concat xs1 ($singleton_elim (concat s1 ys1)) zs1)) ($singleton_elim (concat xs1 s1 ys1 zs1)))
)
(declare-rule bv-concat-extract-merge ((@n0 Int) (@n1 Int) (@n2 Int) (xs1 (BitVec @n0) :list) (s1 (BitVec @n1)) (ys1 (BitVec @n2) :list) (i1 Int) (j1 Int) (j2 Int) (k1 Int))
  :premises ((= j2 (+ j1 1)))
  :args (xs220 s221 ys222 i223 j224 j1225 k226)
  :conclusion (= (concat xs1 (extract k1 j2 s1) (extract j1 i1 s1) ys1) ($singleton_elim (concat xs1 (extract k1 i1 s1) ys1)))
)
(declare-rule bv-extract-extract ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (j1 Int) (k1 Int) (l1 Int))
  :args (x227 i228 j229 k230 l231)
  :conclusion (= (extract l1 k1 (extract j1 i1 x1)) (extract (+ i1 l1) (+ i1 k1) x1))
)
(declare-rule bv-extract-whole ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :premises ((= (>= n1 (- (@bvsize x1) 1)) true))
  :args (x232 n233)
  :conclusion (= (extract n1 0 x1) x1)
)
(declare-rule bv-extract-concat-1 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (xs1 (BitVec @n1) :list) (y1 (BitVec @n2)) (i1 Int) (j1 Int))
  :premises ((= (<= j1 (@bvsize x1)) true))
  :args (x234 xs235 y236 i237 j238)
  :conclusion (= (extract j1 i1 (concat xs1 y1 x1)) (extract j1 i1 x1))
)
(declare-rule bv-extract-concat-2 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (xs1 (BitVec @n1) :list) (y1 (BitVec @n2)) (i1 Int) (j1 Int))
  :premises ((= (< i1 (@bvsize x1)) true) (= (>= j1 (@bvsize x1)) true))
  :args (x239 xs240 y241 i242 j243)
  :conclusion (= (extract j1 i1 (concat xs1 y1 x1)) (eo::define ((_let_1 (@bvsize x1))) (concat (extract (- j1 _let_1) 0 ($singleton_elim (concat xs1 y1))) (extract (- _let_1 1) i1 x1))))
)
(declare-rule bv-extract-concat-3 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (xs1 (BitVec @n2) :list) (i1 Int) (j1 Int))
  :premises ((= (>= i1 (@bvsize x1)) true))
  :args (x244 y245 xs246 i247 j248)
  :conclusion (= (extract j1 i1 (concat xs1 y1 x1)) (eo::define ((_let_1 (@bvsize x1))) (extract (- j1 _let_1) (- i1 _let_1) ($singleton_elim (concat xs1 y1)))))
)
(declare-rule bv-extract-concat-4 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (xs1 (BitVec @n2) :list) (i1 Int) (j1 Int))
  :premises ((= (< j1 (- (@bvsize (concat x1 xs1 y1)) (@bvsize x1))) true))
  :args (x249 y250 xs251 i252 j253)
  :conclusion (= (extract j1 i1 (concat x1 xs1 y1)) (extract j1 i1 ($singleton_elim (concat xs1 y1))))
)
(declare-rule bv-extract-bitwise-and ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (i1 Int) (j1 Int))
  :args (x254 y255 i256 j257)
  :conclusion (= (extract j1 i1 (bvand x1 y1)) (bvand (extract j1 i1 x1) (extract j1 i1 y1)))
)
(declare-rule bv-extract-bitwise-or ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (i1 Int) (j1 Int))
  :args (x258 y259 i260 j261)
  :conclusion (= (extract j1 i1 (bvor x1 y1)) (bvor (extract j1 i1 x1) (extract j1 i1 y1)))
)
(declare-rule bv-extract-bitwise-xor ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (i1 Int) (j1 Int))
  :args (x262 y263 i264 j265)
  :conclusion (= (extract j1 i1 (bvxor x1 y1)) (bvxor (extract j1 i1 x1) (extract j1 i1 y1)))
)
(declare-rule bv-extract-not ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (j1 Int))
  :args (x266 i267 j268)
  :conclusion (= (extract j1 i1 (bvnot x1)) (bvnot (extract j1 i1 x1)))
)
(declare-rule bv-extract-sign-extend-1 ((@n0 Int) (x1 (BitVec @n0)) (low1 Int) (high1 Int) (k1 Int))
  :premises ((= (< high1 (@bvsize x1)) true))
  :args (x269 low270 high271 k272)
  :conclusion (= (extract high1 low1 (sign_extend k1 x1)) (extract high1 low1 x1))
)
(declare-rule bv-extract-sign-extend-2 ((@n0 Int) (x1 (BitVec @n0)) (low1 Int) (high1 Int) (k1 Int))
  :premises ((= (< low1 (@bvsize x1)) true) (= (>= high1 (@bvsize x1)) true))
  :args (x273 low274 high275 k276)
  :conclusion (= (extract high1 low1 (sign_extend k1 x1)) (eo::define ((_let_1 (@bvsize x1))) (sign_extend (+ 1 (- high1 _let_1)) (extract (- _let_1 1) low1 x1))))
)
(declare-rule bv-extract-sign-extend-3 ((@n0 Int) (x1 (BitVec @n0)) (low1 Int) (high1 Int) (k1 Int))
  :premises ((= (>= low1 (@bvsize x1)) true))
  :args (x277 low278 high279 k280)
  :conclusion (= (extract high1 low1 (sign_extend k1 x1)) (eo::define ((_let_1 (- (@bvsize x1) 1))) (repeat (+ 1 (- high1 low1)) (extract _let_1 _let_1 x1))))
)
(declare-rule bv-neg-mult ((@n0 Int) (@n1 Int) (xs1 (BitVec @n0)) (ys1 (BitVec @n1)) (n1 Int) (m1 Int))
  :args (xs281 ys282 n283 m284)
  :conclusion (= (bvneg (bvmul xs1 (@bv n1 m1) ys1)) (bvmul xs1 (@bv (- n1) m1) ys1))
)
(declare-rule bv-neg-add ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (zs1 (BitVec @n2) :list))
  :args (x285 y286 zs287)
  :conclusion (= (bvneg (bvadd x1 y1 zs1)) (bvadd (bvneg x1) (bvneg ($singleton_elim (bvadd y1 zs1)))))
)
(declare-rule bv-mult-distrib-const-neg ((@n0 Int) (x1 (BitVec @n0)) (n1 Int) (m1 Int))
  :args (x288 n289 m290)
  :conclusion (= (bvmul (bvneg x1) (@bv n1 m1)) (bvmul x1 (@bv (- n1) m1)))
)
(declare-rule bv-mult-distrib-const-add ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (n1 Int) (m1 Int))
  :args (x291 y292 n293 m294)
  :conclusion (= (bvmul (bvadd x1 y1) (@bv n1 m1)) (eo::define ((_let_1 (@bv n1 m1))) (bvadd (bvmul x1 _let_1) (bvmul y1 _let_1))))
)
(declare-rule bv-mult-distrib-const-sub ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (n1 Int) (m1 Int))
  :args (x295 y296 n297 m298)
  :conclusion (= (bvmul (bvsub x1 y1) (@bv n1 m1)) (eo::define ((_let_1 (@bv n1 m1))) (bvsub (bvmul x1 _let_1) (bvmul y1 _let_1))))
)
(declare-rule bv-mult-distrib-1 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (x2 (BitVec @n1)) (y1 (BitVec @n2)))
  :args (x1299 x2300 y301)
  :conclusion (= (bvmul (bvadd x1 x2) y1) (bvadd (bvmul x1 y1) (bvmul x2 y1)))
)
(declare-rule bv-mult-distrib-2 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (x2 (BitVec @n1)) (y1 (BitVec @n2)))
  :args (x1302 x2303 y304)
  :conclusion (= (bvmul y1 (bvadd x1 x2)) (bvadd (bvmul y1 x1) (bvmul y1 x2)))
)
(declare-rule bv-not-xor ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (xs1 (BitVec @n1) :list))
  :args (x305 xs306)
  :conclusion (= (bvnot ($singleton_elim (bvxor x1 xs1))) ($singleton_elim (bvxor (bvnot x1) xs1)))
)
(declare-rule bv-and-simplify-1 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
  :args (xs307 ys308 zs309 x310)
  :conclusion (= (bvand xs1 x1 ys1 x1 zs1) ($singleton_elim (bvand xs1 x1 ys1 zs1)))
)
(declare-rule bv-and-simplify-2 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
  :args (xs311 ys312 zs313 x314)
  :conclusion (= (bvand xs1 x1 ys1 (bvnot x1) zs1) (@bv 0 (@bvsize x1)))
)
(declare-rule bv-or-simplify-1 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
  :args (xs315 ys316 zs317 x318)
  :conclusion (= (bvor xs1 x1 ys1 x1 zs1) ($singleton_elim (bvor xs1 x1 ys1 zs1)))
)
(declare-rule bv-or-simplify-2 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
  :args (xs319 ys320 zs321 x322)
  :conclusion (= (bvor xs1 x1 ys1 (bvnot x1) zs1) (bvnot (@bv 0 (@bvsize x1))))
)
(declare-rule bv-xor-simplify-1 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
  :args (xs323 ys324 zs325 x326)
  :conclusion (= (bvxor xs1 x1 ys1 x1 zs1) ($singleton_elim (bvxor xs1 ys1 zs1)))
)
(declare-rule bv-xor-simplify-2 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
  :args (xs327 ys328 zs329 x330)
  :conclusion (= (bvxor xs1 x1 ys1 (bvnot x1) zs1) (bvnot ($singleton_elim (bvxor xs1 ys1 zs1))))
)
(declare-rule bv-xor-simplify-3 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (zs1 (BitVec @n2) :list) (x1 (BitVec @n3)))
  :args (xs331 ys332 zs333 x334)
  :conclusion (= (bvxor xs1 (bvnot x1) ys1 x1 zs1) (bvnot ($singleton_elim (bvxor xs1 ys1 zs1))))
)
(declare-rule bv-ult-add-one ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (c1 (BitVec @n2)))
  :premises ((= c1 (@bv 1 (@bvsize c1))))
  :args (x335 y336 c1337)
  :conclusion (= (bvult x1 (bvadd y1 c1)) (and (not (bvult y1 x1)) (not (= y1 (bvnot (@bv 0 (@bvsize y1)))))))
)
(declare-rule bv-concat-to-mult ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (m1 Int) (n1 Int))
  :premises ((= (+ 1 i1 m1) (@bvsize x1)) (= n1 0))
  :args (x338 i339 m340 n0341)
  :conclusion (= (concat (extract i1 n1 x1) (@bv n1 m1)) (eo::define ((_let_1 (@bvsize x1))) (bvmul x1 (bvshl (@bv 1 _let_1) (@bv m1 _let_1)))))
)
(declare-rule bv-mult-slt-mult-1 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (t1 (BitVec @n1)) (a1 (BitVec @n2)) (n1 Int) (m1 Int))
  :args (x342 t343 a344 n345 m346)
  :conclusion (= (eo::define ((_let_1 (sign_extend m1 a1))) (bvslt (bvmul (sign_extend n1 (bvadd x1 t1)) _let_1) (bvmul (sign_extend n1 x1) _let_1))) (eo::define ((_let_1 (@bv 0 (@bvsize a1)))) (and (not (= t1 (@bv 0 (@bvsize t1)))) (not (= a1 _let_1)) (= (bvslt (bvadd x1 t1) x1) (bvsgt a1 _let_1)))))
)
(declare-rule bv-mult-slt-mult-2 ((@n0 Int) (@n1 Int) (@n2 Int) (x1 (BitVec @n0)) (t1 (BitVec @n1)) (a1 (BitVec @n2)) (n1 Int) (m1 Int))
  :args (x347 t348 a349 n350 m351)
  :conclusion (= (eo::define ((_let_1 (sign_extend m1 a1))) (bvslt (bvmul (zero_extend n1 (bvadd x1 t1)) _let_1) (bvmul (zero_extend n1 x1) _let_1))) (eo::define ((_let_1 (@bv 0 (@bvsize a1)))) (and (not (= t1 (@bv 0 (@bvsize t1)))) (not (= a1 _let_1)) (= (bvult (bvadd x1 t1) x1) (bvsgt a1 _let_1)))))
)
(declare-rule bv-commutative-and ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x352 y353)
  :conclusion (= (bvand x1 y1) (bvand y1 x1))
)
(declare-rule bv-commutative-or ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x354 y355)
  :conclusion (= (bvor x1 y1) (bvor y1 x1))
)
(declare-rule bv-commutative-xor ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x356 y357)
  :conclusion (= (bvxor x1 y1) (bvxor y1 x1))
)
(declare-rule bv-commutative-mul ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x358 y359)
  :conclusion (= (bvmul x1 y1) (bvmul y1 x1))
)
(declare-rule bv-or-zero ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x360 n361)
  :conclusion (= (bvor x1 (@bv 0 n1)) x1)
)
(declare-rule bv-mul-one ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (c1 (BitVec @n1)))
  :premises ((= c1 (@bv 1 (@bvsize c1))))
  :args (x362 c1363)
  :conclusion (= (bvmul x1 c1) x1)
)
(declare-rule bv-mul-zero ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (c1 (BitVec @n1)))
  :premises ((= c1 (@bv 0 (@bvsize c1))))
  :args (x364 c0365)
  :conclusion (= (bvmul x1 c1) (@bv 0 (@bvsize x1)))
)
(declare-rule bv-add-zero ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (c1 (BitVec @n1)))
  :premises ((= c1 (@bv 0 (@bvsize c1))))
  :args (x366 c0367)
  :conclusion (= (bvadd x1 c1) x1)
)
(declare-rule bv-add-two ((@n0 Int) (x1 (BitVec @n0)))
  :args (x368)
  :conclusion (= (bvadd x1 x1) (bvmul x1 (@bv 2 (@bvsize x1))))
)
(declare-rule bv-zero-extend-eliminate-0 ((@n0 Int) (x1 (BitVec @n0)))
  :args (x369)
  :conclusion (= (zero_extend 0 x1) x1)
)
(declare-rule bv-sign-extend-eliminate-0 ((@n0 Int) (x1 (BitVec @n0)))
  :args (x370)
  :conclusion (= (sign_extend 0 x1) x1)
)
(declare-rule bv-not-neq ((@n0 Int) (x1 (BitVec @n0)))
  :premises ((= (> (@bvsize x1) 0) true))
  :args (x371)
  :conclusion (= (= x1 (bvnot x1)) false)
)
(declare-rule bv-ult-ones ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :premises ((= y1 (bvnot (@bv 0 (@bvsize y1)))))
  :args (x372 y373)
  :conclusion (= (bvult x1 y1) (distinct x1 y1))
)
(declare-rule bv-or-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (s1 (BitVec @n1)) (ys1 (BitVec @n2) :list) (zs1 (BitVec @n3) :list))
  :args (xs374 s375 ys376 zs377)
  :conclusion (= ($singleton_elim (bvor xs1 ($singleton_elim (bvor s1 ys1)) zs1)) ($singleton_elim (bvor xs1 s1 ys1 zs1)))
)
(declare-rule bv-xor-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (s1 (BitVec @n1)) (ys1 (BitVec @n2) :list) (zs1 (BitVec @n3) :list))
  :args (xs378 s379 ys380 zs381)
  :conclusion (= ($singleton_elim (bvxor xs1 ($singleton_elim (bvxor s1 ys1)) zs1)) ($singleton_elim (bvxor xs1 s1 ys1 zs1)))
)
(declare-rule bv-and-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (s1 (BitVec @n1)) (ys1 (BitVec @n2) :list) (zs1 (BitVec @n3) :list))
  :args (xs382 s383 ys384 zs385)
  :conclusion (= ($singleton_elim (bvand xs1 ($singleton_elim (bvand s1 ys1)) zs1)) ($singleton_elim (bvand xs1 s1 ys1 zs1)))
)
(declare-rule bv-mul-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs1 (BitVec @n0) :list) (s1 (BitVec @n1)) (ys1 (BitVec @n2) :list) (zs1 (BitVec @n3) :list))
  :args (xs386 s387 ys388 zs389)
  :conclusion (= ($singleton_elim (bvmul xs1 ($singleton_elim (bvmul s1 ys1)) zs1)) ($singleton_elim (bvmul xs1 s1 ys1 zs1)))
)
(declare-rule bv-concat-merge-const ((@n0 Int) (@n1 Int) (xs1 (BitVec @n0) :list) (n1 Int) (w1 Int) (n2 Int) (w2 Int) (zs1 (BitVec @n1) :list))
  :args (xs390 n1391 w1392 n2393 w2394 zs395)
  :conclusion (= (concat xs1 (@bv n1 w1) (@bv n2 w2) zs1) ($singleton_elim (concat xs1 (@bv (+ (* n1 (int.pow2 w2)) n2) (+ w1 w2)) zs1)))
)
(declare-rule bv-commutative-add ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x396 y397)
  :conclusion (= (bvadd x1 y1) (bvadd y1 x1))
)
(declare-rule bv-neg-sub ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x398 y399)
  :conclusion (= (bvneg (bvsub x1 y1)) (bvsub y1 x1))
)
(declare-rule bv-neg-idemp ((@n0 Int) (x1 (BitVec @n0)))
  :args (x400)
  :conclusion (= (bvneg (bvneg x1)) x1)
)
(declare-rule bv-sub-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x401 y402)
  :conclusion (= (bvsub x1 y1) (bvadd x1 (bvneg y1)))
)
(declare-rule bv-ugt-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x432 y433)
  :conclusion (= (bvugt x1 y1) (bvult y1 x1))
)
(declare-rule bv-uge-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x434 y435)
  :conclusion (= (bvuge x1 y1) (bvule y1 x1))
)
(declare-rule bv-sgt-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x436 y437)
  :conclusion (= (bvsgt x1 y1) (bvslt y1 x1))
)
(declare-rule bv-sge-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x438 y439)
  :conclusion (= (bvsge x1 y1) (bvsle y1 x1))
)
(declare-rule bv-slt-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x440 y441)
  :conclusion (= (bvslt x1 y1) (eo::define ((_let_1 (@bvsize x1))) (eo::define ((_let_2 (bvshl (@bv 1 _let_1) (@bv (- _let_1 1) _let_1)))) (bvult (bvadd x1 _let_2) (bvadd y1 _let_2)))))
)
(declare-rule bv-sle-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x442 y443)
  :conclusion (= (bvsle x1 y1) (not (bvslt y1 x1)))
)
(declare-rule bv-redor-eliminate ((@n0 Int) (x1 (BitVec @n0)))
  :args (x444)
  :conclusion (= (bvredor x1) (bvnot (bvcomp x1 (@bv 0 (@bvsize x1)))))
)
(declare-rule bv-redand-eliminate ((@n0 Int) (x1 (BitVec @n0)))
  :args (x445)
  :conclusion (= (bvredand x1) (bvcomp x1 (bvnot (@bv 0 (@bvsize x1)))))
)
(declare-rule bv-ule-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x446 y447)
  :conclusion (= (bvule x1 y1) (not (bvult y1 x1)))
)
(declare-rule bv-comp-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x448 y449)
  :conclusion (= (bvcomp x1 y1) (ite (= x1 y1) (@bv 1 1) (@bv 0 1)))
)
(declare-rule bv-repeat-eliminate-1 ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :premises ((= (> n1 1) true))
  :args (x450 n451)
  :conclusion (= (repeat n1 x1) (concat x1 (repeat (- n1 1) x1)))
)
(declare-rule bv-repeat-eliminate-2 ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :premises ((= n1 1))
  :args (x452 n453)
  :conclusion (= (repeat n1 x1) x1)
)
(declare-rule bv-rotate-left-eliminate-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int))
  :premises ((= (= (mod amount1 (@bvsize x1)) 0) false))
  :args (x454 amount455)
  :conclusion (= (rotate_left amount1 x1) (eo::define ((_let_1 (@bvsize x1))) (eo::define ((_let_2 (mod amount1 _let_1))) (concat (extract (- _let_1 (+ 1 _let_2)) 0 x1) (extract (- _let_1 1) (- _let_1 _let_2) x1)))))
)
(declare-rule bv-rotate-left-eliminate-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int))
  :premises ((= (mod amount1 (@bvsize x1)) 0))
  :args (x456 amount457)
  :conclusion (= (rotate_left amount1 x1) x1)
)
(declare-rule bv-rotate-right-eliminate-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int))
  :premises ((= (= (mod amount1 (@bvsize x1)) 0) false))
  :args (x458 amount459)
  :conclusion (= (rotate_right amount1 x1) (eo::define ((_let_1 (@bvsize x1))) (eo::define ((_let_2 (mod amount1 _let_1))) (concat (extract (- _let_2 1) 0 x1) (extract (- _let_1 1) _let_2 x1)))))
)
(declare-rule bv-rotate-right-eliminate-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int))
  :premises ((= (mod amount1 (@bvsize x1)) 0))
  :args (x460 amount461)
  :conclusion (= (rotate_right amount1 x1) x1)
)
(declare-rule bv-nand-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x462 y463)
  :conclusion (= (bvnand x1 y1) (bvnot (bvand x1 y1)))
)
(declare-rule bv-nor-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x464 y465)
  :conclusion (= (bvnor x1 y1) (bvnot (bvor x1 y1)))
)
(declare-rule bv-xnor-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x466 y467)
  :conclusion (= (bvxnor x1 y1) (bvnot (bvxor x1 y1)))
)
(declare-rule bv-sdiv-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x468 y469)
  :conclusion (= (bvsdiv x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (eo::define ((_let_3 (= (extract _let_2 _let_2 y1) _let_1))) (eo::define ((_let_4 (= (extract _let_2 _let_2 x1) _let_1))) (eo::define ((_let_5 (bvudiv (ite _let_4 (bvneg x1) x1) (ite _let_3 (bvneg y1) y1)))) (ite (xor _let_4 _let_3) (bvneg _let_5) _let_5)))))))
)
(declare-rule bv-sdiv-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x470 y471)
  :conclusion (= (bvsdiv x1 y1) (eo::define ((_let_1 (concat (@bv 1 1) (@bv 0 (- (@bvsize x1) 1))))) (eo::define ((_let_2 (bvuge y1 _let_1))) (eo::define ((_let_3 (bvuge x1 _let_1))) (eo::define ((_let_4 (bvudiv (ite _let_3 (bvneg x1) x1) (ite _let_2 (bvneg y1) y1)))) (ite (xor _let_3 _let_2) (bvneg _let_4) _let_4))))))
)
(declare-rule bv-zero-extend-eliminate ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x472 n473)
  :conclusion (= (zero_extend n1 x1) (concat (@bv 0 n1) x1))
)
(declare-rule bv-sign-extend-eliminate ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x474 n475)
  :conclusion (= (sign_extend n1 x1) (eo::define ((_let_1 (- (@bvsize x1) 1))) (concat (repeat n1 (extract _let_1 _let_1 x1)) x1)))
)
(declare-rule bv-uaddo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x476 y477)
  :conclusion (= (bvuaddo x1 y1) (eo::define ((_let_1 (@bv 0 1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (= (extract _let_2 _let_2 (bvadd (concat _let_1 x1) (concat _let_1 y1))) (@bv 1 1)))))
)
(declare-rule bv-saddo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x478 y479)
  :conclusion (= (bvsaddo x1 y1) (eo::define ((_let_1 (@bv 0 1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (eo::define ((_let_3 (extract _let_2 _let_2 (bvadd x1 y1)))) (eo::define ((_let_4 (@bv 1 1))) (eo::define ((_let_5 (extract _let_2 _let_2 y1))) (eo::define ((_let_6 (extract _let_2 _let_2 x1))) (or (and (and (= _let_6 _let_1) (= _let_5 _let_1)) (= _let_3 _let_4)) (and (and (= _let_6 _let_4) (= _let_5 _let_4)) (= _let_3 _let_1))))))))))
)
(declare-rule bv-sdivo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x480 y481)
  :conclusion (= (bvsdivo x1 y1) (and (= x1 (concat (@bv 1 1) (@bv 0 (- (@bvsize x1) 1)))) (= y1 (bvnot (@bv 0 (@bvsize y1))))))
)
(declare-rule bv-smod-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x482 y483)
  :conclusion (= (bvsmod x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (@bvsize x1))) (eo::define ((_let_3 (- _let_2 1))) (eo::define ((_let_4 (= (extract _let_3 _let_3 y1) _let_1))) (eo::define ((_let_5 (= (extract _let_3 _let_3 x1) _let_1))) (eo::define ((_let_6 (bvurem (ite _let_5 (bvneg x1) x1) (ite _let_4 (bvneg y1) y1)))) (eo::define ((_let_7 (bvneg _let_6))) (eo::define ((_let_8 (not _let_5))) (eo::define ((_let_9 (not _let_4))) (ite (= _let_6 (@bv 0 _let_2)) _let_6 (ite (and _let_8 _let_9) _let_6 (ite (and _let_5 _let_9) (bvadd _let_7 y1) (ite (and _let_8 _let_4) (bvadd _let_6 y1) _let_7))))))))))))))
)
(declare-rule bv-smod-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x484 y485)
  :conclusion (= (bvsmod x1 y1) (eo::define ((_let_1 (@bvsize x1))) (eo::define ((_let_2 (concat (@bv 1 1) (@bv 0 (- _let_1 1))))) (eo::define ((_let_3 (bvuge y1 _let_2))) (eo::define ((_let_4 (bvuge x1 _let_2))) (eo::define ((_let_5 (bvurem (ite _let_4 (bvneg x1) x1) (ite _let_3 (bvneg y1) y1)))) (eo::define ((_let_6 (bvneg _let_5))) (eo::define ((_let_7 (not _let_4))) (eo::define ((_let_8 (not _let_3))) (ite (= _let_5 (@bv 0 _let_1)) _let_5 (ite (and _let_7 _let_8) _let_5 (ite (and _let_4 _let_8) (bvadd _let_6 y1) (ite (and _let_7 _let_3) (bvadd _let_5 y1) _let_6)))))))))))))
)
(declare-rule bv-srem-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x486 y487)
  :conclusion (= (bvsrem x1 y1) (eo::define ((_let_1 (- (@bvsize x1) 1))) (eo::define ((_let_2 (extract _let_1 _let_1 x1))) (eo::define ((_let_3 (bvurem (bvite _let_2 (bvneg x1) x1) (bvite (extract _let_1 _let_1 y1) (bvneg y1) y1)))) (bvite _let_2 (bvneg _let_3) _let_3)))))
)
(declare-rule bv-srem-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x488 y489)
  :conclusion (= (bvsrem x1 y1) (eo::define ((_let_1 (concat (@bv 1 1) (@bv 0 (- (@bvsize x1) 1))))) (eo::define ((_let_2 (bvuge x1 _let_1))) (eo::define ((_let_3 (bvurem (ite _let_2 (bvneg x1) x1) (ite (bvuge y1 _let_1) (bvneg y1) y1)))) (ite _let_2 (bvneg _let_3) _let_3)))))
)
(declare-rule bv-usubo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x490 y491)
  :conclusion (= (bvusubo x1 y1) (eo::define ((_let_1 (@bvsize x1))) (= (extract _let_1 _let_1 (bvsub (zero_extend 1 x1) (zero_extend 1 y1))) (@bv 1 1))))
)
(declare-rule bv-ssubo-eliminate ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x492 y493)
  :conclusion (= (bvssubo x1 y1) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (eo::define ((_let_3 (= (extract _let_2 _let_2 (bvsub x1 y1)) _let_1))) (eo::define ((_let_4 (= (extract _let_2 _let_2 y1) _let_1))) (eo::define ((_let_5 (= (extract _let_2 _let_2 x1) _let_1))) (or (and _let_5 (not _let_4) (not _let_3)) (and (not _let_5) _let_4 _let_3))))))))
)
(declare-rule bv-ite-equal-children ((@n0 Int) (c1 (_ BitVec 1)) (x1 (BitVec @n0)))
  :args (c546 x547)
  :conclusion (= (bvite c1 x1 x1) x1)
)
(declare-rule bv-ite-const-children-1 ((c1 (_ BitVec 1)))
  :args (c548)
  :conclusion (= (bvite c1 (@bv 0 1) (@bv 1 1)) (bvnot c1))
)
(declare-rule bv-ite-const-children-2 ((c1 (_ BitVec 1)))
  :args (c549)
  :conclusion (= (bvite c1 (@bv 1 1) (@bv 0 1)) c1)
)
(declare-rule bv-ite-equal-cond-1 ((@n0 Int) (@n1 Int) (@n2 Int) (c1 (_ BitVec 1)) (t1 (BitVec @n0)) (e1 (BitVec @n1)) (e2 (BitVec @n2)))
  :args (c0550 t0551 e0552 e1553)
  :conclusion (= (bvite c1 (bvite c1 t1 e1) e2) (bvite c1 t1 e2))
)
(declare-rule bv-ite-equal-cond-2 ((@n0 Int) (@n1 Int) (@n2 Int) (c1 (_ BitVec 1)) (t1 (BitVec @n0)) (t2 (BitVec @n1)) (e1 (BitVec @n2)))
  :args (c0554 t0555 t1556 e1557)
  :conclusion (= (bvite c1 t1 (bvite c1 t2 e1)) (bvite c1 t1 e1))
)
(declare-rule bv-ite-equal-cond-3 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (c1 (_ BitVec 1)) (t1 (BitVec @n0)) (e1 (BitVec @n1)) (t2 (BitVec @n2)) (e2 (BitVec @n3)))
  :args (c0558 t0559 e0560 t1561 e1562)
  :conclusion (= (bvite c1 (bvite c1 t1 e1) (bvite c1 t2 e2)) (bvite c1 t1 e2))
)
(declare-rule bv-ite-merge-then-if ((@n0 Int) (@n1 Int) (c1 (_ BitVec 1)) (c2 (_ BitVec 1)) (t1 (BitVec @n0)) (e1 (BitVec @n1)))
  :args (c0563 c1564 t1565 e1566)
  :conclusion (= (bvite c1 (bvite c2 t1 e1) t1) (bvite (bvand c1 (bvnot c2)) e1 t1))
)
(declare-rule bv-ite-merge-else-if ((@n0 Int) (@n1 Int) (c1 (_ BitVec 1)) (c2 (_ BitVec 1)) (t1 (BitVec @n0)) (e1 (BitVec @n1)))
  :args (c0567 c1568 t1569 e1570)
  :conclusion (= (bvite c1 (bvite c2 t1 e1) e1) (bvite (bvand c1 c2) t1 e1))
)
(declare-rule bv-ite-merge-then-else ((@n0 Int) (@n1 Int) (c1 (_ BitVec 1)) (c2 (_ BitVec 1)) (t1 (BitVec @n0)) (e1 (BitVec @n1)))
  :args (c0571 c1572 t0573 e1574)
  :conclusion (= (bvite c1 t1 (bvite c2 t1 e1)) (bvite (bvnor c1 c2) e1 t1))
)
(declare-rule bv-ite-merge-else-else ((@n0 Int) (@n1 Int) (c1 (_ BitVec 1)) (c2 (_ BitVec 1)) (t1 (BitVec @n0)) (t2 (BitVec @n1)))
  :args (c0575 c1576 t1577 t0578)
  :conclusion (= (bvite c1 t2 (bvite c2 t1 t2)) (bvite (bvand (bvnot c1) c2) t1 t2))
)
(declare-rule bv-shl-by-const-0 ((@n0 Int) (x1 (BitVec @n0)) (sz1 Int))
  :args (x579 sz580)
  :conclusion (= (bvshl x1 (@bv 0 sz1)) x1)
)
(declare-rule bv-shl-by-const-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
  :premises ((= (< amount1 (@bvsize x1)) true))
  :args (x581 amount582 sz583)
  :conclusion (= (bvshl x1 (@bv amount1 sz1)) (concat (extract (- (@bvsize x1) (+ 1 amount1)) 0 x1) (@bv 0 amount1)))
)
(declare-rule bv-shl-by-const-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
  :premises ((= (>= amount1 (@bvsize x1)) true))
  :args (x584 amount585 sz586)
  :conclusion (= (bvshl x1 (@bv amount1 sz1)) (@bv 0 (@bvsize x1)))
)
(declare-rule bv-lshr-by-const-0 ((@n0 Int) (x1 (BitVec @n0)) (sz1 Int))
  :args (x587 sz588)
  :conclusion (= (bvlshr x1 (@bv 0 sz1)) x1)
)
(declare-rule bv-lshr-by-const-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
  :premises ((= (< amount1 (@bvsize x1)) true))
  :args (x589 amount590 sz591)
  :conclusion (= (bvlshr x1 (@bv amount1 sz1)) (concat (@bv 0 amount1) (extract (- (@bvsize x1) 1) amount1 x1)))
)
(declare-rule bv-lshr-by-const-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
  :premises ((= (>= amount1 (@bvsize x1)) true))
  :args (x592 amount593 sz594)
  :conclusion (= (bvlshr x1 (@bv amount1 sz1)) (@bv 0 sz1))
)
(declare-rule bv-ashr-by-const-0 ((@n0 Int) (x1 (BitVec @n0)) (sz1 Int))
  :args (x595 sz596)
  :conclusion (= (bvashr x1 (@bv 0 sz1)) x1)
)
(declare-rule bv-ashr-by-const-1 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
  :premises ((= (< amount1 (@bvsize x1)) true))
  :args (x597 amount598 sz599)
  :conclusion (= (bvashr x1 (@bv amount1 sz1)) (eo::define ((_let_1 (- (@bvsize x1) 1))) (concat (repeat amount1 (extract _let_1 _let_1 x1)) (extract _let_1 amount1 x1))))
)
(declare-rule bv-ashr-by-const-2 ((@n0 Int) (x1 (BitVec @n0)) (amount1 Int) (sz1 Int))
  :premises ((= (>= amount1 (@bvsize x1)) true))
  :args (x600 amount601 sz602)
  :conclusion (= (bvashr x1 (@bv amount1 sz1)) (eo::define ((_let_1 (@bvsize x1))) (eo::define ((_let_2 (- _let_1 1))) (repeat _let_1 (extract _let_2 _let_2 x1)))))
)
(declare-rule bv-and-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (z1 (BitVec @n2)) (ys1 (BitVec @n3) :list))
  :args (x603 y604 z605 ys606)
  :conclusion (= (bvand x1 (concat ys1 z1 y1)) (eo::define ((_let_1 (@bvsize y1))) (concat (bvand (extract (- (@bvsize x1) 1) _let_1 x1) ($singleton_elim (concat ys1 z1))) (bvand (extract (- _let_1 1) 0 x1) y1))))
)
(declare-rule bv-or-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (z1 (BitVec @n2)) (ys1 (BitVec @n3) :list))
  :args (x607 y608 z609 ys610)
  :conclusion (= (bvor x1 (concat ys1 z1 y1)) (eo::define ((_let_1 (@bvsize y1))) (concat (bvor (extract (- (@bvsize x1) 1) _let_1 x1) ($singleton_elim (concat ys1 z1))) (bvor (extract (- _let_1 1) 0 x1) y1))))
)
(declare-rule bv-xor-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)) (z1 (BitVec @n2)) (ys1 (BitVec @n3) :list))
  :args (x611 y612 z613 ys614)
  :conclusion (= (bvxor x1 (concat ys1 z1 y1)) (eo::define ((_let_1 (@bvsize y1))) (concat (bvxor (extract (- (@bvsize x1) 1) _let_1 x1) ($singleton_elim (concat ys1 z1))) (bvxor (extract (- _let_1 1) 0 x1) y1))))
)
(declare-rule bv-bitwise-idemp-1 ((@n0 Int) (x1 (BitVec @n0)))
  :args (x615)
  :conclusion (= (bvand x1 x1) x1)
)
(declare-rule bv-bitwise-idemp-2 ((@n0 Int) (x1 (BitVec @n0)))
  :args (x616)
  :conclusion (= (bvor x1 x1) x1)
)
(declare-rule bv-and-zero ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x617 n618)
  :conclusion (= (bvand x1 (@bv 0 n1)) (@bv 0 n1))
)
(declare-rule bv-and-one ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :premises ((= y1 (bvnot (@bv 0 (@bvsize y1)))))
  :args (x619 y620)
  :conclusion (= (bvand x1 y1) x1)
)
(declare-rule bv-or-one ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :premises ((= y1 (bvnot (@bv 0 (@bvsize y1)))))
  :args (x621 y622)
  :conclusion (= (bvor x1 y1) (bvnot (@bv 0 (@bvsize y1))))
)
(declare-rule bv-xor-duplicate ((@n0 Int) (x1 (BitVec @n0)))
  :args (x623)
  :conclusion (= (bvxor x1 x1) (@bv 0 (@bvsize x1)))
)
(declare-rule bv-xor-ones ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :premises ((= y1 (bvnot (@bv 0 (@bvsize y1)))))
  :args (x624 y625)
  :conclusion (= (bvxor x1 y1) (bvnot x1))
)
(declare-rule bv-xor-zero ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x626 n627)
  :conclusion (= (bvxor x1 (@bv 0 n1)) x1)
)
(declare-rule bv-bitwise-not-and ((@n0 Int) (x1 (BitVec @n0)))
  :args (x628)
  :conclusion (= (bvand x1 (bvnot x1)) (@bv 0 (@bvsize x1)))
)
(declare-rule bv-bitwise-not-or ((@n0 Int) (x1 (BitVec @n0)))
  :args (x629)
  :conclusion (= (bvor x1 (bvnot x1)) (bvnot (@bv 0 (@bvsize x1))))
)
(declare-rule bv-xor-not ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x630 y631)
  :conclusion (= (bvxor (bvnot x1) (bvnot y1)) (bvxor x1 y1))
)
(declare-rule bv-not-idemp ((@n0 Int) (x1 (BitVec @n0)))
  :args (x632)
  :conclusion (= (bvnot (bvnot x1)) x1)
)
(declare-rule bv-ult-zero-1 ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x633 n634)
  :conclusion (= (bvult (@bv 0 n1) x1) (not (= x1 (@bv 0 n1))))
)
(declare-rule bv-ult-zero-2 ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x635 n636)
  :conclusion (= (bvult x1 (@bv 0 n1)) false)
)
(declare-rule bv-ult-self ((@n0 Int) (x1 (BitVec @n0)))
  :args (x637)
  :conclusion (= (bvult x1 x1) false)
)
(declare-rule bv-lt-self ((@n0 Int) (x1 (BitVec @n0)))
  :args (x638)
  :conclusion (= (bvslt x1 x1) false)
)
(declare-rule bv-ule-self ((@n0 Int) (x1 (BitVec @n0)))
  :args (x639)
  :conclusion (= (bvule x1 x1) true)
)
(declare-rule bv-ule-zero ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x640 n641)
  :conclusion (= (bvule x1 (@bv 0 n1)) (= x1 (@bv 0 n1)))
)
(declare-rule bv-zero-ule ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x642 n643)
  :conclusion (= (bvule (@bv 0 n1) x1) true)
)
(declare-rule bv-sle-self ((@n0 Int) (x1 (BitVec @n0)))
  :args (x644)
  :conclusion (= (bvsle x1 x1) true)
)
(declare-rule bv-ule-max ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :premises ((= y1 (bvnot (@bv 0 (@bvsize y1)))))
  :args (x645 y646)
  :conclusion (= (bvule x1 y1) true)
)
(declare-rule bv-not-ult ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x647 y648)
  :conclusion (= (not (bvult x1 y1)) (bvule y1 x1))
)
(declare-rule bv-not-ule ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x649 y650)
  :conclusion (= (not (bvule x1 y1)) (bvult y1 x1))
)
(declare-rule bv-not-sle ((@n0 Int) (@n1 Int) (x1 (BitVec @n0)) (y1 (BitVec @n1)))
  :args (x651 y652)
  :conclusion (= (not (bvsle x1 y1)) (bvslt y1 x1))
)
(declare-rule bv-mult-pow2-1 ((@n0 Int) (@n1 Int) (@n2 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (z1 (BitVec @n2)) (size1 Int) (n1 Int))
  :premises ((= (int.ispow2 n1) true))
  :args (xs653 ys654 z655 size656 n657)
  :conclusion (= (bvmul xs1 z1 (@bv n1 size1) ys1) (eo::define ((_let_1 (int.log2 n1))) (concat (extract (- (- size1 _let_1) 1) 0 ($singleton_elim (bvmul xs1 z1 ys1))) (@bv 0 _let_1))))
)
(declare-rule bv-mult-pow2-2 ((@n0 Int) (@n1 Int) (@n2 Int) (xs1 (BitVec @n0) :list) (ys1 (BitVec @n1) :list) (z1 (BitVec @n2)) (size1 Int) (n1 Int))
  :premises ((= (int.ispow2 (- n1)) true))
  :args (xs658 ys659 z660 size661 n662)
  :conclusion (= (bvmul xs1 z1 (@bv n1 size1) ys1) (eo::define ((_let_1 (int.log2 (- n1)))) (concat (extract (- (- size1 _let_1) 1) 0 (bvneg ($singleton_elim (bvmul xs1 z1 ys1)))) (@bv 0 _let_1))))
)
(declare-rule bv-mult-pow2-2b ((@n0 Int) (z1 (BitVec @n0)) (size1 Int) (n1 Int))
  :premises ((= (int.ispow2 (- n1)) true))
  :args (z663 size664 n665)
  :conclusion (= (bvmul z1 (@bv n1 size1)) (eo::define ((_let_1 (int.log2 (- n1)))) (concat (extract (- (- size1 _let_1) 1) 0 (bvneg z1)) (@bv 0 _let_1))))
)
(declare-rule bv-extract-mult-leading-bit ((@n0 Int) (@n1 Int) (high1 Int) (low1 Int) (x1i1 Int) (x1in1 Int) (x1 (BitVec @n0)) (y1i1 Int) (y1in1 Int) (y1 (BitVec @n1)))
  :premises ((= (> (+ x1in1 (@bvsize x1)) 64) true) (= (<= (- (* 2 (+ x1in1 (@bvsize x1))) (+ (ite (= x1i1 0) x1in1 (- x1in1 (+ 1 (int.log2 x1i1)))) (ite (= y1i1 0) y1in1 (- y1in1 (+ 1 (int.log2 y1i1)))))) low1) true))
  :args (high666 low667 x1i668 x1in669 x2670 y1i671 y1in672 y2673)
  :conclusion (= (extract high1 low1 (bvmul (concat (@bv x1i1 x1in1) x1) (concat (@bv y1i1 y1in1) y1))) (@bv 0 (+ 1 (- high1 low1))))
)
(declare-rule bv-udiv-pow2-not-one ((@n0 Int) (x1 (BitVec @n0)) (v1 Int) (n1 Int))
  :premises ((= (int.ispow2 v1) true) (= (> v1 1) true))
  :args (x674 v675 n676)
  :conclusion (= (bvudiv x1 (@bv v1 n1)) (eo::define ((_let_1 (int.log2 v1))) (concat (@bv 0 _let_1) (extract (- n1 1) _let_1 x1))))
)
(declare-rule bv-udiv-zero ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x677 n678)
  :conclusion (= (bvudiv x1 (@bv 0 n1)) (bvnot (@bv 0 n1)))
)
(declare-rule bv-udiv-one ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x679 n680)
  :conclusion (= (bvudiv x1 (@bv 1 n1)) x1)
)
(declare-rule bv-urem-pow2-not-one ((@n0 Int) (x1 (BitVec @n0)) (v1 Int) (n1 Int))
  :premises ((= (int.ispow2 v1) true) (= (> v1 1) true))
  :args (x681 v682 n683)
  :conclusion (= (bvurem x1 (@bv v1 n1)) (eo::define ((_let_1 (int.log2 v1))) (concat (@bv 0 (- n1 _let_1)) (extract (- _let_1 1) 0 x1))))
)
(declare-rule bv-urem-one ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x684 n685)
  :conclusion (= (bvurem x1 (@bv 1 n1)) (@bv 0 n1))
)
(declare-rule bv-urem-self ((@n0 Int) (x1 (BitVec @n0)))
  :args (x686)
  :conclusion (= (bvurem x1 x1) (@bv 0 (@bvsize x1)))
)
(declare-rule bv-shl-zero ((@n0 Int) (a1 (BitVec @n0)) (n1 Int))
  :args (a687 n688)
  :conclusion (= (bvshl (@bv 0 n1) a1) (@bv 0 n1))
)
(declare-rule bv-lshr-zero ((@n0 Int) (a1 (BitVec @n0)) (n1 Int))
  :args (a689 n690)
  :conclusion (= (bvlshr (@bv 0 n1) a1) (@bv 0 n1))
)
(declare-rule bv-ashr-zero ((@n0 Int) (a1 (BitVec @n0)) (n1 Int))
  :args (a691 n692)
  :conclusion (= (bvashr (@bv 0 n1) a1) (@bv 0 n1))
)
(declare-rule bv-ugt-urem ((@n0 Int) (@n1 Int) (y1 (BitVec @n0)) (x1 (BitVec @n1)))
  :args (y693 x694)
  :conclusion (= (bvugt (bvurem y1 x1) x1) (and (= x1 (@bv 0 (@bvsize x1))) (bvugt y1 (@bv 0 (@bvsize y1)))))
)
(declare-rule bv-ult-one ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x695 n696)
  :conclusion (= (bvult x1 (@bv 1 n1)) (= x1 (@bv 0 n1)))
)
(declare-rule bv-slt-zero ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x697 n698)
  :conclusion (= (bvslt x1 (@bv 0 n1)) (eo::define ((_let_1 (- n1 1))) (= (extract _let_1 _let_1 x1) (@bv 1 1))))
)
(declare-rule bv-merge-sign-extend-1 ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (j1 Int))
  :args (x699 i700 j701)
  :conclusion (= (sign_extend i1 (sign_extend j1 x1)) (sign_extend (+ i1 j1) x1))
)
(declare-rule bv-merge-sign-extend-2 ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (j1 Int))
  :premises ((= (> j1 1) true))
  :args (x702 i703 j704)
  :conclusion (= (sign_extend i1 (zero_extend j1 x1)) (zero_extend (+ i1 j1) x1))
)
(declare-rule bv-merge-sign-extend-3 ((@n0 Int) (x1 (BitVec @n0)) (i1 Int) (n1 Int))
  :premises ((= n1 0))
  :args (x705 i706 n0707)
  :conclusion (= (sign_extend i1 (zero_extend n1 x1)) (sign_extend i1 x1))
)
(declare-rule bv-sign-extend-eq-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
  :args (x708 m709 c710 nm711)
  :conclusion (= (= (sign_extend m1 x1) (@bv c1 nm1)) (eo::define ((_let_1 (@bv c1 nm1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (eo::define ((_let_3 (@bv 0 (+ m1 1)))) (eo::define ((_let_4 (extract (- nm1 1) _let_2 _let_1))) (and (or (= _let_4 _let_3) (= _let_4 (bvnot _let_3))) (= x1 (extract _let_2 0 _let_1))))))))
)
(declare-rule bv-sign-extend-eq-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
  :args (x712 m713 c714 nm715)
  :conclusion (= (= (@bv c1 nm1) (sign_extend m1 x1)) (eo::define ((_let_1 (@bv c1 nm1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (eo::define ((_let_3 (@bv 0 (+ m1 1)))) (eo::define ((_let_4 (extract (- nm1 1) _let_2 _let_1))) (and (or (= _let_4 _let_3) (= _let_4 (bvnot _let_3))) (= x1 (extract _let_2 0 _let_1))))))))
)
(declare-rule bv-zero-extend-eq-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
  :args (x716 m717 c718 nm719)
  :conclusion (= (= (zero_extend m1 x1) (@bv c1 nm1)) (eo::define ((_let_1 (@bv c1 nm1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (and (= (extract (- nm1 1) _let_2 _let_1) (@bv 0 m1)) (= x1 (extract _let_2 0 _let_1))))))
)
(declare-rule bv-zero-extend-eq-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
  :args (x720 m721 c722 nm723)
  :conclusion (= (= (@bv c1 nm1) (zero_extend m1 x1)) (eo::define ((_let_1 (@bv c1 nm1))) (eo::define ((_let_2 (- (@bvsize x1) 1))) (and (= (extract (- nm1 1) _let_2 _let_1) (@bv 0 m1)) (= x1 (extract _let_2 0 _let_1))))))
)
(declare-rule bv-zero-extend-ult-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
  :premises ((= (extract (- nm1 1) (@bvsize x1) (@bv c1 nm1)) (@bv 0 m1)))
  :args (x724 m725 c726 nm727)
  :conclusion (= (bvult (zero_extend m1 x1) (@bv c1 nm1)) (bvult x1 (extract (- (@bvsize x1) 1) 0 (@bv c1 nm1))))
)
(declare-rule bv-zero-extend-ult-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
  :premises ((= (extract (- nm1 1) (@bvsize x1) (@bv c1 nm1)) (@bv 0 m1)))
  :args (x728 m729 c730 nm731)
  :conclusion (= (bvult (@bv c1 nm1) (zero_extend m1 x1)) (bvult (extract (- (@bvsize x1) 1) 0 (@bv c1 nm1)) x1))
)
(declare-rule bv-sign-extend-ult-const-1 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
  :premises ((eo::define ((_let_1 (@bv (- (@bvsize x1) 1) nm1))) (eo::define ((_let_2 (@bv c1 nm1))) (= (or (bvule _let_2 (bvshl (@bv 1 nm1) _let_1)) (bvuge _let_2 (bvshl (bvnot (@bv 0 nm1)) _let_1))) true))))
  :args (x732 m733 c734 nm735)
  :conclusion (= (bvult (sign_extend m1 x1) (@bv c1 nm1)) (bvult x1 (extract (- (@bvsize x1) 1) 0 (@bv c1 nm1))))
)
(declare-rule bv-sign-extend-ult-const-2 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
  :premises ((= (bvult (bvshl (@bv 1 nm1) (@bv (- (@bvsize x1) 1) nm1)) (@bv c1 nm1)) true) (= (bvule (@bv c1 nm1) (bvshl (bvnot (@bv 0 nm1)) (@bv (- (@bvsize x1) 1) nm1))) true))
  :args (x736 m737 c738 nm739)
  :conclusion (= (bvult (sign_extend m1 x1) (@bv c1 nm1)) (eo::define ((_let_1 (- (@bvsize x1) 1))) (= (extract _let_1 _let_1 x1) (@bv 0 1))))
)
(declare-rule bv-sign-extend-ult-const-3 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
  :premises ((eo::define ((_let_1 (bvshl (@bv 1 nm1) (@bv (- (@bvsize x1) 1) nm1)))) (eo::define ((_let_2 (@bv c1 nm1))) (= (or (bvult _let_2 _let_1) (bvuge _let_2 (bvnot _let_1))) true))))
  :args (x740 m741 c742 nm743)
  :conclusion (= (bvult (@bv c1 nm1) (sign_extend m1 x1)) (bvult (extract (- (@bvsize x1) 1) 0 (@bv c1 nm1)) x1))
)
(declare-rule bv-sign-extend-ult-const-4 ((@n0 Int) (x1 (BitVec @n0)) (m1 Int) (c1 Int) (nm1 Int))
  :premises ((= (bvule (bvnot (bvshl (bvnot (@bv 0 nm1)) (@bv (- (@bvsize x1) 1) nm1))) (@bv c1 nm1)) true) (= (bvule (@bv c1 nm1) (bvnot (bvshl (@bv 1 nm1) (@bv (- (@bvsize x1) 1) nm1)))) true))
  :args (x744 m745 c746 nm747)
  :conclusion (= (bvult (@bv c1 nm1) (sign_extend m1 x1)) (eo::define ((_let_1 (- (@bvsize x1) 1))) (= (extract _let_1 _let_1 x1) (@bv 1 1))))
)
(declare-rule sets-eq-singleton-emp ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 @T1))
  :premises ((= (set.is_empty x1) true))
  :args (x812 y813)
  :conclusion (= (= x1 (set.singleton y1)) false)
)
(declare-rule sets-member-singleton ((@T0 Type) (@T1 Type) (x1 @T0) (y1 @T1))
  :args (x814 y815)
  :conclusion (= (set.member x1 (set.singleton y1)) (= x1 y1))
)
(declare-rule sets-member-emp ((@T0 Type) (@T1 Type) (x1 @T0) (y1 (Set @T1)))
  :premises ((= (set.is_empty y1) true))
  :args (x816 y817)
  :conclusion (= (set.member x1 y1) false)
)
(declare-rule sets-subset-elim ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 (Set @T1)))
  :args (x818 y819)
  :conclusion (= (set.subset x1 y1) (= (set.union x1 y1) y1))
)
(declare-rule sets-union-comm ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 (Set @T1)))
  :args (x820 y821)
  :conclusion (= (set.union x1 y1) (set.union y1 x1))
)
(declare-rule sets-inter-comm ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 (Set @T1)))
  :args (x822 y823)
  :conclusion (= (set.inter x1 y1) (set.inter y1 x1))
)
(declare-rule sets-inter-emp1 ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 (Set @T1)))
  :premises ((= (set.is_empty x1) true))
  :args (x824 y825)
  :conclusion (= (set.inter x1 y1) x1)
)
(declare-rule sets-inter-emp2 ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 (Set @T1)))
  :premises ((= (set.is_empty y1) true))
  :args (x826 y827)
  :conclusion (= (set.inter x1 y1) y1)
)
(declare-rule sets-minus-emp1 ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 (Set @T1)))
  :premises ((= (set.is_empty x1) true))
  :args (x828 y829)
  :conclusion (= (set.minus x1 y1) x1)
)
(declare-rule sets-minus-emp2 ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 (Set @T1)))
  :premises ((= (set.is_empty y1) true))
  :args (x830 y831)
  :conclusion (= (set.minus x1 y1) x1)
)
(declare-rule sets-union-emp1 ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 (Set @T1)))
  :premises ((= (set.is_empty x1) true))
  :args (x832 y833)
  :conclusion (= (set.union x1 y1) y1)
)
(declare-rule sets-union-emp2 ((@T0 Type) (@T1 Type) (x1 (Set @T0)) (y1 (Set @T1)))
  :premises ((= (set.is_empty y1) true))
  :args (x834 y835)
  :conclusion (= (set.union x1 y1) x1)
)
(declare-rule sets-inter-member ((@T0 Type) (@T1 Type) (@T2 Type) (x1 @T0) (y1 (Set @T1)) (z1 (Set @T2)))
  :args (x836 y837 z838)
  :conclusion (= (set.member x1 (set.inter y1 z1)) (and (set.member x1 y1) (set.member x1 z1)))
)
(declare-rule sets-minus-member ((@T0 Type) (@T1 Type) (@T2 Type) (x1 @T0) (y1 (Set @T1)) (z1 (Set @T2)))
  :args (x839 y840 z841)
  :conclusion (= (set.member x1 (set.minus y1 z1)) (and (set.member x1 y1) (not (set.member x1 z1))))
)
(declare-rule sets-union-member ((@T0 Type) (@T1 Type) (@T2 Type) (x1 @T0) (y1 (Set @T1)) (z1 (Set @T2)))
  :args (x842 y843 z844)
  :conclusion (= (set.member x1 (set.union y1 z1)) (or (set.member x1 y1) (set.member x1 z1)))
)
(declare-rule sets-choose-singleton ((@T0 Type) (x1 @T0))
  :args (x845)
  :conclusion (= (set.choose (set.singleton x1)) x1)
)
(declare-rule sets-card-singleton ((@T0 Type) (x1 @T0))
  :args (x846)
  :conclusion (= (set.card (set.singleton x1)) 1)
)
(declare-rule sets-card-union ((@T0 Type) (@T1 Type) (s1 (Set @T0)) (t1 (Set @T1)))
  :args (s847 t848)
  :conclusion (= (set.card (set.union s1 t1)) (- (+ (set.card s1) (set.card t1)) (set.card (set.inter s1 t1))))
)
(declare-rule sets-card-minus ((@T0 Type) (@T1 Type) (s1 (Set @T0)) (t1 (Set @T1)))
  :args (s849 t850)
  :conclusion (= (set.card (set.minus s1 t1)) (- (set.card s1) (set.card (set.inter s1 t1))))
)
(declare-rule sets-card-emp ((@T0 Type) (x1 (Set @T0)))
  :premises ((= (set.is_empty x1) true))
  :args (x851)
  :conclusion (= (set.card x1) 0)
)
(declare-rule str-eq-ctn-false ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x1 (Seq @T0) :list) (x2 (Seq @T1)) (x3 (Seq @T2) :list) (y1 (Seq @T3)))
  :premises ((= (seq.contains y1 x2) false))
  :args (x1854 x855 x2856 y857)
  :conclusion (= (= ($singleton_elim (seq.++ x1 x2 x3)) y1) false)
)
(declare-rule str-eq-ctn-full-false1 ((@T0 Type) (@T1 Type) (x1 (Seq @T0)) (y1 (Seq @T1)))
  :premises ((= (seq.contains y1 x1) false))
  :args (x858 y859)
  :conclusion (= (= x1 y1) false)
)
(declare-rule str-eq-ctn-full-false2 ((@T0 Type) (@T1 Type) (x1 (Seq @T0)) (y1 (Seq @T1)))
  :premises ((= (seq.contains x1 y1) false))
  :args (x860 y861)
  :conclusion (= (= x1 y1) false)
)
(declare-rule str-concat-flatten ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (xs1 (Seq @T0) :list) (s1 (Seq @T1)) (ys1 (Seq @T2) :list) (zs1 (Seq @T3) :list))
  :args (xs862 s863 ys864 zs865)
  :conclusion (= ($singleton_elim (seq.++ xs1 ($singleton_elim (seq.++ s1 ys1)) zs1)) ($singleton_elim (seq.++ xs1 s1 ys1 zs1)))
)
(declare-rule str-concat-flatten-eq ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x1 (Seq @T0)) (x2 (Seq @T1) :list) (x3 (Seq @T2) :list) (y1 (Seq @T3)))
  :args (x866 x1867 x2868 y869)
  :conclusion (= (= ($singleton_elim (seq.++ ($singleton_elim (seq.++ x1 x2)) x3)) y1) (= y1 ($singleton_elim (seq.++ x1 x2 x3))))
)
(declare-rule str-concat-flatten-eq-rev ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x1 (Seq @T0)) (x2 (Seq @T1) :list) (x3 (Seq @T2) :list) (y1 (Seq @T3)))
  :args (x870 x1871 x2872 y873)
  :conclusion (= (= ($singleton_elim (seq.++ x3 ($singleton_elim (seq.++ x2 x1)))) y1) (= y1 ($singleton_elim (seq.++ x3 x2 x1))))
)
(declare-rule str-substr-empty-str ((n1 Int) (m1 Int))
  :args (n874 m875)
  :conclusion (= (str.substr "" n1 m1) "")
)
(declare-rule str-substr-empty-range ((x1 String) (n1 Int) (m1 Int))
  :premises ((= (>= 0 m1) true))
  :args (x876 n877 m878)
  :conclusion (= (str.substr x1 n1 m1) "")
)
(declare-rule str-substr-empty-start ((x1 String) (n1 Int) (m1 Int))
  :premises ((= (>= n1 (str.len x1)) true))
  :args (x879 n880 m881)
  :conclusion (= (str.substr x1 n1 m1) "")
)
(declare-rule str-substr-empty-start-neg ((x1 String) (n1 Int) (m1 Int))
  :premises ((= (< n1 0) true))
  :args (x882 n883 m884)
  :conclusion (= (str.substr x1 n1 m1) "")
)
(declare-rule str-substr-eq-empty ((s1 String) (n1 Int) (m1 Int))
  :premises ((= n1 0) (= (> m1 n1) true))
  :args (s885 n886 m887)
  :conclusion (= (= (str.substr s1 n1 m1) "") (= s1 ""))
)
(declare-rule str-len-replace-inv ((@T0 Type) (@T1 Type) (@T2 Type) (t1 (Seq @T0)) (s1 (Seq @T1)) (r1 (Seq @T2)))
  :premises ((= (seq.len s1) (seq.len r1)))
  :args (t888 s889 r890)
  :conclusion (= (seq.len (seq.replace t1 s1 r1)) (seq.len t1))
)
(declare-rule str-len-update-inv ((@T0 Type) (@T1 Type) (t1 (Seq @T0)) (n1 Int) (r1 (Seq @T1)))
  :args (t891 n892 r893)
  :conclusion (= (seq.len (seq.update t1 n1 r1)) (seq.len t1))
)
(declare-rule str-len-substr-in-range ((@T0 Type) (s1 (Seq @T0)) (n1 Int) (m1 Int))
  :premises ((= (>= n1 0) true) (= (>= m1 0) true) (= (>= (seq.len s1) (+ n1 m1)) true))
  :args (s894 n895 m896)
  :conclusion (= (seq.len (seq.extract s1 n1 m1)) m1)
)
(declare-rule str-len-substr-ub1 ((@T0 Type) (s1 (Seq @T0)) (n1 Int) (m1 Int) (k1 Int))
  :premises ((= (>= k1 0) true) (= (>= k1 m1) true))
  :args (s897 n898 m899 k900)
  :conclusion (= (>= k1 (seq.len (seq.extract s1 n1 m1))) true)
)
(declare-rule str-len-substr-ub2 ((@T0 Type) (s1 (Seq @T0)) (n1 Int) (m1 Int) (k1 Int))
  :premises ((= (>= k1 0) true) (= (>= k1 (- (seq.len s1) n1)) true))
  :args (s901 n902 m903 k904)
  :conclusion (= (>= k1 (seq.len (seq.extract s1 n1 m1))) true)
)
(declare-rule str-concat-clash ((s1 String) (s2 String :list) (t1 String) (t2 String :list))
  :premises ((= (= s1 t1) false) (= (str.len s1) (str.len t1)))
  :args (s1905 s2906 t1907 t2908)
  :conclusion (= (= ($singleton_elim (str.++ s1 s2)) ($singleton_elim (str.++ t1 t2))) false)
)
(declare-rule str-concat-clash-rev ((s1 String) (s2 String :list) (t1 String) (t2 String :list))
  :premises ((= (= s1 t1) false) (= (str.len s1) (str.len t1)))
  :args (s1909 s2910 t1911 t2912)
  :conclusion (= (= ($singleton_elim (str.++ s2 s1)) ($singleton_elim (str.++ t2 t1))) false)
)
(declare-rule str-concat-clash2 ((s1 String) (t1 String) (t2 String :list))
  :premises ((= (= s1 t1) false) (= (str.len s1) (str.len t1)))
  :args (s1913 t1914 t2915)
  :conclusion (= (= s1 ($singleton_elim (str.++ t1 t2))) false)
)
(declare-rule str-concat-clash2-rev ((s1 String) (t1 String) (t2 String :list))
  :premises ((= (= s1 t1) false) (= (str.len s1) (str.len t1)))
  :args (s1916 t1917 t2918)
  :conclusion (= (= s1 ($singleton_elim (str.++ t2 t1))) false)
)
(declare-rule str-concat-unify ((s1 String) (s2 String) (s3 String :list) (t1 String) (t2 String :list))
  :args (s1919 s2920 s3921 t2922 t3923)
  :conclusion (= (= (str.++ s1 s2 s3) (str.++ s1 t1 t2)) (= ($singleton_elim (str.++ s2 s3)) ($singleton_elim (str.++ t1 t2))))
)
(declare-rule str-concat-unify-rev ((s1 String) (s2 String) (s3 String :list) (t1 String) (t2 String :list))
  :args (s1924 s2925 s3926 t2927 t3928)
  :conclusion (= (= (str.++ s2 s3 s1) (str.++ t1 t2 s1)) (= ($singleton_elim (str.++ s2 s3)) ($singleton_elim (str.++ t1 t2))))
)
(declare-rule str-concat-unify-base ((s1 String) (t1 String) (t2 String :list))
  :args (s929 t1930 t2931)
  :conclusion (= (= s1 (str.++ s1 t1 t2)) (= "" ($singleton_elim (str.++ t1 t2))))
)
(declare-rule str-concat-unify-base-rev ((s1 String) (t1 String) (t2 String :list))
  :args (s932 t1933 t2934)
  :conclusion (= (= s1 (str.++ t1 t2 s1)) (= "" ($singleton_elim (str.++ t1 t2))))
)
(declare-rule str-concat-clash-char ((s1 String) (s2 String :list) (s3 String :list) (t1 String) (t2 String :list) (t3 String :list))
  :premises ((= (= s1 t1) false) (= (str.len s1) (str.len t1)))
  :args (s1935 s2936 s3937 t1938 t2939 t3940)
  :conclusion (= (= ($singleton_elim (str.++ ($singleton_elim (str.++ s1 s2)) s3)) ($singleton_elim (str.++ ($singleton_elim (str.++ t1 t2)) t3))) false)
)
(declare-rule str-concat-clash-char-rev ((s1 String) (s2 String :list) (s3 String :list) (t1 String) (t2 String :list) (t3 String :list))
  :premises ((= (= s1 t1) false) (= (str.len s1) (str.len t1)))
  :args (s1941 s2942 s3943 t1944 t2945 t3946)
  :conclusion (= (= ($singleton_elim (str.++ s3 ($singleton_elim (str.++ s2 s1)))) ($singleton_elim (str.++ t3 ($singleton_elim (str.++ t2 t1))))) false)
)
(declare-rule str-prefixof-elim ((@T0 Type) (@T1 Type) (s1 (Seq @T0)) (t1 (Seq @T1)))
  :args (s947 t948)
  :conclusion (= (seq.prefixof s1 t1) (= s1 (seq.extract t1 0 (seq.len s1))))
)
(declare-rule str-suffixof-elim ((@T0 Type) (@T1 Type) (s1 (Seq @T0)) (t1 (Seq @T1)))
  :args (s949 t950)
  :conclusion (= (seq.suffixof s1 t1) (eo::define ((_let_1 (seq.len s1))) (= s1 (seq.extract t1 (- (seq.len t1) _let_1) _let_1))))
)
(declare-rule str-prefixof-one ((@T0 Type) (@T1 Type) (s1 (Seq @T0)) (t1 (Seq @T1)))
  :premises ((= (seq.len t1) 1))
  :args (s951 t952)
  :conclusion (= (seq.prefixof s1 t1) (seq.contains t1 s1))
)
(declare-rule str-suffixof-one ((@T0 Type) (@T1 Type) (s1 (Seq @T0)) (t1 (Seq @T1)))
  :premises ((= (seq.len t1) 1))
  :args (s953 t954)
  :conclusion (= (seq.suffixof s1 t1) (seq.contains t1 s1))
)
(declare-rule str-substr-combine1 ((s1 String) (n1 Int) (m1 Int) (n2 Int) (m2 Int))
  :premises ((= (>= n1 0) true) (= (>= n2 0) true) (= (>= (- m2 (- m1 n2)) 0) true))
  :args (s955 n1956 m1957 n2958 m2959)
  :conclusion (= (str.substr (str.substr s1 n1 m1) n2 m2) (str.substr s1 (+ n1 n2) (- m1 n2)))
)
(declare-rule str-substr-combine2 ((s1 String) (n1 Int) (m1 Int) (n2 Int) (m2 Int))
  :premises ((= (>= n1 0) true) (= (>= n2 0) true) (= (>= (- (- m1 n2) m2) 0) true))
  :args (s960 n1961 m1962 n2963 m2964)
  :conclusion (= (str.substr (str.substr s1 n1 m1) n2 m2) (str.substr s1 (+ n1 n2) m2))
)
(declare-rule str-substr-combine3 ((s1 String) (n1 Int) (m1 Int) (n2 Int) (m2 Int))
  :premises ((= (>= n1 0) true) (= (>= n2 0) true) (= (>= (str.len (str.substr s1 n1 m1)) (+ n2 m2)) true))
  :args (s965 n1966 m1967 n2968 m2969)
  :conclusion (= (str.substr (str.substr s1 n1 m1) n2 m2) (str.substr s1 (+ n1 n2) m2))
)
(declare-rule str-substr-combine4 ((s1 String) (n1 Int) (m1 Int) (n2 Int) (m2 Int))
  :premises ((= (>= n1 0) true) (= (>= n2 0) true) (= (>= (+ n2 m2) (str.len (str.substr s1 n1 m1))) true))
  :args (s970 n1971 m1972 n2973 m2974)
  :conclusion (= (str.substr (str.substr s1 n1 m1) n2 m2) (str.substr s1 (+ n1 n2) (- m1 n2)))
)
(declare-rule str-substr-concat1 ((@T0 Type) (@T1 Type) (s1 (Seq @T0)) (s2 (Seq @T1) :list) (n1 Int) (m1 Int))
  :premises ((= (>= n1 0) true) (= (>= (seq.len s1) (+ n1 m1)) true))
  :args (s1975 s2976 n977 m978)
  :conclusion (= (seq.extract ($singleton_elim (seq.++ s1 s2)) n1 m1) (seq.extract s1 n1 m1))
)
(declare-rule str-substr-concat2 ((@T0 Type) (@T1 Type) (@T2 Type) (s1 (Seq @T0)) (s2 (Seq @T1)) (s3 (Seq @T2) :list) (n1 Int) (m1 Int))
  :premises ((= (>= n1 (seq.len s1)) true))
  :args (s1979 s2980 s3981 n982 m983)
  :conclusion (= (seq.extract (seq.++ s1 s2 s3) n1 m1) (seq.extract ($singleton_elim (seq.++ s2 s3)) (- n1 (seq.len s1)) m1))
)
(declare-rule str-substr-full ((@T0 Type) (s1 (Seq @T0)) (n1 Int))
  :premises ((= (>= n1 (seq.len s1)) true))
  :args (s984 n985)
  :conclusion (= (seq.extract s1 0 n1) s1)
)
(declare-rule str-substr-full-eq ((@T0 Type) (s1 (Seq @T0)) (n1 Int))
  :premises ((= (seq.len s1) n1))
  :args (s986 n987)
  :conclusion (= (seq.extract s1 0 n1) s1)
)
(declare-rule str-contains-refl ((@T0 Type) (x1 (Seq @T0)))
  :args (x988)
  :conclusion (= (seq.contains x1 x1) true)
)
(declare-rule str-contains-concat-find ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (xs1 (Seq @T0) :list) (z1 (Seq @T1)) (y1 (Seq @T2)) (zs1 (Seq @T3) :list))
  :premises ((= (seq.contains z1 y1) true))
  :args (xs989 z990 y991 zs992)
  :conclusion (= (seq.contains ($singleton_elim (seq.++ xs1 z1 zs1)) y1) true)
)
(declare-rule str-contains-split-char ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x1 (Seq @T0)) (y1 (Seq @T1)) (z1 (Seq @T2) :list) (w1 (Seq @T3)))
  :premises ((= (seq.len w1) 1))
  :args (x993 y994 z995 w996)
  :conclusion (= (seq.contains (seq.++ x1 y1 z1) w1) (or (seq.contains x1 w1) (seq.contains ($singleton_elim (seq.++ y1 z1)) w1)))
)
(declare-rule str-contains-lt-len ((x1 String) (y1 String))
  :premises ((= (> (str.len y1) (str.len x1)) true))
  :args (x997 y998)
  :conclusion (= (str.contains x1 y1) false)
)
(declare-rule str-contains-leq-len-eq ((x1 String) (y1 String))
  :premises ((= (>= (str.len y1) (str.len x1)) true))
  :args (x999 y1000)
  :conclusion (= (str.contains x1 y1) (= x1 y1))
)
(declare-rule str-contains-emp ((x1 String) (y1 String))
  :premises ((= (str.len y1) 0))
  :args (x1001 y1002)
  :conclusion (= (str.contains x1 y1) true)
)
(declare-rule str-contains-is-emp ((x1 String) (y1 String))
  :premises ((= (str.len x1) 0))
  :args (x1003 y1004)
  :conclusion (= (str.contains x1 y1) (= x1 y1))
)
(declare-rule str-concat-emp ((xs1 String :list) (ys1 String :list))
  :args (xs1005 ys1006)
  :conclusion (= ($singleton_elim (str.++ xs1 "" ys1)) ($singleton_elim (str.++ xs1 ys1)))
)
(declare-rule str-at-elim ((@T0 Type) (x1 (Seq @T0)) (n1 Int))
  :args (x1007 n1008)
  :conclusion (= (seq.at x1 n1) (seq.extract x1 n1 1))
)
(declare-rule str-replace-self ((@T0 Type) (@T1 Type) (t1 (Seq @T0)) (s1 (Seq @T1)))
  :args (t1009 s1010)
  :conclusion (= (seq.replace t1 t1 s1) s1)
)
(declare-rule str-replace-no-contains ((@T0 Type) (@T1 Type) (@T2 Type) (t1 (Seq @T0)) (s1 (Seq @T1)) (r1 (Seq @T2)))
  :premises ((= (seq.contains t1 s1) false))
  :args (t1011 s1012 r1013)
  :conclusion (= (seq.replace t1 s1 r1) t1)
)
(declare-rule str-replace-empty ((@T0 Type) (@T1 Type) (t1 (Seq @T0)) (s1 (Seq @T1)))
  :args (t1014 s1015)
  :conclusion (= (seq.replace t1 "" s1) (seq.++ s1 t1))
)
(declare-rule str-len-concat-rec ((@T0 Type) (@T1 Type) (@T2 Type) (s1 (Seq @T0)) (s2 (Seq @T1)) (s3 (Seq @T2) :list))
  :args (s11016 s21017 s31018)
  :conclusion (= (seq.len (seq.++ s1 s2 s3)) (+ (seq.len s1) (seq.len ($singleton_elim (seq.++ s2 s3)))))
)
(declare-rule str-indexof-self ((t1 String) (n1 Int))
  :args (t1019 n1020)
  :conclusion (= (str.indexof t1 t1 n1) (str.indexof "" "" n1))
)
(declare-rule str-indexof-no-contains ((t1 String) (s1 String) (n1 Int))
  :premises ((= (str.contains (str.substr t1 n1 (str.len t1)) s1) false))
  :args (t1021 s1022 n1023)
  :conclusion (= (str.indexof t1 s1 n1) (- 1))
)
(declare-rule str-to-lower-concat ((s1 String) (s2 String) (s3 String :list))
  :args (s11024 s21025 s31026)
  :conclusion (= (str.to_lower (str.++ s1 s2 s3)) (str.++ (str.to_lower s1) (str.to_lower ($singleton_elim (str.++ s2 s3)))))
)
(declare-rule str-to-upper-concat ((s1 String) (s2 String) (s3 String :list))
  :args (s11027 s21028 s31029)
  :conclusion (= (str.to_upper (str.++ s1 s2 s3)) (str.++ (str.to_upper s1) (str.to_upper ($singleton_elim (str.++ s2 s3)))))
)
(declare-rule str-to-lower-upper ((s1 String))
  :args (s1030)
  :conclusion (= (str.to_lower (str.to_upper s1)) (str.to_lower s1))
)
(declare-rule str-to-upper-lower ((s1 String))
  :args (s1031)
  :conclusion (= (str.to_upper (str.to_lower s1)) (str.to_upper s1))
)
(declare-rule re-all-elim ()
  :args ()
  :conclusion (= re.all (re.* re.allchar))
)
(declare-rule re-opt-elim ((x1 RegLan))
  :args (x1032)
  :conclusion (= (re.opt x1) (re.union (str.to_re "") x1))
)
(declare-rule re-diff-elim ((x1 RegLan) (y1 RegLan))
  :args (x1033 y1034)
  :conclusion (= (re.diff x1 y1) (re.inter x1 (re.comp y1)))
)
(declare-rule re-concat-emp ((xs1 RegLan :list) (ys1 RegLan :list))
  :args (xs1035 ys1036)
  :conclusion (= ($singleton_elim (re.++ xs1 (str.to_re "") ys1)) ($singleton_elim (re.++ xs1 ys1)))
)
(declare-rule re-concat-none ((xs1 RegLan :list) (ys1 RegLan :list))
  :args (xs1037 ys1038)
  :conclusion (= ($singleton_elim (re.++ xs1 re.none ys1)) re.none)
)
(declare-rule re-concat-flatten ((xs1 RegLan :list) (s1 RegLan) (ys1 RegLan :list) (zs1 RegLan :list))
  :args (xs1039 s1040 ys1041 zs1042)
  :conclusion (= ($singleton_elim (re.++ xs1 ($singleton_elim (re.++ s1 ys1)) zs1)) ($singleton_elim (re.++ xs1 s1 ys1 zs1)))
)
(declare-rule re-concat-star-swap ((xs1 RegLan :list) (r1 RegLan) (ys1 RegLan :list))
  :args (xs1043 r1044 ys1045)
  :conclusion (= (re.++ xs1 (re.* r1) r1 ys1) (re.++ xs1 r1 (re.* r1) ys1))
)
(declare-rule re-concat-merge ((xs1 RegLan :list) (s1 String) (t1 String) (ys1 RegLan :list))
  :args (xs1046 s1047 t1048 ys1049)
  :conclusion (= (re.++ xs1 (str.to_re s1) (str.to_re t1) ys1) ($singleton_elim (re.++ xs1 (str.to_re (str.++ s1 t1)) ys1)))
)
(declare-rule re-union-all ((xs1 RegLan :list) (ys1 RegLan :list))
  :args (xs1050 ys1051)
  :conclusion (= ($singleton_elim (re.union xs1 (re.* re.allchar) ys1)) (re.* re.allchar))
)
(declare-rule re-union-none ((xs1 RegLan :list) (ys1 RegLan :list))
  :args (xs1052 ys1053)
  :conclusion (= ($singleton_elim (re.union xs1 re.none ys1)) ($singleton_elim (re.union xs1 ys1)))
)
(declare-rule re-union-flatten ((xs1 RegLan :list) (b1 RegLan) (ys1 RegLan :list) (zs1 RegLan :list))
  :args (xs1054 b1055 ys1056 zs1057)
  :conclusion (= ($singleton_elim (re.union xs1 ($singleton_elim (re.union b1 ys1)) zs1)) ($singleton_elim (re.union xs1 b1 ys1 zs1)))
)
(declare-rule re-union-dup ((xs1 RegLan :list) (b1 RegLan) (ys1 RegLan :list) (zs1 RegLan :list))
  :args (xs1058 b1059 ys1060 zs1061)
  :conclusion (= (re.union xs1 b1 ys1 b1 zs1) ($singleton_elim (re.union xs1 b1 ys1 zs1)))
)
(declare-rule re-inter-all ((xs1 RegLan :list) (ys1 RegLan :list))
  :args (xs1062 ys1063)
  :conclusion (= ($singleton_elim (re.inter xs1 (re.* re.allchar) ys1)) ($singleton_elim (re.inter xs1 ys1)))
)
(declare-rule re-inter-none ((xs1 RegLan :list) (ys1 RegLan :list))
  :args (xs1064 ys1065)
  :conclusion (= ($singleton_elim (re.inter xs1 re.none ys1)) re.none)
)
(declare-rule re-inter-flatten ((xs1 RegLan :list) (b1 RegLan) (ys1 RegLan :list) (zs1 RegLan :list))
  :args (xs1066 b1067 ys1068 zs1069)
  :conclusion (= ($singleton_elim (re.inter xs1 ($singleton_elim (re.inter b1 ys1)) zs1)) ($singleton_elim (re.inter xs1 b1 ys1 zs1)))
)
(declare-rule re-inter-dup ((xs1 RegLan :list) (b1 RegLan) (ys1 RegLan :list) (zs1 RegLan :list))
  :args (xs1070 b1071 ys1072 zs1073)
  :conclusion (= (re.inter xs1 b1 ys1 b1 zs1) ($singleton_elim (re.inter xs1 b1 ys1 zs1)))
)
(declare-rule re-loop-neg ((n1 Int) (m1 Int) (r1 RegLan))
  :premises ((= (> n1 m1) true))
  :args (n1074 m1075 r1076)
  :conclusion (= (re.loop n1 m1 r1) re.none)
)
(declare-rule re-inter-cstring ((xs1 RegLan :list) (ys1 RegLan :list) (s1 String))
  :premises ((= (str.in_re s1 ($singleton_elim (re.inter xs1 ys1))) true))
  :args (xs1077 ys1078 s1079)
  :conclusion (= ($singleton_elim (re.inter xs1 (str.to_re s1) ys1)) (str.to_re s1))
)
(declare-rule re-inter-cstring-neg ((xs1 RegLan :list) (ys1 RegLan :list) (s1 String))
  :premises ((= (str.in_re s1 ($singleton_elim (re.inter xs1 ys1))) false))
  :args (xs1080 ys1081 s1082)
  :conclusion (= ($singleton_elim (re.inter xs1 (str.to_re s1) ys1)) re.none)
)
(declare-rule str-substr-len-include ((@T0 Type) (@T1 Type) (s1 (Seq @T0)) (s2 (Seq @T1) :list) (n1 Int))
  :premises ((= n1 (seq.len s1)))
  :args (s11083 s21084 n1085)
  :conclusion (= (seq.extract ($singleton_elim (seq.++ s1 s2)) 0 n1) s1)
)
(declare-rule str-substr-len-include-pre ((@T0 Type) (@T1 Type) (@T2 Type) (s1 (Seq @T0)) (s2 (Seq @T1)) (s3 (Seq @T2) :list) (n1 Int))
  :premises ((= (>= n1 (seq.len s1)) true))
  :args (s11086 s21087 s31088 n1089)
  :conclusion (= (seq.extract (seq.++ s1 s2 s3) 0 n1) (seq.++ s1 (seq.extract ($singleton_elim (seq.++ s2 s3)) 0 (- n1 (seq.len s1)))))
)
(declare-rule str-substr-len-skip ((@T0 Type) (@T1 Type) (@T2 Type) (s1 (Seq @T0)) (s2 (Seq @T1)) (s3 (Seq @T2) :list) (n1 Int) (m1 Int))
  :premises ((= (>= n1 (seq.len s1)) true))
  :args (s11090 s21091 s31092 n1093 m1094)
  :conclusion (= (seq.extract (seq.++ s1 s2 s3) n1 m1) (seq.extract ($singleton_elim (seq.++ s2 s3)) (- n1 (seq.len s1)) m1))
)
(declare-rule seq-rev-concat ((@T0 Type) (@T1 Type) (@T2 Type) (x1 (Seq @T0)) (y1 (Seq @T1) :list) (z1 (Seq @T2)))
  :args (x1095 y1096 z1097)
  :conclusion (= (seq.rev (seq.++ x1 y1 z1)) (seq.++ (seq.rev z1) (seq.rev ($singleton_elim (seq.++ x1 y1)))))
)
(declare-rule seq-len-unit ((@T0 Type) (x1 @T0))
  :args (x1098)
  :conclusion (= (seq.len (seq.unit x1)) 1)
)
(declare-rule seq-nth-unit ((@T0 Type) (x1 @T0))
  :args (x1099)
  :conclusion (= (seq.nth (seq.unit x1) 0) x1)
)
(declare-rule seq-rev-unit ((@T0 Type) (x1 @T0))
  :args (x1100)
  :conclusion (= (seq.rev (seq.unit x1)) (seq.unit x1))
)
(declare-rule re-in-empty ((t1 String))
  :args (t1132)
  :conclusion (= (str.in_re t1 re.none) false)
)
(declare-rule re-in-sigma ((t1 String))
  :args (t1133)
  :conclusion (= (str.in_re t1 re.allchar) (= (str.len t1) 1))
)
(declare-rule re-in-sigma-star ((t1 String))
  :args (t1134)
  :conclusion (= (str.in_re t1 (re.* re.allchar)) true)
)
(declare-rule re-in-cstring ((t1 String) (s1 String))
  :args (t1135 s1136)
  :conclusion (= (str.in_re t1 (str.to_re s1)) (= t1 s1))
)
(declare-rule re-in-comp ((t1 String) (r1 RegLan))
  :args (t1137 r1138)
  :conclusion (= (str.in_re t1 (re.comp r1)) (not (str.in_re t1 r1)))
)
(declare-rule str-in-re-union-elim ((s1 String) (r1 RegLan) (r2 RegLan) (rs1 RegLan :list))
  :args (s1139 r11140 r21141 rs1142)
  :conclusion (= (str.in_re s1 (re.union r1 r2 rs1)) (or (str.in_re s1 r1) (str.in_re s1 ($singleton_elim (re.union r2 rs1)))))
)
(declare-rule str-in-re-inter-elim ((s1 String) (r1 RegLan) (r2 RegLan) (rs1 RegLan :list))
  :args (s1143 r11144 r21145 rs1146)
  :conclusion (= (str.in_re s1 (re.inter r1 r2 rs1)) (and (str.in_re s1 r1) (str.in_re s1 ($singleton_elim (re.inter r2 rs1)))))
)
(declare-rule str-in-re-range-elim ((s1 String) (c1 String) (c2 String))
  :premises ((= (str.len c1) 1) (= (str.len c2) 1))
  :args (s1147 c11148 c21149)
  :conclusion (= (str.in_re s1 (re.range c1 c2)) (eo::define ((_let_1 (str.to_code s1))) (and (<= (str.to_code c1) _let_1) (<= _let_1 (str.to_code c2)))))
)
(declare-rule str-in-re-contains ((t1 String) (s1 String))
  :args (t1150 s1151)
  :conclusion (= (eo::define ((_let_1 (re.* re.allchar))) (str.in_re t1 (re.++ _let_1 (str.to_re s1) _let_1))) (str.contains t1 s1))
)
(declare-rule str-in-re-strip-prefix ((s1 String) (s2 String) (s3 String :list) (sr1 String) (sr2 String :list) (r1 RegLan :list))
  :args (s1152 s11153 s21154 sr11155 sr21156 r1157)
  :conclusion (= (str.in_re (str.++ s1 s2 s3) ($singleton_elim (re.++ (str.to_re (str.++ s1 sr1 sr2)) r1))) (str.in_re ($singleton_elim (str.++ s2 s3)) ($singleton_elim (re.++ (str.to_re ($singleton_elim (str.++ sr1 sr2))) r1))))
)
(declare-rule str-in-re-strip-prefix-neg ((s1 String) (t1 String) (s2 String) (s3 String :list) (sr1 String) (sr2 String :list) (r1 RegLan :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1158 t1159 s11160 s21161 sr11162 sr21163 r1164)
  :conclusion (= (str.in_re (str.++ s1 s2 s3) ($singleton_elim (re.++ (str.to_re (str.++ t1 sr1 sr2)) r1))) false)
)
(declare-rule str-in-re-strip-prefix-sr-single ((s1 String) (s2 String) (s3 String :list) (r1 RegLan) (r2 RegLan :list))
  :args (s1165 s11166 s21167 r11168 r21169)
  :conclusion (= (str.in_re (str.++ s1 s2 s3) (re.++ (str.to_re s1) r1 r2)) (str.in_re ($singleton_elim (str.++ s2 s3)) ($singleton_elim (re.++ r1 r2))))
)
(declare-rule str-in-re-strip-prefix-sr-single-neg ((s1 String) (t1 String) (s2 String) (s3 String :list) (r1 RegLan) (r2 RegLan :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1170 t1171 s11172 s21173 r11174 r21175)
  :conclusion (= (str.in_re (str.++ s1 s2 s3) (re.++ (str.to_re t1) r1 r2)) false)
)
(declare-rule str-in-re-strip-prefix-srs-single ((s1 String) (r1 RegLan) (r2 RegLan :list))
  :args (s1176 r11177 r21178)
  :conclusion (= (str.in_re s1 (re.++ (str.to_re s1) r1 r2)) (str.in_re "" ($singleton_elim (re.++ r1 r2))))
)
(declare-rule str-in-re-strip-prefix-srs-single-neg ((s1 String) (t1 String) (r1 RegLan) (r2 RegLan :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1179 t1180 r11181 r21182)
  :conclusion (= (str.in_re s1 (re.++ (str.to_re t1) r1 r2)) false)
)
(declare-rule str-in-re-strip-prefix-s-single ((s1 String) (sr1 String) (sr2 String :list) (r1 RegLan :list))
  :args (s1183 sr11184 sr21185 r1186)
  :conclusion (= (str.in_re s1 ($singleton_elim (re.++ (str.to_re (str.++ s1 sr1 sr2)) r1))) (str.in_re "" ($singleton_elim (re.++ (str.to_re ($singleton_elim (str.++ sr1 sr2))) r1))))
)
(declare-rule str-in-re-strip-prefix-s-single-neg ((s1 String) (t1 String) (sr1 String) (sr2 String :list) (r1 RegLan :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1187 t1188 sr11189 sr21190 r1191)
  :conclusion (= (str.in_re s1 ($singleton_elim (re.++ (str.to_re (str.++ t1 sr1 sr2)) r1))) false)
)
(declare-rule str-in-re-strip-prefix-base ((s1 String) (s2 String) (s3 String :list) (sr1 String) (sr2 String :list))
  :args (s1192 s11193 s21194 sr11195 sr21196)
  :conclusion (= (str.in_re (str.++ s1 s2 s3) (str.to_re (str.++ s1 sr1 sr2))) (str.in_re ($singleton_elim (str.++ s2 s3)) (str.to_re ($singleton_elim (str.++ sr1 sr2)))))
)
(declare-rule str-in-re-strip-prefix-base-neg ((s1 String) (t1 String) (s2 String) (s3 String :list) (sr1 String) (sr2 String :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1197 t1198 s11199 s21200 sr11201 sr21202)
  :conclusion (= (str.in_re (str.++ s1 s2 s3) (str.to_re (str.++ t1 sr1 sr2))) false)
)
(declare-rule str-in-re-strip-prefix-base-s-single ((s1 String) (sr1 String) (sr2 String :list))
  :args (s1203 sr11204 sr21205)
  :conclusion (= (str.in_re s1 (str.to_re (str.++ s1 sr1 sr2))) (str.in_re "" (str.to_re ($singleton_elim (str.++ sr1 sr2)))))
)
(declare-rule str-in-re-strip-prefix-base-s-single-neg ((s1 String) (t1 String) (sr1 String) (sr2 String :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1206 t1207 sr11208 sr21209)
  :conclusion (= (str.in_re s1 (str.to_re (str.++ t1 sr1 sr2))) false)
)
(declare-rule str-in-re-strip-char ((s1 String) (s2 String) (s3 String :list) (r1 RegLan) (r2 RegLan :list))
  :premises ((= (str.len s1) 1))
  :args (s1210 s11211 s21212 r11213 r21214)
  :conclusion (= (str.in_re (str.++ s1 s2 s3) (re.++ re.allchar r1 r2)) (str.in_re ($singleton_elim (str.++ s2 s3)) ($singleton_elim (re.++ r1 r2))))
)
(declare-rule str-in-re-strip-char-s-single ((s1 String) (r1 RegLan) (r2 RegLan :list))
  :premises ((= (str.len s1) 1))
  :args (s1215 r11216 r21217)
  :conclusion (= (str.in_re s1 (re.++ re.allchar r1 r2)) (str.in_re "" ($singleton_elim (re.++ r1 r2))))
)
(declare-rule str-in-re-strip-prefix-rev ((s1 String) (s2 String) (s3 String :list) (sr1 String) (sr2 String :list) (r1 RegLan :list))
  :args (s1218 s11219 s21220 sr11221 sr21222 r1223)
  :conclusion (= (str.in_re (str.++ s2 s3 s1) ($singleton_elim (re.++ r1 (str.to_re (str.++ sr1 sr2 s1))))) (str.in_re ($singleton_elim (str.++ s2 s3)) ($singleton_elim (re.++ r1 (str.to_re ($singleton_elim (str.++ sr1 sr2)))))))
)
(declare-rule str-in-re-strip-prefix-neg-rev ((s1 String) (t1 String) (s2 String) (s3 String :list) (sr1 String) (sr2 String :list) (r1 RegLan :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1224 t1225 s11226 s21227 sr11228 sr21229 r1230)
  :conclusion (= (str.in_re (str.++ s2 s3 s1) ($singleton_elim (re.++ r1 (str.to_re (str.++ sr1 sr2 t1))))) false)
)
(declare-rule str-in-re-strip-prefix-sr-single-rev ((s1 String) (s2 String) (s3 String :list) (r1 RegLan) (r2 RegLan :list))
  :args (s1231 s11232 s21233 r11234 r21235)
  :conclusion (= (str.in_re (str.++ s2 s3 s1) (re.++ r1 r2 (str.to_re s1))) (str.in_re ($singleton_elim (str.++ s2 s3)) ($singleton_elim (re.++ r1 r2))))
)
(declare-rule str-in-re-strip-prefix-sr-single-neg-rev ((s1 String) (t1 String) (s2 String) (s3 String :list) (r1 RegLan) (r2 RegLan :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1236 t1237 s11238 s21239 r11240 r21241)
  :conclusion (= (str.in_re (str.++ s2 s3 s1) (re.++ r1 r2 (str.to_re t1))) false)
)
(declare-rule str-in-re-strip-prefix-srs-single-rev ((s1 String) (r1 RegLan) (r2 RegLan :list))
  :args (s1242 r11243 r21244)
  :conclusion (= (str.in_re s1 (re.++ r1 r2 (str.to_re s1))) (str.in_re "" ($singleton_elim (re.++ r1 r2))))
)
(declare-rule str-in-re-strip-prefix-srs-single-neg-rev ((s1 String) (t1 String) (r1 RegLan) (r2 RegLan :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1245 t1246 r11247 r21248)
  :conclusion (= (str.in_re s1 (re.++ r1 r2 (str.to_re t1))) false)
)
(declare-rule str-in-re-strip-prefix-s-single-rev ((s1 String) (sr1 String) (sr2 String :list) (r1 RegLan :list))
  :args (s1249 sr11250 sr21251 r1252)
  :conclusion (= (str.in_re s1 ($singleton_elim (re.++ r1 (str.to_re (str.++ sr1 sr2 s1))))) (str.in_re "" ($singleton_elim (re.++ r1 (str.to_re ($singleton_elim (str.++ sr1 sr2)))))))
)
(declare-rule str-in-re-strip-prefix-s-single-neg-rev ((s1 String) (t1 String) (sr1 String) (sr2 String :list) (r1 RegLan :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1253 t1254 sr11255 sr21256 r1257)
  :conclusion (= (str.in_re s1 ($singleton_elim (re.++ r1 (str.to_re (str.++ sr1 sr2 t1))))) false)
)
(declare-rule str-in-re-strip-prefix-base-rev ((s1 String) (s2 String) (s3 String :list) (sr1 String) (sr2 String :list))
  :args (s1258 s11259 s21260 sr11261 sr21262)
  :conclusion (= (str.in_re (str.++ s2 s3 s1) (str.to_re (str.++ sr1 sr2 s1))) (str.in_re ($singleton_elim (str.++ s2 s3)) (str.to_re ($singleton_elim (str.++ sr1 sr2)))))
)
(declare-rule str-in-re-strip-prefix-base-neg-rev ((s1 String) (t1 String) (s2 String) (s3 String :list) (sr1 String) (sr2 String :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1263 t1264 s11265 s21266 sr11267 sr21268)
  :conclusion (= (str.in_re (str.++ s2 s3 s1) (str.to_re (str.++ sr1 sr2 t1))) false)
)
(declare-rule str-in-re-strip-prefix-base-s-single-rev ((s1 String) (sr1 String) (sr2 String :list))
  :args (s1269 sr11270 sr21271)
  :conclusion (= (str.in_re s1 (str.to_re (str.++ sr1 sr2 s1))) (str.in_re "" (str.to_re ($singleton_elim (str.++ sr1 sr2)))))
)
(declare-rule str-in-re-strip-prefix-base-s-single-neg-rev ((s1 String) (t1 String) (sr1 String) (sr2 String :list))
  :premises ((= (str.len s1) (str.len t1)) (= (= s1 t1) false))
  :args (s1272 t1273 sr11274 sr21275)
  :conclusion (= (str.in_re s1 (str.to_re (str.++ sr1 sr2 t1))) false)
)
(declare-rule str-in-re-strip-char-rev ((s1 String) (s2 String) (s3 String :list) (r1 RegLan) (r2 RegLan :list))
  :premises ((= (str.len s1) 1))
  :args (s1276 s11277 s21278 r11279 r21280)
  :conclusion (= (str.in_re (str.++ s2 s3 s1) (re.++ r1 r2 re.allchar)) (str.in_re ($singleton_elim (str.++ s2 s3)) ($singleton_elim (re.++ r1 r2))))
)
(declare-rule str-in-re-strip-char-s-single-rev ((s1 String) (r1 RegLan) (r2 RegLan :list))
  :premises ((= (str.len s1) 1))
  :args (s1281 r11282 r21283)
  :conclusion (= (str.in_re s1 (re.++ r1 r2 re.allchar)) (str.in_re "" ($singleton_elim (re.++ r1 r2))))
)
(declare-rule str-in-re-req-unfold ((s1 String) (r1 RegLan) (r2 RegLan) (r3 RegLan :list))
  :premises ((= (str.in_re s1 ($singleton_elim (re.++ r2 r3))) false))
  :args (s1284 r11285 r21286 r31287)
  :conclusion (= (str.in_re s1 (re.++ (re.* r1) r2 r3)) (str.in_re s1 (re.++ r1 (re.* r1) r2 r3)))
)
(declare-rule str-in-re-req-unfold-rev ((s1 String) (r1 RegLan) (r2 RegLan :list) (r3 RegLan))
  :premises ((= (str.in_re s1 ($singleton_elim (re.++ r1 r2))) false))
  :args (s1288 r11289 r21290 r31291)
  :conclusion (= (str.in_re s1 (re.++ r1 r2 (re.* r3))) (str.in_re s1 (re.++ r1 r2 (re.* r3) r3)))
)
(declare-rule str-in-re-skip-unfold ((s1 String) (r1 RegLan) (r2 RegLan) (r3 RegLan :list))
  :premises ((= (str.in_re s1 (re.++ r1 (re.* r1) r2 r3)) false))
  :args (s1292 r11293 r21294 r31295)
  :conclusion (= (str.in_re s1 (re.++ (re.* r1) r2 r3)) (str.in_re s1 ($singleton_elim (re.++ r2 r3))))
)
(declare-rule str-in-re-skip-unfold-rev ((s1 String) (r1 RegLan) (r2 RegLan :list) (r3 RegLan))
  :premises ((= (str.in_re s1 (re.++ r1 r2 (re.* r3) r3)) false))
  :args (s1296 r11297 r21298 r31299)
  :conclusion (= (str.in_re s1 (re.++ r1 r2 (re.* r3))) (str.in_re s1 ($singleton_elim (re.++ r1 r2))))
)
(declare-rule str-in-re-test-unfold ((s1 String) (r1 RegLan) (r2 RegLan) (r3 RegLan :list))
  :premises ((= (str.in_re s1 ($singleton_elim (re.++ r2 r3))) false) (= (str.in_re s1 (re.++ r1 (re.* r1) r2 r3)) false))
  :args (s1300 r11301 r21302 r31303)
  :conclusion (= (str.in_re s1 (re.++ (re.* r1) r2 r3)) false)
)
(declare-rule str-in-re-test-unfold-rev ((s1 String) (r1 RegLan) (r2 RegLan :list) (r3 RegLan))
  :premises ((= (str.in_re s1 ($singleton_elim (re.++ r1 r2))) false) (= (str.in_re s1 (re.++ r1 r2 (re.* r3) r3)) false))
  :args (s1304 r11305 r21306 r31307)
  :conclusion (= (str.in_re s1 (re.++ r1 r2 (re.* r3))) false)
)
(declare-rule eq-refl ((@T0 Type) (t1 @T0))
  :args (t1329)
  :conclusion (= (= t1 t1) true)
)
(declare-rule eq-symm ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1330 s1331)
  :conclusion (= (= t1 s1) (= s1 t1))
)
(declare-rule distinct-binary-elim ((@T0 Type) (@T1 Type) (t1 @T0) (s1 @T1))
  :args (t1332 s1333)
  :conclusion (= (distinct t1 s1) (not (= t1 s1)))
)
(declare-rule uf-bv2nat-geq-elim ((@n0 Int) (x1 (BitVec @n0)) (n1 Int))
  :args (x1334 n1335)
  :conclusion (= (>= (bv2nat x1) n1) (eo::define ((_let_1 (@bvsize x1))) (ite (>= n1 _let_1) false (ite (< n1 0) true (bvuge x1 (int2bv _let_1 n1))))))
)
