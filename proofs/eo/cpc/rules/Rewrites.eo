(include "../theories/Builtin.eo")
(include "../theories/Arrays.eo")
(include "../theories/Arith.eo")
(include "../theories/Reals.eo")
(include "../theories/Transcendentals.eo")
(include "../theories/BitVectors.eo")
(include "../theories/Strings.eo")
(include "../theories/Sets.eo")

(declare-rule arith-plus-zero ((@T0 Type) (@T1 Type) (t1 @T0 :list) (s2 @T1 :list))
  :args (t1 s2)
  :conclusion (= ($singleton_elim (+ t1 0 s2)) ($singleton_elim (+ t1 s2)))
)
(declare-rule arith-mul-one ((@T0 Type) (@T1 Type) (t3 @T0 :list) (s4 @T1 :list))
  :args (t3 s4)
  :conclusion (= ($singleton_elim (* t3 1 s4)) ($singleton_elim (* t3 s4)))
)
(declare-rule arith-mul-zero ((@T0 Type) (@T1 Type) (t5 @T0 :list) (s6 @T1 :list))
  :args (t5 s6)
  :conclusion (= ($singleton_elim (* t5 0 s6)) 0)
)
(declare-rule arith-div-total ((@T0 Type) (@T1 Type) (t7 @T0) (s8 @T1))
  :premises ((= (= s8 0) false))
  :args (t7 s8)
  :conclusion (= (/ t7 s8) (/_total t7 s8))
)
(declare-rule arith-int-div-total ((t9 Int) (s10 Int))
  :premises ((= (= s10 0) false))
  :args (t9 s10)
  :conclusion (= (div t9 s10) (div_total t9 s10))
)
(declare-rule arith-int-div-total-one ((t11 Int))
  :args (t11)
  :conclusion (= (div_total t11 1) t11)
)
(declare-rule arith-int-div-total-zero ((t12 Int))
  :args (t12)
  :conclusion (= (div_total t12 0) 0)
)
(declare-rule arith-int-mod-total ((t13 Int) (s14 Int))
  :premises ((= (= s14 0) false))
  :args (t13 s14)
  :conclusion (= (mod t13 s14) (mod_total t13 s14))
)
(declare-rule arith-int-mod-total-one ((t15 Int))
  :args (t15)
  :conclusion (= (mod_total t15 1) 0)
)
(declare-rule arith-int-mod-total-zero ((t16 Int))
  :args (t16)
  :conclusion (= (mod_total t16 0) t16)
)
(declare-rule arith-neg-neg-one ((@T0 Type) (t17 @T0))
  :args (t17)
  :conclusion (= (* (- 1) (* (- 1) t17)) t17)
)
(declare-rule arith-elim-uminus ((@T0 Type) (t18 @T0))
  :args (t18)
  :conclusion (= (- t18) (* (- 1) t18))
)
(declare-rule arith-elim-minus ((@T0 Type) (@T1 Type) (t19 @T0) (s20 @T1))
  :args (t19 s20)
  :conclusion (= (- t19 s20) (+ t19 (* (- 1) s20)))
)
(declare-rule arith-elim-gt ((@T0 Type) (@T1 Type) (t21 @T0) (s22 @T1))
  :args (t21 s22)
  :conclusion (= (> t21 s22) (not (<= t21 s22)))
)
(declare-rule arith-elim-lt ((@T0 Type) (@T1 Type) (t23 @T0) (s24 @T1))
  :args (t23 s24)
  :conclusion (= (< t23 s24) (not (>= t23 s24)))
)
(declare-rule arith-elim-int-gt ((t25 Int) (s26 Int))
  :args (t25 s26)
  :conclusion (= (> t25 s26) (>= t25 (+ s26 1)))
)
(declare-rule arith-elim-int-lt ((t27 Int) (s28 Int))
  :args (t27 s28)
  :conclusion (= (< t27 s28) (>= s28 (+ t27 1)))
)
(declare-rule arith-elim-leq ((@T0 Type) (@T1 Type) (t29 @T0) (s30 @T1))
  :args (t29 s30)
  :conclusion (= (<= t29 s30) (>= s30 t29))
)
(declare-rule arith-leq-norm ((t31 Int) (s32 Int))
  :args (t31 s32)
  :conclusion (= (<= t31 s32) (not (>= t31 (+ s32 1))))
)
(declare-rule arith-geq-tighten ((t33 Int) (s34 Int))
  :args (t33 s34)
  :conclusion (= (not (>= t33 s34)) (>= s34 (+ t33 1)))
)
(declare-rule arith-geq-norm1 ((@T0 Type) (@T1 Type) (t35 @T0) (s36 @T1))
  :args (t35 s36)
  :conclusion (= (>= t35 s36) (>= (- t35 s36) 0))
)
(declare-rule arith-geq-norm2 ((@T0 Type) (@T1 Type) (t37 @T0) (s38 @T1))
  :args (t37 s38)
  :conclusion (= (>= t37 s38) (<= (- t37) (- s38)))
)
(declare-rule arith-refl-leq ((@T0 Type) (t39 @T0))
  :args (t39)
  :conclusion (= (<= t39 t39) true)
)
(declare-rule arith-refl-lt ((@T0 Type) (t40 @T0))
  :args (t40)
  :conclusion (= (< t40 t40) false)
)
(declare-rule arith-refl-geq ((@T0 Type) (t41 @T0))
  :args (t41)
  :conclusion (= (>= t41 t41) true)
)
(declare-rule arith-refl-gt ((@T0 Type) (t42 @T0))
  :args (t42)
  :conclusion (= (> t42 t42) false)
)
(declare-rule arith-real-eq-elim ((t43 Real) (s44 Real))
  :args (t43 s44)
  :conclusion (= (= t43 s44) (and (>= t43 s44) (<= t43 s44)))
)
(declare-rule arith-int-eq-elim ((t45 Int) (s46 Int))
  :args (t45 s46)
  :conclusion (= (= t45 s46) (and (>= t45 s46) (<= t45 s46)))
)
(declare-rule arith-plus-flatten ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (xs47 @T0 :list) (w48 @T1) (ys49 @T2 :list) (zs50 @T3 :list))
  :args (xs47 w48 ys49 zs50)
  :conclusion (= ($singleton_elim (+ xs47 ($singleton_elim (+ w48 ys49)) zs50)) ($singleton_elim (+ xs47 w48 ys49 zs50)))
)
(declare-rule arith-mult-flatten ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (xs51 @T0 :list) (w52 @T1) (ys53 @T2 :list) (zs54 @T3 :list))
  :args (xs51 w52 ys53 zs54)
  :conclusion (= ($singleton_elim (* xs51 ($singleton_elim (* w52 ys53)) zs54)) ($singleton_elim (* xs51 w52 ys53 zs54)))
)
(declare-rule arith-mult-dist ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x55 @T0) (y56 @T1) (z57 @T2) (w58 @T3 :list))
  :args (x55 y56 z57 w58)
  :conclusion (= (* x55 (+ y56 z57 w58)) (+ (* x55 y56) (* x55 ($singleton_elim (+ z57 w58)))))
)
(declare-rule arith-plus-cancel1 ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (t59 @T0 :list) (x60 @T1) (s61 @T2 :list) (r62 @T3 :list))
  :args (t59 x60 s61 r62)
  :conclusion (= (+ t59 x60 s61 (* (- 1) x60) r62) ($singleton_elim (+ t59 s61 r62)))
)
(declare-rule arith-plus-cancel2 ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (t63 @T0 :list) (x64 @T1) (s65 @T2 :list) (r66 @T3 :list))
  :args (t63 x64 s65 r66)
  :conclusion (= (+ t63 (* (- 1) x64) s65 x64 r66) ($singleton_elim (+ t63 s65 r66)))
)
(declare-rule arith-abs-elim ((@T0 Type) (x67 @T0))
  :args (x67)
  :conclusion (= (abs x67) (ite (< x67 0) (- x67) x67))
)
(declare-rule arith-to-real-elim ((x68 Real))
  :args (x68)
  :conclusion (= (to_real x68) x68)
)
(declare-rule arith-to-int-elim-to-real ((@T0 Type) (x69 @T0))
  :args (x69)
  :conclusion (= (to_int (to_real x69)) (to_int x69))
)
(declare-rule arith-div-elim-to-real1 ((@T0 Type) (@T1 Type) (x70 @T0) (y71 @T1))
  :args (x70 y71)
  :conclusion (= (/ (to_real x70) y71) (/ x70 y71))
)
(declare-rule arith-div-elim-to-real2 ((@T0 Type) (@T1 Type) (x72 @T0) (y73 @T1))
  :args (x72 y73)
  :conclusion (= (/ x72 (to_real y73)) (/ x72 y73))
)
(declare-rule array-read-over-write ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (t84 (Array @T0 @T1)) (i85 @T2) (e86 @T3))
  :args (t84 i85 e86)
  :conclusion (= (select (store t84 i85 e86) i85) e86)
)
(declare-rule array-read-over-write2 ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (@T4 Type) (t87 (Array @T0 @T1)) (i88 @T2) (j89 @T3) (e90 @T4))
  :premises ((= (= i88 j89) false))
  :args (t87 i88 j89 e90)
  :conclusion (= (select (store t87 i88 e90) j89) (select t87 j89))
)
(declare-rule array-store-overwrite ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (@T4 Type) (t91 (Array @T0 @T1)) (i92 @T2) (e93 @T3) (f94 @T4))
  :args (t91 i92 e93 f94)
  :conclusion (= (store (store t91 i92 e93) i92 f94) (store t91 i92 f94))
)
(declare-rule array-store-self ((@T0 Type) (@T1 Type) (@T2 Type) (t95 (Array @T0 @T1)) (i96 @T2))
  :args (t95 i96)
  :conclusion (= (store t95 i96 (select t95 i96)) t95)
)
(declare-rule bool-double-not-elim ((t98 Bool))
  :args (t98)
  :conclusion (= (not (not t98)) t98)
)
(declare-rule bool-not-true ((t99 Bool))
  :premises ((= t99 false))
  :args (t99)
  :conclusion (= (not t99) true)
)
(declare-rule bool-not-false ((t100 Bool))
  :premises ((= t100 true))
  :args (t100)
  :conclusion (= (not t100) false)
)
(declare-rule bool-eq-true ((t101 Bool))
  :args (t101)
  :conclusion (= (= t101 true) t101)
)
(declare-rule bool-eq-false ((t102 Bool))
  :args (t102)
  :conclusion (= (= t102 false) (not t102))
)
(declare-rule bool-eq-nrefl ((x103 Bool))
  :args (x103)
  :conclusion (= (= x103 (not x103)) false)
)
(declare-rule bool-impl-false1 ((t104 Bool))
  :args (t104)
  :conclusion (= (=> t104 false) (not t104))
)
(declare-rule bool-impl-false2 ((t105 Bool))
  :args (t105)
  :conclusion (= (=> false t105) true)
)
(declare-rule bool-impl-true1 ((t106 Bool))
  :args (t106)
  :conclusion (= (=> t106 true) true)
)
(declare-rule bool-impl-true2 ((t107 Bool))
  :args (t107)
  :conclusion (= (=> true t107) t107)
)
(declare-rule bool-impl-elim ((t108 Bool) (s109 Bool))
  :args (t108 s109)
  :conclusion (= (=> t108 s109) (or (not t108) s109))
)
(declare-rule bool-or-true ((xs110 Bool :list) (ys111 Bool :list))
  :args (xs110 ys111)
  :conclusion (= ($singleton_elim (or xs110 true ys111)) true)
)
(declare-rule bool-or-false ((xs112 Bool :list) (ys113 Bool :list))
  :args (xs112 ys113)
  :conclusion (= ($singleton_elim (or xs112 false ys113)) ($singleton_elim (or xs112 ys113)))
)
(declare-rule bool-or-flatten ((xs114 Bool :list) (b115 Bool) (ys116 Bool :list) (zs117 Bool :list))
  :args (xs114 b115 ys116 zs117)
  :conclusion (= ($singleton_elim (or xs114 ($singleton_elim (or b115 ys116)) zs117)) ($singleton_elim (or xs114 b115 ys116 zs117)))
)
(declare-rule bool-or-dup ((xs118 Bool :list) (b119 Bool) (ys120 Bool :list) (zs121 Bool :list))
  :args (xs118 b119 ys120 zs121)
  :conclusion (= (or xs118 b119 ys120 b119 zs121) ($singleton_elim (or xs118 b119 ys120 zs121)))
)
(declare-rule bool-and-true ((xs122 Bool :list) (ys123 Bool :list))
  :args (xs122 ys123)
  :conclusion (= ($singleton_elim (and xs122 true ys123)) ($singleton_elim (and xs122 ys123)))
)
(declare-rule bool-and-false ((xs124 Bool :list) (ys125 Bool :list))
  :args (xs124 ys125)
  :conclusion (= ($singleton_elim (and xs124 false ys125)) false)
)
(declare-rule bool-and-flatten ((xs126 Bool :list) (b127 Bool) (ys128 Bool :list) (zs129 Bool :list))
  :args (xs126 b127 ys128 zs129)
  :conclusion (= ($singleton_elim (and xs126 ($singleton_elim (and b127 ys128)) zs129)) ($singleton_elim (and xs126 b127 ys128 zs129)))
)
(declare-rule bool-and-dup ((xs130 Bool :list) (b131 Bool) (ys132 Bool :list) (zs133 Bool :list))
  :args (xs130 b131 ys132 zs133)
  :conclusion (= (and xs130 b131 ys132 b131 zs133) ($singleton_elim (and xs130 b131 ys132 zs133)))
)
(declare-rule bool-and-conf ((xs134 Bool :list) (w135 Bool) (ys136 Bool :list) (zs137 Bool :list))
  :args (xs134 w135 ys136 zs137)
  :conclusion (= (and xs134 w135 ys136 (not w135) zs137) false)
)
(declare-rule bool-or-taut ((xs138 Bool :list) (w139 Bool) (ys140 Bool :list) (zs141 Bool :list))
  :args (xs138 w139 ys140 zs141)
  :conclusion (= (or xs138 w139 ys140 (not w139) zs141) true)
)
(declare-rule bool-or-de-morgan ((x142 Bool) (y143 Bool) (zs144 Bool :list))
  :args (x142 y143 zs144)
  :conclusion (= (not (or x142 y143 zs144)) (and (not x142) (not ($singleton_elim (or y143 zs144)))))
)
(declare-rule bool-implies-de-morgan ((x145 Bool) (y146 Bool))
  :args (x145 y146)
  :conclusion (= (not (=> x145 y146)) (and x145 (not y146)))
)
(declare-rule bool-and-de-morgan ((x147 Bool) (y148 Bool) (zs149 Bool :list))
  :args (x147 y148 zs149)
  :conclusion (= (not (and x147 y148 zs149)) (or (not x147) (not ($singleton_elim (and y148 zs149)))))
)
(declare-rule bool-xor-refl ((x150 Bool))
  :args (x150)
  :conclusion (= (xor x150 x150) false)
)
(declare-rule bool-xor-nrefl ((x151 Bool))
  :args (x151)
  :conclusion (= (xor x151 (not x151)) true)
)
(declare-rule bool-xor-false ((x152 Bool))
  :args (x152)
  :conclusion (= (xor x152 false) x152)
)
(declare-rule bool-xor-true ((x153 Bool))
  :args (x153)
  :conclusion (= (xor x153 true) (not x153))
)
(declare-rule bool-xor-comm ((x154 Bool) (y155 Bool))
  :args (x154 y155)
  :conclusion (= (xor x154 y155) (xor y155 x154))
)
(declare-rule bool-xor-elim ((x156 Bool) (y157 Bool))
  :args (x156 y157)
  :conclusion (= (xor x156 y157) (= (not x156) y157))
)
(declare-rule bool-not-xor-elim ((x158 Bool) (y159 Bool))
  :args (x158 y159)
  :conclusion (= (not (xor x158 y159)) (= x158 y159))
)
(declare-rule bool-not-eq-elim ((x160 Bool) (y161 Bool))
  :args (x160 y161)
  :conclusion (= (not (= x160 y161)) (= (not x160) y161))
)
(declare-rule ite-neg-branch ((c162 Bool) (x163 Bool) (y164 Bool))
  :premises ((= (not y164) x163))
  :args (c162 x163 y164)
  :conclusion (= (ite c162 x163 y164) (= c162 x163))
)
(declare-rule ite-then-true ((c165 Bool) (x166 Bool))
  :args (c165 x166)
  :conclusion (= (ite c165 true x166) (or c165 x166))
)
(declare-rule ite-else-false ((c167 Bool) (x168 Bool))
  :args (c167 x168)
  :conclusion (= (ite c167 x168 false) (and c167 x168))
)
(declare-rule ite-then-false ((c169 Bool) (x170 Bool))
  :args (c169 x170)
  :conclusion (= (ite c169 false x170) (and (not c169) x170))
)
(declare-rule ite-else-true ((c171 Bool) (x172 Bool))
  :args (c171 x172)
  :conclusion (= (ite c171 x172 true) (or (not c171) x172))
)
(declare-rule ite-then-lookahead-self ((c173 Bool) (x174 Bool))
  :args (c173 x174)
  :conclusion (= (ite c173 c173 x174) (ite c173 true x174))
)
(declare-rule ite-else-lookahead-self ((c175 Bool) (x176 Bool))
  :args (c175 x176)
  :conclusion (= (ite c175 x176 c175) (ite c175 x176 false))
)
(declare-rule bool-not-ite-elim ((c177 Bool) (x178 Bool) (y179 Bool))
  :args (c177 x178 y179)
  :conclusion (= (not (ite c177 x178 y179)) (ite c177 (not x178) (not y179)))
)
(declare-rule ite-true-cond ((@T0 Type) (@T1 Type) (x190 @T0) (y191 @T1))
  :args (x190 y191)
  :conclusion (= (ite true x190 y191) x190)
)
(declare-rule ite-false-cond ((@T0 Type) (@T1 Type) (x192 @T0) (y193 @T1))
  :args (x192 y193)
  :conclusion (= (ite false x192 y193) y193)
)
(declare-rule ite-not-cond ((@T0 Type) (@T1 Type) (c194 Bool) (x195 @T0) (y196 @T1))
  :args (c194 x195 y196)
  :conclusion (= (ite (not c194) x195 y196) (ite c194 y196 x195))
)
(declare-rule ite-eq-branch ((@T0 Type) (c197 Bool) (x198 @T0))
  :args (c197 x198)
  :conclusion (= (ite c197 x198 x198) x198)
)
(declare-rule ite-then-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c199 Bool) (x200 @T0) (y201 @T1) (z202 @T2))
  :args (c199 x200 y201 z202)
  :conclusion (= (ite c199 (ite c199 x200 y201) z202) (ite c199 x200 z202))
)
(declare-rule ite-else-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c203 Bool) (x204 @T0) (y205 @T1) (z206 @T2))
  :args (c203 x204 y205 z206)
  :conclusion (= (ite c203 x204 (ite c203 y205 z206)) (ite c203 x204 z206))
)
(declare-rule ite-then-neg-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c207 Bool) (x208 @T0) (y209 @T1) (z210 @T2))
  :args (c207 x208 y209 z210)
  :conclusion (= (ite c207 (ite (not c207) x208 y209) z210) (ite c207 y209 z210))
)
(declare-rule ite-else-neg-lookahead ((@T0 Type) (@T1 Type) (@T2 Type) (c211 Bool) (x212 @T0) (y213 @T1) (z214 @T2))
  :args (c211 x212 y213 z214)
  :conclusion (= (ite c211 x212 (ite (not c211) y213 z214)) (ite c211 x212 y213))
)
(declare-rule bv-concat-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs216 (BitVec @n0) :list) (s217 (BitVec @n1)) (ys218 (BitVec @n2) :list) (zs219 (BitVec @n3) :list))
  :args (xs216 s217 ys218 zs219)
  :conclusion (= ($singleton_elim (concat xs216 ($singleton_elim (concat s217 ys218)) zs219)) ($singleton_elim (concat xs216 s217 ys218 zs219)))
)
(declare-rule bv-concat-extract-merge ((@n0 Int) (@n1 Int) (@n2 Int) (xs220 (BitVec @n0) :list) (s221 (BitVec @n1)) (ys222 (BitVec @n2) :list) (i223 Int) (j224 Int) (j1225 Int) (k226 Int))
  :premises ((= j1225 (+ j224 1)))
  :args (xs220 s221 ys222 i223 j224 j1225 k226)
  :conclusion (= (concat xs220 (extract k226 j1225 s221) (extract j224 i223 s221) ys222) ($singleton_elim (concat xs220 (extract k226 i223 s221) ys222)))
)
(declare-rule bv-extract-extract ((@n0 Int) (x227 (BitVec @n0)) (i228 Int) (j229 Int) (k230 Int) (l231 Int))
  :args (x227 i228 j229 k230 l231)
  :conclusion (= (extract l231 k230 (extract j229 i228 x227)) (extract (+ i228 l231) (+ i228 k230) x227))
)
(declare-rule bv-extract-whole ((@n0 Int) (x232 (BitVec @n0)) (n233 Int))
  :premises ((= (>= n233 (- (@bvsize x232) 1)) true))
  :args (x232 n233)
  :conclusion (= (extract n233 0 x232) x232)
)
(declare-rule bv-extract-concat-1 ((@n0 Int) (@n1 Int) (@n2 Int) (x234 (BitVec @n0)) (xs235 (BitVec @n1) :list) (y236 (BitVec @n2)) (i237 Int) (j238 Int))
  :premises ((= (<= j238 (@bvsize x234)) true))
  :args (x234 xs235 y236 i237 j238)
  :conclusion (= (extract j238 i237 (concat xs235 y236 x234)) (extract j238 i237 x234))
)
(declare-rule bv-extract-concat-2 ((@n0 Int) (@n1 Int) (@n2 Int) (x239 (BitVec @n0)) (xs240 (BitVec @n1) :list) (y241 (BitVec @n2)) (i242 Int) (j243 Int))
  :premises ((= (< i242 (@bvsize x239)) true) (= (>= j243 (@bvsize x239)) true))
  :args (x239 xs240 y241 i242 j243)
  :conclusion (= (extract j243 i242 (concat xs240 y241 x239)) (eo::define ((_let_1 (@bvsize x239))) (concat (extract (- j243 _let_1) 0 ($singleton_elim (concat xs240 y241))) (extract (- _let_1 1) i242 x239))))
)
(declare-rule bv-extract-concat-3 ((@n0 Int) (@n1 Int) (@n2 Int) (x244 (BitVec @n0)) (y245 (BitVec @n1)) (xs246 (BitVec @n2) :list) (i247 Int) (j248 Int))
  :premises ((= (>= i247 (@bvsize x244)) true))
  :args (x244 y245 xs246 i247 j248)
  :conclusion (= (extract j248 i247 (concat xs246 y245 x244)) (eo::define ((_let_1 (@bvsize x244))) (extract (- j248 _let_1) (- i247 _let_1) ($singleton_elim (concat xs246 y245)))))
)
(declare-rule bv-extract-concat-4 ((@n0 Int) (@n1 Int) (@n2 Int) (x249 (BitVec @n0)) (y250 (BitVec @n1)) (xs251 (BitVec @n2) :list) (i252 Int) (j253 Int))
  :premises ((= (< j253 (- (@bvsize (concat x249 xs251 y250)) (@bvsize x249))) true))
  :args (x249 y250 xs251 i252 j253)
  :conclusion (= (extract j253 i252 (concat x249 xs251 y250)) (extract j253 i252 ($singleton_elim (concat xs251 y250))))
)
(declare-rule bv-extract-bitwise-and ((@n0 Int) (@n1 Int) (x254 (BitVec @n0)) (y255 (BitVec @n1)) (i256 Int) (j257 Int))
  :args (x254 y255 i256 j257)
  :conclusion (= (extract j257 i256 (bvand x254 y255)) (bvand (extract j257 i256 x254) (extract j257 i256 y255)))
)
(declare-rule bv-extract-bitwise-or ((@n0 Int) (@n1 Int) (x258 (BitVec @n0)) (y259 (BitVec @n1)) (i260 Int) (j261 Int))
  :args (x258 y259 i260 j261)
  :conclusion (= (extract j261 i260 (bvor x258 y259)) (bvor (extract j261 i260 x258) (extract j261 i260 y259)))
)
(declare-rule bv-extract-bitwise-xor ((@n0 Int) (@n1 Int) (x262 (BitVec @n0)) (y263 (BitVec @n1)) (i264 Int) (j265 Int))
  :args (x262 y263 i264 j265)
  :conclusion (= (extract j265 i264 (bvxor x262 y263)) (bvxor (extract j265 i264 x262) (extract j265 i264 y263)))
)
(declare-rule bv-extract-not ((@n0 Int) (x266 (BitVec @n0)) (i267 Int) (j268 Int))
  :args (x266 i267 j268)
  :conclusion (= (extract j268 i267 (bvnot x266)) (bvnot (extract j268 i267 x266)))
)
(declare-rule bv-extract-sign-extend-1 ((@n0 Int) (x269 (BitVec @n0)) (low270 Int) (high271 Int) (k272 Int))
  :premises ((= (< high271 (@bvsize x269)) true))
  :args (x269 low270 high271 k272)
  :conclusion (= (extract high271 low270 (sign_extend k272 x269)) (extract high271 low270 x269))
)
(declare-rule bv-extract-sign-extend-2 ((@n0 Int) (x273 (BitVec @n0)) (low274 Int) (high275 Int) (k276 Int))
  :premises ((= (< low274 (@bvsize x273)) true) (= (>= high275 (@bvsize x273)) true))
  :args (x273 low274 high275 k276)
  :conclusion (= (extract high275 low274 (sign_extend k276 x273)) (eo::define ((_let_1 (@bvsize x273))) (sign_extend (+ 1 (- high275 _let_1)) (extract (- _let_1 1) low274 x273))))
)
(declare-rule bv-extract-sign-extend-3 ((@n0 Int) (x277 (BitVec @n0)) (low278 Int) (high279 Int) (k280 Int))
  :premises ((= (>= low278 (@bvsize x277)) true))
  :args (x277 low278 high279 k280)
  :conclusion (= (extract high279 low278 (sign_extend k280 x277)) (eo::define ((_let_1 (- (@bvsize x277) 1))) (repeat (+ 1 (- high279 low278)) (extract _let_1 _let_1 x277))))
)
(declare-rule bv-neg-mult ((@n0 Int) (@n1 Int) (xs281 (BitVec @n0)) (ys282 (BitVec @n1)) (n283 Int) (m284 Int))
  :args (xs281 ys282 n283 m284)
  :conclusion (= (bvneg (bvmul xs281 (@bv n283 m284) ys282)) (bvmul xs281 (@bv (- n283) m284) ys282))
)
(declare-rule bv-neg-add ((@n0 Int) (@n1 Int) (@n2 Int) (x285 (BitVec @n0)) (y286 (BitVec @n1)) (zs287 (BitVec @n2) :list))
  :args (x285 y286 zs287)
  :conclusion (= (bvneg (bvadd x285 y286 zs287)) (bvadd (bvneg x285) (bvneg ($singleton_elim (bvadd y286 zs287)))))
)
(declare-rule bv-mult-distrib-const-neg ((@n0 Int) (x288 (BitVec @n0)) (n289 Int) (m290 Int))
  :args (x288 n289 m290)
  :conclusion (= (bvmul (bvneg x288) (@bv n289 m290)) (bvmul x288 (@bv (- n289) m290)))
)
(declare-rule bv-mult-distrib-const-add ((@n0 Int) (@n1 Int) (x291 (BitVec @n0)) (y292 (BitVec @n1)) (n293 Int) (m294 Int))
  :args (x291 y292 n293 m294)
  :conclusion (= (bvmul (bvadd x291 y292) (@bv n293 m294)) (eo::define ((_let_1 (@bv n293 m294))) (bvadd (bvmul x291 _let_1) (bvmul y292 _let_1))))
)
(declare-rule bv-mult-distrib-const-sub ((@n0 Int) (@n1 Int) (x295 (BitVec @n0)) (y296 (BitVec @n1)) (n297 Int) (m298 Int))
  :args (x295 y296 n297 m298)
  :conclusion (= (bvmul (bvsub x295 y296) (@bv n297 m298)) (eo::define ((_let_1 (@bv n297 m298))) (bvsub (bvmul x295 _let_1) (bvmul y296 _let_1))))
)
(declare-rule bv-mult-distrib-1 ((@n0 Int) (@n1 Int) (@n2 Int) (x1299 (BitVec @n0)) (x2300 (BitVec @n1)) (y301 (BitVec @n2)))
  :args (x1299 x2300 y301)
  :conclusion (= (bvmul (bvadd x1299 x2300) y301) (bvadd (bvmul x1299 y301) (bvmul x2300 y301)))
)
(declare-rule bv-mult-distrib-2 ((@n0 Int) (@n1 Int) (@n2 Int) (x1302 (BitVec @n0)) (x2303 (BitVec @n1)) (y304 (BitVec @n2)))
  :args (x1302 x2303 y304)
  :conclusion (= (bvmul y304 (bvadd x1302 x2303)) (bvadd (bvmul y304 x1302) (bvmul y304 x2303)))
)
(declare-rule bv-not-xor ((@n0 Int) (@n1 Int) (x305 (BitVec @n0)) (xs306 (BitVec @n1) :list))
  :args (x305 xs306)
  :conclusion (= (bvnot ($singleton_elim (bvxor x305 xs306))) ($singleton_elim (bvxor (bvnot x305) xs306)))
)
(declare-rule bv-and-simplify-1 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs307 (BitVec @n0) :list) (ys308 (BitVec @n1) :list) (zs309 (BitVec @n2) :list) (x310 (BitVec @n3)))
  :args (xs307 ys308 zs309 x310)
  :conclusion (= (bvand xs307 x310 ys308 x310 zs309) ($singleton_elim (bvand xs307 x310 ys308 zs309)))
)
(declare-rule bv-and-simplify-2 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs311 (BitVec @n0) :list) (ys312 (BitVec @n1) :list) (zs313 (BitVec @n2) :list) (x314 (BitVec @n3)))
  :args (xs311 ys312 zs313 x314)
  :conclusion (= (bvand xs311 x314 ys312 (bvnot x314) zs313) (@bv 0 (@bvsize x314)))
)
(declare-rule bv-or-simplify-1 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs315 (BitVec @n0) :list) (ys316 (BitVec @n1) :list) (zs317 (BitVec @n2) :list) (x318 (BitVec @n3)))
  :args (xs315 ys316 zs317 x318)
  :conclusion (= (bvor xs315 x318 ys316 x318 zs317) ($singleton_elim (bvor xs315 x318 ys316 zs317)))
)
(declare-rule bv-or-simplify-2 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs319 (BitVec @n0) :list) (ys320 (BitVec @n1) :list) (zs321 (BitVec @n2) :list) (x322 (BitVec @n3)))
  :args (xs319 ys320 zs321 x322)
  :conclusion (= (bvor xs319 x322 ys320 (bvnot x322) zs321) (bvnot (@bv 0 (@bvsize x322))))
)
(declare-rule bv-xor-simplify-1 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs323 (BitVec @n0) :list) (ys324 (BitVec @n1) :list) (zs325 (BitVec @n2) :list) (x326 (BitVec @n3)))
  :args (xs323 ys324 zs325 x326)
  :conclusion (= (bvxor xs323 x326 ys324 x326 zs325) ($singleton_elim (bvxor xs323 ys324 zs325)))
)
(declare-rule bv-xor-simplify-2 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs327 (BitVec @n0) :list) (ys328 (BitVec @n1) :list) (zs329 (BitVec @n2) :list) (x330 (BitVec @n3)))
  :args (xs327 ys328 zs329 x330)
  :conclusion (= (bvxor xs327 x330 ys328 (bvnot x330) zs329) (bvnot ($singleton_elim (bvxor xs327 ys328 zs329))))
)
(declare-rule bv-xor-simplify-3 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs331 (BitVec @n0) :list) (ys332 (BitVec @n1) :list) (zs333 (BitVec @n2) :list) (x334 (BitVec @n3)))
  :args (xs331 ys332 zs333 x334)
  :conclusion (= (bvxor xs331 (bvnot x334) ys332 x334 zs333) (bvnot ($singleton_elim (bvxor xs331 ys332 zs333))))
)
(declare-rule bv-ult-add-one ((@n0 Int) (@n1 Int) (@n2 Int) (x335 (BitVec @n0)) (y336 (BitVec @n1)) (c1337 (BitVec @n2)))
  :premises ((= c1337 (@bv 1 (@bvsize c1337))))
  :args (x335 y336 c1337)
  :conclusion (= (bvult x335 (bvadd y336 c1337)) (and (not (bvult y336 x335)) (not (= y336 (bvnot (@bv 0 (@bvsize y336)))))))
)
(declare-rule bv-concat-to-mult ((@n0 Int) (x338 (BitVec @n0)) (i339 Int) (m340 Int) (n0341 Int))
  :premises ((= (+ 1 i339 m340) (@bvsize x338)) (= n0341 0))
  :args (x338 i339 m340 n0341)
  :conclusion (= (concat (extract i339 n0341 x338) (@bv n0341 m340)) (eo::define ((_let_1 (@bvsize x338))) (bvmul x338 (bvshl (@bv 1 _let_1) (@bv m340 _let_1)))))
)
(declare-rule bv-mult-slt-mult-1 ((@n0 Int) (@n1 Int) (@n2 Int) (x342 (BitVec @n0)) (t343 (BitVec @n1)) (a344 (BitVec @n2)) (n345 Int) (m346 Int))
  :args (x342 t343 a344 n345 m346)
  :conclusion (= (eo::define ((_let_1 (sign_extend m346 a344))) (bvslt (bvmul (sign_extend n345 (bvadd x342 t343)) _let_1) (bvmul (sign_extend n345 x342) _let_1))) (eo::define ((_let_1 (@bv 0 (@bvsize a344)))) (and (not (= t343 (@bv 0 (@bvsize t343)))) (not (= a344 _let_1)) (= (bvslt (bvadd x342 t343) x342) (bvsgt a344 _let_1)))))
)
(declare-rule bv-mult-slt-mult-2 ((@n0 Int) (@n1 Int) (@n2 Int) (x347 (BitVec @n0)) (t348 (BitVec @n1)) (a349 (BitVec @n2)) (n350 Int) (m351 Int))
  :args (x347 t348 a349 n350 m351)
  :conclusion (= (eo::define ((_let_1 (sign_extend m351 a349))) (bvslt (bvmul (zero_extend n350 (bvadd x347 t348)) _let_1) (bvmul (zero_extend n350 x347) _let_1))) (eo::define ((_let_1 (@bv 0 (@bvsize a349)))) (and (not (= t348 (@bv 0 (@bvsize t348)))) (not (= a349 _let_1)) (= (bvult (bvadd x347 t348) x347) (bvsgt a349 _let_1)))))
)
(declare-rule bv-commutative-and ((@n0 Int) (@n1 Int) (x352 (BitVec @n0)) (y353 (BitVec @n1)))
  :args (x352 y353)
  :conclusion (= (bvand x352 y353) (bvand y353 x352))
)
(declare-rule bv-commutative-or ((@n0 Int) (@n1 Int) (x354 (BitVec @n0)) (y355 (BitVec @n1)))
  :args (x354 y355)
  :conclusion (= (bvor x354 y355) (bvor y355 x354))
)
(declare-rule bv-commutative-xor ((@n0 Int) (@n1 Int) (x356 (BitVec @n0)) (y357 (BitVec @n1)))
  :args (x356 y357)
  :conclusion (= (bvxor x356 y357) (bvxor y357 x356))
)
(declare-rule bv-commutative-mul ((@n0 Int) (@n1 Int) (x358 (BitVec @n0)) (y359 (BitVec @n1)))
  :args (x358 y359)
  :conclusion (= (bvmul x358 y359) (bvmul y359 x358))
)
(declare-rule bv-or-zero ((@n0 Int) (x360 (BitVec @n0)) (n361 Int))
  :args (x360 n361)
  :conclusion (= (bvor x360 (@bv 0 n361)) x360)
)
(declare-rule bv-mul-one ((@n0 Int) (@n1 Int) (x362 (BitVec @n0)) (c1363 (BitVec @n1)))
  :premises ((= c1363 (@bv 1 (@bvsize c1363))))
  :args (x362 c1363)
  :conclusion (= (bvmul x362 c1363) x362)
)
(declare-rule bv-mul-zero ((@n0 Int) (@n1 Int) (x364 (BitVec @n0)) (c0365 (BitVec @n1)))
  :premises ((= c0365 (@bv 0 (@bvsize c0365))))
  :args (x364 c0365)
  :conclusion (= (bvmul x364 c0365) (@bv 0 (@bvsize x364)))
)
(declare-rule bv-add-zero ((@n0 Int) (@n1 Int) (x366 (BitVec @n0)) (c0367 (BitVec @n1)))
  :premises ((= c0367 (@bv 0 (@bvsize c0367))))
  :args (x366 c0367)
  :conclusion (= (bvadd x366 c0367) x366)
)
(declare-rule bv-add-two ((@n0 Int) (x368 (BitVec @n0)))
  :args (x368)
  :conclusion (= (bvadd x368 x368) (bvmul x368 (@bv 2 (@bvsize x368))))
)
(declare-rule bv-zero-extend-eliminate-0 ((@n0 Int) (x369 (BitVec @n0)))
  :args (x369)
  :conclusion (= (zero_extend 0 x369) x369)
)
(declare-rule bv-sign-extend-eliminate-0 ((@n0 Int) (x370 (BitVec @n0)))
  :args (x370)
  :conclusion (= (sign_extend 0 x370) x370)
)
(declare-rule bv-not-neq ((@n0 Int) (x371 (BitVec @n0)))
  :premises ((= (> (@bvsize x371) 0) true))
  :args (x371)
  :conclusion (= (= x371 (bvnot x371)) false)
)
(declare-rule bv-ult-ones ((@n0 Int) (@n1 Int) (x372 (BitVec @n0)) (y373 (BitVec @n1)))
  :premises ((= y373 (bvnot (@bv 0 (@bvsize y373)))))
  :args (x372 y373)
  :conclusion (= (bvult x372 y373) (distinct x372 y373))
)
(declare-rule bv-or-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs374 (BitVec @n0) :list) (s375 (BitVec @n1)) (ys376 (BitVec @n2) :list) (zs377 (BitVec @n3) :list))
  :args (xs374 s375 ys376 zs377)
  :conclusion (= ($singleton_elim (bvor xs374 ($singleton_elim (bvor s375 ys376)) zs377)) ($singleton_elim (bvor xs374 s375 ys376 zs377)))
)
(declare-rule bv-xor-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs378 (BitVec @n0) :list) (s379 (BitVec @n1)) (ys380 (BitVec @n2) :list) (zs381 (BitVec @n3) :list))
  :args (xs378 s379 ys380 zs381)
  :conclusion (= ($singleton_elim (bvxor xs378 ($singleton_elim (bvxor s379 ys380)) zs381)) ($singleton_elim (bvxor xs378 s379 ys380 zs381)))
)
(declare-rule bv-and-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs382 (BitVec @n0) :list) (s383 (BitVec @n1)) (ys384 (BitVec @n2) :list) (zs385 (BitVec @n3) :list))
  :args (xs382 s383 ys384 zs385)
  :conclusion (= ($singleton_elim (bvand xs382 ($singleton_elim (bvand s383 ys384)) zs385)) ($singleton_elim (bvand xs382 s383 ys384 zs385)))
)
(declare-rule bv-mul-flatten ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (xs386 (BitVec @n0) :list) (s387 (BitVec @n1)) (ys388 (BitVec @n2) :list) (zs389 (BitVec @n3) :list))
  :args (xs386 s387 ys388 zs389)
  :conclusion (= ($singleton_elim (bvmul xs386 ($singleton_elim (bvmul s387 ys388)) zs389)) ($singleton_elim (bvmul xs386 s387 ys388 zs389)))
)
(declare-rule bv-concat-merge-const ((@n0 Int) (@n1 Int) (xs390 (BitVec @n0) :list) (n1391 Int) (w1392 Int) (n2393 Int) (w2394 Int) (zs395 (BitVec @n1) :list))
  :args (xs390 n1391 w1392 n2393 w2394 zs395)
  :conclusion (= (concat xs390 (@bv n1391 w1392) (@bv n2393 w2394) zs395) ($singleton_elim (concat xs390 (@bv (+ (* n1391 (int.pow2 w2394)) n2393) (+ w1392 w2394)) zs395)))
)
(declare-rule bv-commutative-add ((@n0 Int) (@n1 Int) (x396 (BitVec @n0)) (y397 (BitVec @n1)))
  :args (x396 y397)
  :conclusion (= (bvadd x396 y397) (bvadd y397 x396))
)
(declare-rule bv-neg-sub ((@n0 Int) (@n1 Int) (x398 (BitVec @n0)) (y399 (BitVec @n1)))
  :args (x398 y399)
  :conclusion (= (bvneg (bvsub x398 y399)) (bvsub y399 x398))
)
(declare-rule bv-neg-idemp ((@n0 Int) (x400 (BitVec @n0)))
  :args (x400)
  :conclusion (= (bvneg (bvneg x400)) x400)
)
(declare-rule bv-sub-eliminate ((@n0 Int) (@n1 Int) (x401 (BitVec @n0)) (y402 (BitVec @n1)))
  :args (x401 y402)
  :conclusion (= (bvsub x401 y402) (bvadd x401 (bvneg y402)))
)
(declare-rule bv-ugt-eliminate ((@n0 Int) (@n1 Int) (x432 (BitVec @n0)) (y433 (BitVec @n1)))
  :args (x432 y433)
  :conclusion (= (bvugt x432 y433) (bvult y433 x432))
)
(declare-rule bv-uge-eliminate ((@n0 Int) (@n1 Int) (x434 (BitVec @n0)) (y435 (BitVec @n1)))
  :args (x434 y435)
  :conclusion (= (bvuge x434 y435) (bvule y435 x434))
)
(declare-rule bv-sgt-eliminate ((@n0 Int) (@n1 Int) (x436 (BitVec @n0)) (y437 (BitVec @n1)))
  :args (x436 y437)
  :conclusion (= (bvsgt x436 y437) (bvslt y437 x436))
)
(declare-rule bv-sge-eliminate ((@n0 Int) (@n1 Int) (x438 (BitVec @n0)) (y439 (BitVec @n1)))
  :args (x438 y439)
  :conclusion (= (bvsge x438 y439) (bvsle y439 x438))
)
(declare-rule bv-slt-eliminate ((@n0 Int) (@n1 Int) (x440 (BitVec @n0)) (y441 (BitVec @n1)))
  :args (x440 y441)
  :conclusion (= (bvslt x440 y441) (eo::define ((_let_1 (@bvsize x440))) (eo::define ((_let_2 (bvshl (@bv 1 _let_1) (@bv (- _let_1 1) _let_1)))) (bvult (bvadd x440 _let_2) (bvadd y441 _let_2)))))
)
(declare-rule bv-sle-eliminate ((@n0 Int) (@n1 Int) (x442 (BitVec @n0)) (y443 (BitVec @n1)))
  :args (x442 y443)
  :conclusion (= (bvsle x442 y443) (not (bvslt y443 x442)))
)
(declare-rule bv-redor-eliminate ((@n0 Int) (x444 (BitVec @n0)))
  :args (x444)
  :conclusion (= (bvredor x444) (bvnot (bvcomp x444 (@bv 0 (@bvsize x444)))))
)
(declare-rule bv-redand-eliminate ((@n0 Int) (x445 (BitVec @n0)))
  :args (x445)
  :conclusion (= (bvredand x445) (bvcomp x445 (bvnot (@bv 0 (@bvsize x445)))))
)
(declare-rule bv-ule-eliminate ((@n0 Int) (@n1 Int) (x446 (BitVec @n0)) (y447 (BitVec @n1)))
  :args (x446 y447)
  :conclusion (= (bvule x446 y447) (not (bvult y447 x446)))
)
(declare-rule bv-comp-eliminate ((@n0 Int) (@n1 Int) (x448 (BitVec @n0)) (y449 (BitVec @n1)))
  :args (x448 y449)
  :conclusion (= (bvcomp x448 y449) (ite (= x448 y449) (@bv 1 1) (@bv 0 1)))
)
(declare-rule bv-repeat-eliminate-1 ((@n0 Int) (x450 (BitVec @n0)) (n451 Int))
  :premises ((= (> n451 1) true))
  :args (x450 n451)
  :conclusion (= (repeat n451 x450) (concat x450 (repeat (- n451 1) x450)))
)
(declare-rule bv-repeat-eliminate-2 ((@n0 Int) (x452 (BitVec @n0)) (n453 Int))
  :premises ((= n453 1))
  :args (x452 n453)
  :conclusion (= (repeat n453 x452) x452)
)
(declare-rule bv-rotate-left-eliminate-1 ((@n0 Int) (x454 (BitVec @n0)) (amount455 Int))
  :premises ((= (= (mod amount455 (@bvsize x454)) 0) false))
  :args (x454 amount455)
  :conclusion (= (rotate_left amount455 x454) (eo::define ((_let_1 (@bvsize x454))) (eo::define ((_let_2 (mod amount455 _let_1))) (concat (extract (- _let_1 (+ 1 _let_2)) 0 x454) (extract (- _let_1 1) (- _let_1 _let_2) x454)))))
)
(declare-rule bv-rotate-left-eliminate-2 ((@n0 Int) (x456 (BitVec @n0)) (amount457 Int))
  :premises ((= (mod amount457 (@bvsize x456)) 0))
  :args (x456 amount457)
  :conclusion (= (rotate_left amount457 x456) x456)
)
(declare-rule bv-rotate-right-eliminate-1 ((@n0 Int) (x458 (BitVec @n0)) (amount459 Int))
  :premises ((= (= (mod amount459 (@bvsize x458)) 0) false))
  :args (x458 amount459)
  :conclusion (= (rotate_right amount459 x458) (eo::define ((_let_1 (@bvsize x458))) (eo::define ((_let_2 (mod amount459 _let_1))) (concat (extract (- _let_2 1) 0 x458) (extract (- _let_1 1) _let_2 x458)))))
)
(declare-rule bv-rotate-right-eliminate-2 ((@n0 Int) (x460 (BitVec @n0)) (amount461 Int))
  :premises ((= (mod amount461 (@bvsize x460)) 0))
  :args (x460 amount461)
  :conclusion (= (rotate_right amount461 x460) x460)
)
(declare-rule bv-nand-eliminate ((@n0 Int) (@n1 Int) (x462 (BitVec @n0)) (y463 (BitVec @n1)))
  :args (x462 y463)
  :conclusion (= (bvnand x462 y463) (bvnot (bvand x462 y463)))
)
(declare-rule bv-nor-eliminate ((@n0 Int) (@n1 Int) (x464 (BitVec @n0)) (y465 (BitVec @n1)))
  :args (x464 y465)
  :conclusion (= (bvnor x464 y465) (bvnot (bvor x464 y465)))
)
(declare-rule bv-xnor-eliminate ((@n0 Int) (@n1 Int) (x466 (BitVec @n0)) (y467 (BitVec @n1)))
  :args (x466 y467)
  :conclusion (= (bvxnor x466 y467) (bvnot (bvxor x466 y467)))
)
(declare-rule bv-sdiv-eliminate ((@n0 Int) (@n1 Int) (x468 (BitVec @n0)) (y469 (BitVec @n1)))
  :args (x468 y469)
  :conclusion (= (bvsdiv x468 y469) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (- (@bvsize x468) 1))) (eo::define ((_let_3 (= (extract _let_2 _let_2 y469) _let_1))) (eo::define ((_let_4 (= (extract _let_2 _let_2 x468) _let_1))) (eo::define ((_let_5 (bvudiv (ite _let_4 (bvneg x468) x468) (ite _let_3 (bvneg y469) y469)))) (ite (xor _let_4 _let_3) (bvneg _let_5) _let_5)))))))
)
(declare-rule bv-sdiv-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x470 (BitVec @n0)) (y471 (BitVec @n1)))
  :args (x470 y471)
  :conclusion (= (bvsdiv x470 y471) (eo::define ((_let_1 (concat (@bv 1 1) (@bv 0 (- (@bvsize x470) 1))))) (eo::define ((_let_2 (bvuge y471 _let_1))) (eo::define ((_let_3 (bvuge x470 _let_1))) (eo::define ((_let_4 (bvudiv (ite _let_3 (bvneg x470) x470) (ite _let_2 (bvneg y471) y471)))) (ite (xor _let_3 _let_2) (bvneg _let_4) _let_4))))))
)
(declare-rule bv-zero-extend-eliminate ((@n0 Int) (x472 (BitVec @n0)) (n473 Int))
  :args (x472 n473)
  :conclusion (= (zero_extend n473 x472) (concat (@bv 0 n473) x472))
)
(declare-rule bv-sign-extend-eliminate ((@n0 Int) (x474 (BitVec @n0)) (n475 Int))
  :args (x474 n475)
  :conclusion (= (sign_extend n475 x474) (eo::define ((_let_1 (- (@bvsize x474) 1))) (concat (repeat n475 (extract _let_1 _let_1 x474)) x474)))
)
(declare-rule bv-uaddo-eliminate ((@n0 Int) (@n1 Int) (x476 (BitVec @n0)) (y477 (BitVec @n1)))
  :args (x476 y477)
  :conclusion (= (bvuaddo x476 y477) (eo::define ((_let_1 (@bv 0 1))) (eo::define ((_let_2 (- (@bvsize x476) 1))) (= (extract _let_2 _let_2 (bvadd (concat _let_1 x476) (concat _let_1 y477))) (@bv 1 1)))))
)
(declare-rule bv-saddo-eliminate ((@n0 Int) (@n1 Int) (x478 (BitVec @n0)) (y479 (BitVec @n1)))
  :args (x478 y479)
  :conclusion (= (bvsaddo x478 y479) (eo::define ((_let_1 (@bv 0 1))) (eo::define ((_let_2 (- (@bvsize x478) 1))) (eo::define ((_let_3 (extract _let_2 _let_2 (bvadd x478 y479)))) (eo::define ((_let_4 (@bv 1 1))) (eo::define ((_let_5 (extract _let_2 _let_2 y479))) (eo::define ((_let_6 (extract _let_2 _let_2 x478))) (or (and (and (= _let_6 _let_1) (= _let_5 _let_1)) (= _let_3 _let_4)) (and (and (= _let_6 _let_4) (= _let_5 _let_4)) (= _let_3 _let_1))))))))))
)
(declare-rule bv-sdivo-eliminate ((@n0 Int) (@n1 Int) (x480 (BitVec @n0)) (y481 (BitVec @n1)))
  :args (x480 y481)
  :conclusion (= (bvsdivo x480 y481) (and (= x480 (concat (@bv 1 1) (@bv 0 (- (@bvsize x480) 1)))) (= y481 (bvnot (@bv 0 (@bvsize y481))))))
)
(declare-rule bv-smod-eliminate ((@n0 Int) (@n1 Int) (x482 (BitVec @n0)) (y483 (BitVec @n1)))
  :args (x482 y483)
  :conclusion (= (bvsmod x482 y483) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (@bvsize x482))) (eo::define ((_let_3 (- _let_2 1))) (eo::define ((_let_4 (= (extract _let_3 _let_3 y483) _let_1))) (eo::define ((_let_5 (= (extract _let_3 _let_3 x482) _let_1))) (eo::define ((_let_6 (bvurem (ite _let_5 (bvneg x482) x482) (ite _let_4 (bvneg y483) y483)))) (eo::define ((_let_7 (bvneg _let_6))) (eo::define ((_let_8 (not _let_5))) (eo::define ((_let_9 (not _let_4))) (ite (= _let_6 (@bv 0 _let_2)) _let_6 (ite (and _let_8 _let_9) _let_6 (ite (and _let_5 _let_9) (bvadd _let_7 y483) (ite (and _let_8 _let_4) (bvadd _let_6 y483) _let_7))))))))))))))
)
(declare-rule bv-smod-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x484 (BitVec @n0)) (y485 (BitVec @n1)))
  :args (x484 y485)
  :conclusion (= (bvsmod x484 y485) (eo::define ((_let_1 (@bvsize x484))) (eo::define ((_let_2 (concat (@bv 1 1) (@bv 0 (- _let_1 1))))) (eo::define ((_let_3 (bvuge y485 _let_2))) (eo::define ((_let_4 (bvuge x484 _let_2))) (eo::define ((_let_5 (bvurem (ite _let_4 (bvneg x484) x484) (ite _let_3 (bvneg y485) y485)))) (eo::define ((_let_6 (bvneg _let_5))) (eo::define ((_let_7 (not _let_4))) (eo::define ((_let_8 (not _let_3))) (ite (= _let_5 (@bv 0 _let_1)) _let_5 (ite (and _let_7 _let_8) _let_5 (ite (and _let_4 _let_8) (bvadd _let_6 y485) (ite (and _let_7 _let_3) (bvadd _let_5 y485) _let_6)))))))))))))
)
(declare-rule bv-srem-eliminate ((@n0 Int) (@n1 Int) (x486 (BitVec @n0)) (y487 (BitVec @n1)))
  :args (x486 y487)
  :conclusion (= (bvsrem x486 y487) (eo::define ((_let_1 (- (@bvsize x486) 1))) (eo::define ((_let_2 (extract _let_1 _let_1 x486))) (eo::define ((_let_3 (bvurem (bvite _let_2 (bvneg x486) x486) (bvite (extract _let_1 _let_1 y487) (bvneg y487) y487)))) (bvite _let_2 (bvneg _let_3) _let_3)))))
)
(declare-rule bv-srem-eliminate-fewer-bitwise-ops ((@n0 Int) (@n1 Int) (x488 (BitVec @n0)) (y489 (BitVec @n1)))
  :args (x488 y489)
  :conclusion (= (bvsrem x488 y489) (eo::define ((_let_1 (concat (@bv 1 1) (@bv 0 (- (@bvsize x488) 1))))) (eo::define ((_let_2 (bvuge x488 _let_1))) (eo::define ((_let_3 (bvurem (ite _let_2 (bvneg x488) x488) (ite (bvuge y489 _let_1) (bvneg y489) y489)))) (ite _let_2 (bvneg _let_3) _let_3)))))
)
(declare-rule bv-usubo-eliminate ((@n0 Int) (@n1 Int) (x490 (BitVec @n0)) (y491 (BitVec @n1)))
  :args (x490 y491)
  :conclusion (= (bvusubo x490 y491) (eo::define ((_let_1 (@bvsize x490))) (= (extract _let_1 _let_1 (bvsub (zero_extend 1 x490) (zero_extend 1 y491))) (@bv 1 1))))
)
(declare-rule bv-ssubo-eliminate ((@n0 Int) (@n1 Int) (x492 (BitVec @n0)) (y493 (BitVec @n1)))
  :args (x492 y493)
  :conclusion (= (bvssubo x492 y493) (eo::define ((_let_1 (@bv 1 1))) (eo::define ((_let_2 (- (@bvsize x492) 1))) (eo::define ((_let_3 (= (extract _let_2 _let_2 (bvsub x492 y493)) _let_1))) (eo::define ((_let_4 (= (extract _let_2 _let_2 y493) _let_1))) (eo::define ((_let_5 (= (extract _let_2 _let_2 x492) _let_1))) (or (and _let_5 (not _let_4) (not _let_3)) (and (not _let_5) _let_4 _let_3))))))))
)
(declare-rule bv-ite-equal-children ((@n0 Int) (c546 (_ BitVec 1)) (x547 (BitVec @n0)))
  :args (c546 x547)
  :conclusion (= (bvite c546 x547 x547) x547)
)
(declare-rule bv-ite-const-children-1 ((c548 (_ BitVec 1)))
  :args (c548)
  :conclusion (= (bvite c548 (@bv 0 1) (@bv 1 1)) (bvnot c548))
)
(declare-rule bv-ite-const-children-2 ((c549 (_ BitVec 1)))
  :args (c549)
  :conclusion (= (bvite c549 (@bv 1 1) (@bv 0 1)) c549)
)
(declare-rule bv-ite-equal-cond-1 ((@n0 Int) (@n1 Int) (@n2 Int) (c0550 (_ BitVec 1)) (t0551 (BitVec @n0)) (e0552 (BitVec @n1)) (e1553 (BitVec @n2)))
  :args (c0550 t0551 e0552 e1553)
  :conclusion (= (bvite c0550 (bvite c0550 t0551 e0552) e1553) (bvite c0550 t0551 e1553))
)
(declare-rule bv-ite-equal-cond-2 ((@n0 Int) (@n1 Int) (@n2 Int) (c0554 (_ BitVec 1)) (t0555 (BitVec @n0)) (t1556 (BitVec @n1)) (e1557 (BitVec @n2)))
  :args (c0554 t0555 t1556 e1557)
  :conclusion (= (bvite c0554 t0555 (bvite c0554 t1556 e1557)) (bvite c0554 t0555 e1557))
)
(declare-rule bv-ite-equal-cond-3 ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (c0558 (_ BitVec 1)) (t0559 (BitVec @n0)) (e0560 (BitVec @n1)) (t1561 (BitVec @n2)) (e1562 (BitVec @n3)))
  :args (c0558 t0559 e0560 t1561 e1562)
  :conclusion (= (bvite c0558 (bvite c0558 t0559 e0560) (bvite c0558 t1561 e1562)) (bvite c0558 t0559 e1562))
)
(declare-rule bv-ite-merge-then-if ((@n0 Int) (@n1 Int) (c0563 (_ BitVec 1)) (c1564 (_ BitVec 1)) (t1565 (BitVec @n0)) (e1566 (BitVec @n1)))
  :args (c0563 c1564 t1565 e1566)
  :conclusion (= (bvite c0563 (bvite c1564 t1565 e1566) t1565) (bvite (bvand c0563 (bvnot c1564)) e1566 t1565))
)
(declare-rule bv-ite-merge-else-if ((@n0 Int) (@n1 Int) (c0567 (_ BitVec 1)) (c1568 (_ BitVec 1)) (t1569 (BitVec @n0)) (e1570 (BitVec @n1)))
  :args (c0567 c1568 t1569 e1570)
  :conclusion (= (bvite c0567 (bvite c1568 t1569 e1570) e1570) (bvite (bvand c0567 c1568) t1569 e1570))
)
(declare-rule bv-ite-merge-then-else ((@n0 Int) (@n1 Int) (c0571 (_ BitVec 1)) (c1572 (_ BitVec 1)) (t0573 (BitVec @n0)) (e1574 (BitVec @n1)))
  :args (c0571 c1572 t0573 e1574)
  :conclusion (= (bvite c0571 t0573 (bvite c1572 t0573 e1574)) (bvite (bvnor c0571 c1572) e1574 t0573))
)
(declare-rule bv-ite-merge-else-else ((@n0 Int) (@n1 Int) (c0575 (_ BitVec 1)) (c1576 (_ BitVec 1)) (t1577 (BitVec @n0)) (t0578 (BitVec @n1)))
  :args (c0575 c1576 t1577 t0578)
  :conclusion (= (bvite c0575 t0578 (bvite c1576 t1577 t0578)) (bvite (bvand (bvnot c0575) c1576) t1577 t0578))
)
(declare-rule bv-shl-by-const-0 ((@n0 Int) (x579 (BitVec @n0)) (sz580 Int))
  :args (x579 sz580)
  :conclusion (= (bvshl x579 (@bv 0 sz580)) x579)
)
(declare-rule bv-shl-by-const-1 ((@n0 Int) (x581 (BitVec @n0)) (amount582 Int) (sz583 Int))
  :premises ((= (< amount582 (@bvsize x581)) true))
  :args (x581 amount582 sz583)
  :conclusion (= (bvshl x581 (@bv amount582 sz583)) (concat (extract (- (@bvsize x581) (+ 1 amount582)) 0 x581) (@bv 0 amount582)))
)
(declare-rule bv-shl-by-const-2 ((@n0 Int) (x584 (BitVec @n0)) (amount585 Int) (sz586 Int))
  :premises ((= (>= amount585 (@bvsize x584)) true))
  :args (x584 amount585 sz586)
  :conclusion (= (bvshl x584 (@bv amount585 sz586)) (@bv 0 (@bvsize x584)))
)
(declare-rule bv-lshr-by-const-0 ((@n0 Int) (x587 (BitVec @n0)) (sz588 Int))
  :args (x587 sz588)
  :conclusion (= (bvlshr x587 (@bv 0 sz588)) x587)
)
(declare-rule bv-lshr-by-const-1 ((@n0 Int) (x589 (BitVec @n0)) (amount590 Int) (sz591 Int))
  :premises ((= (< amount590 (@bvsize x589)) true))
  :args (x589 amount590 sz591)
  :conclusion (= (bvlshr x589 (@bv amount590 sz591)) (concat (@bv 0 amount590) (extract (- (@bvsize x589) 1) amount590 x589)))
)
(declare-rule bv-lshr-by-const-2 ((@n0 Int) (x592 (BitVec @n0)) (amount593 Int) (sz594 Int))
  :premises ((= (>= amount593 (@bvsize x592)) true))
  :args (x592 amount593 sz594)
  :conclusion (= (bvlshr x592 (@bv amount593 sz594)) (@bv 0 sz594))
)
(declare-rule bv-ashr-by-const-0 ((@n0 Int) (x595 (BitVec @n0)) (sz596 Int))
  :args (x595 sz596)
  :conclusion (= (bvashr x595 (@bv 0 sz596)) x595)
)
(declare-rule bv-ashr-by-const-1 ((@n0 Int) (x597 (BitVec @n0)) (amount598 Int) (sz599 Int))
  :premises ((= (< amount598 (@bvsize x597)) true))
  :args (x597 amount598 sz599)
  :conclusion (= (bvashr x597 (@bv amount598 sz599)) (eo::define ((_let_1 (- (@bvsize x597) 1))) (concat (repeat amount598 (extract _let_1 _let_1 x597)) (extract _let_1 amount598 x597))))
)
(declare-rule bv-ashr-by-const-2 ((@n0 Int) (x600 (BitVec @n0)) (amount601 Int) (sz602 Int))
  :premises ((= (>= amount601 (@bvsize x600)) true))
  :args (x600 amount601 sz602)
  :conclusion (= (bvashr x600 (@bv amount601 sz602)) (eo::define ((_let_1 (@bvsize x600))) (eo::define ((_let_2 (- _let_1 1))) (repeat _let_1 (extract _let_2 _let_2 x600)))))
)
(declare-rule bv-and-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x603 (BitVec @n0)) (y604 (BitVec @n1)) (z605 (BitVec @n2)) (ys606 (BitVec @n3) :list))
  :args (x603 y604 z605 ys606)
  :conclusion (= (bvand x603 (concat ys606 z605 y604)) (eo::define ((_let_1 (@bvsize y604))) (concat (bvand (extract (- (@bvsize x603) 1) _let_1 x603) ($singleton_elim (concat ys606 z605))) (bvand (extract (- _let_1 1) 0 x603) y604))))
)
(declare-rule bv-or-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x607 (BitVec @n0)) (y608 (BitVec @n1)) (z609 (BitVec @n2)) (ys610 (BitVec @n3) :list))
  :args (x607 y608 z609 ys610)
  :conclusion (= (bvor x607 (concat ys610 z609 y608)) (eo::define ((_let_1 (@bvsize y608))) (concat (bvor (extract (- (@bvsize x607) 1) _let_1 x607) ($singleton_elim (concat ys610 z609))) (bvor (extract (- _let_1 1) 0 x607) y608))))
)
(declare-rule bv-xor-concat-pullup ((@n0 Int) (@n1 Int) (@n2 Int) (@n3 Int) (x611 (BitVec @n0)) (y612 (BitVec @n1)) (z613 (BitVec @n2)) (ys614 (BitVec @n3) :list))
  :args (x611 y612 z613 ys614)
  :conclusion (= (bvxor x611 (concat ys614 z613 y612)) (eo::define ((_let_1 (@bvsize y612))) (concat (bvxor (extract (- (@bvsize x611) 1) _let_1 x611) ($singleton_elim (concat ys614 z613))) (bvxor (extract (- _let_1 1) 0 x611) y612))))
)
(declare-rule bv-bitwise-idemp-1 ((@n0 Int) (x615 (BitVec @n0)))
  :args (x615)
  :conclusion (= (bvand x615 x615) x615)
)
(declare-rule bv-bitwise-idemp-2 ((@n0 Int) (x616 (BitVec @n0)))
  :args (x616)
  :conclusion (= (bvor x616 x616) x616)
)
(declare-rule bv-and-zero ((@n0 Int) (x617 (BitVec @n0)) (n618 Int))
  :args (x617 n618)
  :conclusion (= (bvand x617 (@bv 0 n618)) (@bv 0 n618))
)
(declare-rule bv-and-one ((@n0 Int) (@n1 Int) (x619 (BitVec @n0)) (y620 (BitVec @n1)))
  :premises ((= y620 (bvnot (@bv 0 (@bvsize y620)))))
  :args (x619 y620)
  :conclusion (= (bvand x619 y620) x619)
)
(declare-rule bv-or-one ((@n0 Int) (@n1 Int) (x621 (BitVec @n0)) (y622 (BitVec @n1)))
  :premises ((= y622 (bvnot (@bv 0 (@bvsize y622)))))
  :args (x621 y622)
  :conclusion (= (bvor x621 y622) (bvnot (@bv 0 (@bvsize y622))))
)
(declare-rule bv-xor-duplicate ((@n0 Int) (x623 (BitVec @n0)))
  :args (x623)
  :conclusion (= (bvxor x623 x623) (@bv 0 (@bvsize x623)))
)
(declare-rule bv-xor-ones ((@n0 Int) (@n1 Int) (x624 (BitVec @n0)) (y625 (BitVec @n1)))
  :premises ((= y625 (bvnot (@bv 0 (@bvsize y625)))))
  :args (x624 y625)
  :conclusion (= (bvxor x624 y625) (bvnot x624))
)
(declare-rule bv-xor-zero ((@n0 Int) (x626 (BitVec @n0)) (n627 Int))
  :args (x626 n627)
  :conclusion (= (bvxor x626 (@bv 0 n627)) x626)
)
(declare-rule bv-bitwise-not-and ((@n0 Int) (x628 (BitVec @n0)))
  :args (x628)
  :conclusion (= (bvand x628 (bvnot x628)) (@bv 0 (@bvsize x628)))
)
(declare-rule bv-bitwise-not-or ((@n0 Int) (x629 (BitVec @n0)))
  :args (x629)
  :conclusion (= (bvor x629 (bvnot x629)) (bvnot (@bv 0 (@bvsize x629))))
)
(declare-rule bv-xor-not ((@n0 Int) (@n1 Int) (x630 (BitVec @n0)) (y631 (BitVec @n1)))
  :args (x630 y631)
  :conclusion (= (bvxor (bvnot x630) (bvnot y631)) (bvxor x630 y631))
)
(declare-rule bv-not-idemp ((@n0 Int) (x632 (BitVec @n0)))
  :args (x632)
  :conclusion (= (bvnot (bvnot x632)) x632)
)
(declare-rule bv-ult-zero-1 ((@n0 Int) (x633 (BitVec @n0)) (n634 Int))
  :args (x633 n634)
  :conclusion (= (bvult (@bv 0 n634) x633) (not (= x633 (@bv 0 n634))))
)
(declare-rule bv-ult-zero-2 ((@n0 Int) (x635 (BitVec @n0)) (n636 Int))
  :args (x635 n636)
  :conclusion (= (bvult x635 (@bv 0 n636)) false)
)
(declare-rule bv-ult-self ((@n0 Int) (x637 (BitVec @n0)))
  :args (x637)
  :conclusion (= (bvult x637 x637) false)
)
(declare-rule bv-lt-self ((@n0 Int) (x638 (BitVec @n0)))
  :args (x638)
  :conclusion (= (bvslt x638 x638) false)
)
(declare-rule bv-ule-self ((@n0 Int) (x639 (BitVec @n0)))
  :args (x639)
  :conclusion (= (bvule x639 x639) true)
)
(declare-rule bv-ule-zero ((@n0 Int) (x640 (BitVec @n0)) (n641 Int))
  :args (x640 n641)
  :conclusion (= (bvule x640 (@bv 0 n641)) (= x640 (@bv 0 n641)))
)
(declare-rule bv-zero-ule ((@n0 Int) (x642 (BitVec @n0)) (n643 Int))
  :args (x642 n643)
  :conclusion (= (bvule (@bv 0 n643) x642) true)
)
(declare-rule bv-sle-self ((@n0 Int) (x644 (BitVec @n0)))
  :args (x644)
  :conclusion (= (bvsle x644 x644) true)
)
(declare-rule bv-ule-max ((@n0 Int) (@n1 Int) (x645 (BitVec @n0)) (y646 (BitVec @n1)))
  :premises ((= y646 (bvnot (@bv 0 (@bvsize y646)))))
  :args (x645 y646)
  :conclusion (= (bvule x645 y646) true)
)
(declare-rule bv-not-ult ((@n0 Int) (@n1 Int) (x647 (BitVec @n0)) (y648 (BitVec @n1)))
  :args (x647 y648)
  :conclusion (= (not (bvult x647 y648)) (bvule y648 x647))
)
(declare-rule bv-not-ule ((@n0 Int) (@n1 Int) (x649 (BitVec @n0)) (y650 (BitVec @n1)))
  :args (x649 y650)
  :conclusion (= (not (bvule x649 y650)) (bvult y650 x649))
)
(declare-rule bv-not-sle ((@n0 Int) (@n1 Int) (x651 (BitVec @n0)) (y652 (BitVec @n1)))
  :args (x651 y652)
  :conclusion (= (not (bvsle x651 y652)) (bvslt y652 x651))
)
(declare-rule bv-mult-pow2-1 ((@n0 Int) (@n1 Int) (@n2 Int) (xs653 (BitVec @n0) :list) (ys654 (BitVec @n1) :list) (z655 (BitVec @n2)) (size656 Int) (n657 Int))
  :premises ((= (int.ispow2 n657) true))
  :args (xs653 ys654 z655 size656 n657)
  :conclusion (= (bvmul xs653 z655 (@bv n657 size656) ys654) (eo::define ((_let_1 (int.log2 n657))) (concat (extract (- (- size656 _let_1) 1) 0 ($singleton_elim (bvmul xs653 z655 ys654))) (@bv 0 _let_1))))
)
(declare-rule bv-mult-pow2-2 ((@n0 Int) (@n1 Int) (@n2 Int) (xs658 (BitVec @n0) :list) (ys659 (BitVec @n1) :list) (z660 (BitVec @n2)) (size661 Int) (n662 Int))
  :premises ((= (int.ispow2 (- n662)) true))
  :args (xs658 ys659 z660 size661 n662)
  :conclusion (= (bvmul xs658 z660 (@bv n662 size661) ys659) (eo::define ((_let_1 (int.log2 (- n662)))) (concat (extract (- (- size661 _let_1) 1) 0 (bvneg ($singleton_elim (bvmul xs658 z660 ys659)))) (@bv 0 _let_1))))
)
(declare-rule bv-mult-pow2-2b ((@n0 Int) (z663 (BitVec @n0)) (size664 Int) (n665 Int))
  :premises ((= (int.ispow2 (- n665)) true))
  :args (z663 size664 n665)
  :conclusion (= (bvmul z663 (@bv n665 size664)) (eo::define ((_let_1 (int.log2 (- n665)))) (concat (extract (- (- size664 _let_1) 1) 0 (bvneg z663)) (@bv 0 _let_1))))
)
(declare-rule bv-extract-mult-leading-bit ((@n0 Int) (@n1 Int) (high666 Int) (low667 Int) (x1i668 Int) (x1in669 Int) (x2670 (BitVec @n0)) (y1i671 Int) (y1in672 Int) (y2673 (BitVec @n1)))
  :premises ((= (> (+ x1in669 (@bvsize x2670)) 64) true) (= (<= (- (* 2 (+ x1in669 (@bvsize x2670))) (+ (ite (= x1i668 0) x1in669 (- x1in669 (+ 1 (int.log2 x1i668)))) (ite (= y1i671 0) y1in672 (- y1in672 (+ 1 (int.log2 y1i671)))))) low667) true))
  :args (high666 low667 x1i668 x1in669 x2670 y1i671 y1in672 y2673)
  :conclusion (= (extract high666 low667 (bvmul (concat (@bv x1i668 x1in669) x2670) (concat (@bv y1i671 y1in672) y2673))) (@bv 0 (+ 1 (- high666 low667))))
)
(declare-rule bv-udiv-pow2-not-one ((@n0 Int) (x674 (BitVec @n0)) (v675 Int) (n676 Int))
  :premises ((= (int.ispow2 v675) true) (= (> v675 1) true))
  :args (x674 v675 n676)
  :conclusion (= (bvudiv x674 (@bv v675 n676)) (eo::define ((_let_1 (int.log2 v675))) (concat (@bv 0 _let_1) (extract (- n676 1) _let_1 x674))))
)
(declare-rule bv-udiv-zero ((@n0 Int) (x677 (BitVec @n0)) (n678 Int))
  :args (x677 n678)
  :conclusion (= (bvudiv x677 (@bv 0 n678)) (bvnot (@bv 0 n678)))
)
(declare-rule bv-udiv-one ((@n0 Int) (x679 (BitVec @n0)) (n680 Int))
  :args (x679 n680)
  :conclusion (= (bvudiv x679 (@bv 1 n680)) x679)
)
(declare-rule bv-urem-pow2-not-one ((@n0 Int) (x681 (BitVec @n0)) (v682 Int) (n683 Int))
  :premises ((= (int.ispow2 v682) true) (= (> v682 1) true))
  :args (x681 v682 n683)
  :conclusion (= (bvurem x681 (@bv v682 n683)) (eo::define ((_let_1 (int.log2 v682))) (concat (@bv 0 (- n683 _let_1)) (extract (- _let_1 1) 0 x681))))
)
(declare-rule bv-urem-one ((@n0 Int) (x684 (BitVec @n0)) (n685 Int))
  :args (x684 n685)
  :conclusion (= (bvurem x684 (@bv 1 n685)) (@bv 0 n685))
)
(declare-rule bv-urem-self ((@n0 Int) (x686 (BitVec @n0)))
  :args (x686)
  :conclusion (= (bvurem x686 x686) (@bv 0 (@bvsize x686)))
)
(declare-rule bv-shl-zero ((@n0 Int) (a687 (BitVec @n0)) (n688 Int))
  :args (a687 n688)
  :conclusion (= (bvshl (@bv 0 n688) a687) (@bv 0 n688))
)
(declare-rule bv-lshr-zero ((@n0 Int) (a689 (BitVec @n0)) (n690 Int))
  :args (a689 n690)
  :conclusion (= (bvlshr (@bv 0 n690) a689) (@bv 0 n690))
)
(declare-rule bv-ashr-zero ((@n0 Int) (a691 (BitVec @n0)) (n692 Int))
  :args (a691 n692)
  :conclusion (= (bvashr (@bv 0 n692) a691) (@bv 0 n692))
)
(declare-rule bv-ugt-urem ((@n0 Int) (@n1 Int) (y693 (BitVec @n0)) (x694 (BitVec @n1)))
  :args (y693 x694)
  :conclusion (= (bvugt (bvurem y693 x694) x694) (and (= x694 (@bv 0 (@bvsize x694))) (bvugt y693 (@bv 0 (@bvsize y693)))))
)
(declare-rule bv-ult-one ((@n0 Int) (x695 (BitVec @n0)) (n696 Int))
  :args (x695 n696)
  :conclusion (= (bvult x695 (@bv 1 n696)) (= x695 (@bv 0 n696)))
)
(declare-rule bv-slt-zero ((@n0 Int) (x697 (BitVec @n0)) (n698 Int))
  :args (x697 n698)
  :conclusion (= (bvslt x697 (@bv 0 n698)) (eo::define ((_let_1 (- n698 1))) (= (extract _let_1 _let_1 x697) (@bv 1 1))))
)
(declare-rule bv-merge-sign-extend-1 ((@n0 Int) (x699 (BitVec @n0)) (i700 Int) (j701 Int))
  :args (x699 i700 j701)
  :conclusion (= (sign_extend i700 (sign_extend j701 x699)) (sign_extend (+ i700 j701) x699))
)
(declare-rule bv-merge-sign-extend-2 ((@n0 Int) (x702 (BitVec @n0)) (i703 Int) (j704 Int))
  :premises ((= (> j704 1) true))
  :args (x702 i703 j704)
  :conclusion (= (sign_extend i703 (zero_extend j704 x702)) (zero_extend (+ i703 j704) x702))
)
(declare-rule bv-merge-sign-extend-3 ((@n0 Int) (x705 (BitVec @n0)) (i706 Int) (n0707 Int))
  :premises ((= n0707 0))
  :args (x705 i706 n0707)
  :conclusion (= (sign_extend i706 (zero_extend n0707 x705)) (sign_extend i706 x705))
)
(declare-rule bv-sign-extend-eq-const-1 ((@n0 Int) (x708 (BitVec @n0)) (m709 Int) (c710 Int) (nm711 Int))
  :args (x708 m709 c710 nm711)
  :conclusion (= (= (sign_extend m709 x708) (@bv c710 nm711)) (eo::define ((_let_1 (@bv c710 nm711))) (eo::define ((_let_2 (- (@bvsize x708) 1))) (eo::define ((_let_3 (@bv 0 (+ m709 1)))) (eo::define ((_let_4 (extract (- nm711 1) _let_2 _let_1))) (and (or (= _let_4 _let_3) (= _let_4 (bvnot _let_3))) (= x708 (extract _let_2 0 _let_1))))))))
)
(declare-rule bv-sign-extend-eq-const-2 ((@n0 Int) (x712 (BitVec @n0)) (m713 Int) (c714 Int) (nm715 Int))
  :args (x712 m713 c714 nm715)
  :conclusion (= (= (@bv c714 nm715) (sign_extend m713 x712)) (eo::define ((_let_1 (@bv c714 nm715))) (eo::define ((_let_2 (- (@bvsize x712) 1))) (eo::define ((_let_3 (@bv 0 (+ m713 1)))) (eo::define ((_let_4 (extract (- nm715 1) _let_2 _let_1))) (and (or (= _let_4 _let_3) (= _let_4 (bvnot _let_3))) (= x712 (extract _let_2 0 _let_1))))))))
)
(declare-rule bv-zero-extend-eq-const-1 ((@n0 Int) (x716 (BitVec @n0)) (m717 Int) (c718 Int) (nm719 Int))
  :args (x716 m717 c718 nm719)
  :conclusion (= (= (zero_extend m717 x716) (@bv c718 nm719)) (eo::define ((_let_1 (@bv c718 nm719))) (eo::define ((_let_2 (- (@bvsize x716) 1))) (and (= (extract (- nm719 1) _let_2 _let_1) (@bv 0 m717)) (= x716 (extract _let_2 0 _let_1))))))
)
(declare-rule bv-zero-extend-eq-const-2 ((@n0 Int) (x720 (BitVec @n0)) (m721 Int) (c722 Int) (nm723 Int))
  :args (x720 m721 c722 nm723)
  :conclusion (= (= (@bv c722 nm723) (zero_extend m721 x720)) (eo::define ((_let_1 (@bv c722 nm723))) (eo::define ((_let_2 (- (@bvsize x720) 1))) (and (= (extract (- nm723 1) _let_2 _let_1) (@bv 0 m721)) (= x720 (extract _let_2 0 _let_1))))))
)
(declare-rule bv-zero-extend-ult-const-1 ((@n0 Int) (x724 (BitVec @n0)) (m725 Int) (c726 Int) (nm727 Int))
  :premises ((= (extract (- nm727 1) (@bvsize x724) (@bv c726 nm727)) (@bv 0 m725)))
  :args (x724 m725 c726 nm727)
  :conclusion (= (bvult (zero_extend m725 x724) (@bv c726 nm727)) (bvult x724 (extract (- (@bvsize x724) 1) 0 (@bv c726 nm727))))
)
(declare-rule bv-zero-extend-ult-const-2 ((@n0 Int) (x728 (BitVec @n0)) (m729 Int) (c730 Int) (nm731 Int))
  :premises ((= (extract (- nm731 1) (@bvsize x728) (@bv c730 nm731)) (@bv 0 m729)))
  :args (x728 m729 c730 nm731)
  :conclusion (= (bvult (@bv c730 nm731) (zero_extend m729 x728)) (bvult (extract (- (@bvsize x728) 1) 0 (@bv c730 nm731)) x728))
)
(declare-rule bv-sign-extend-ult-const-1 ((@n0 Int) (x732 (BitVec @n0)) (m733 Int) (c734 Int) (nm735 Int))
  :premises ((eo::define ((_let_1 (@bv (- (@bvsize x732) 1) nm735))) (eo::define ((_let_2 (@bv c734 nm735))) (= (or (bvule _let_2 (bvshl (@bv 1 nm735) _let_1)) (bvuge _let_2 (bvshl (bvnot (@bv 0 nm735)) _let_1))) true))))
  :args (x732 m733 c734 nm735)
  :conclusion (= (bvult (sign_extend m733 x732) (@bv c734 nm735)) (bvult x732 (extract (- (@bvsize x732) 1) 0 (@bv c734 nm735))))
)
(declare-rule bv-sign-extend-ult-const-2 ((@n0 Int) (x736 (BitVec @n0)) (m737 Int) (c738 Int) (nm739 Int))
  :premises ((= (bvult (bvshl (@bv 1 nm739) (@bv (- (@bvsize x736) 1) nm739)) (@bv c738 nm739)) true) (= (bvule (@bv c738 nm739) (bvshl (bvnot (@bv 0 nm739)) (@bv (- (@bvsize x736) 1) nm739))) true))
  :args (x736 m737 c738 nm739)
  :conclusion (= (bvult (sign_extend m737 x736) (@bv c738 nm739)) (eo::define ((_let_1 (- (@bvsize x736) 1))) (= (extract _let_1 _let_1 x736) (@bv 0 1))))
)
(declare-rule bv-sign-extend-ult-const-3 ((@n0 Int) (x740 (BitVec @n0)) (m741 Int) (c742 Int) (nm743 Int))
  :premises ((eo::define ((_let_1 (bvshl (@bv 1 nm743) (@bv (- (@bvsize x740) 1) nm743)))) (eo::define ((_let_2 (@bv c742 nm743))) (= (or (bvult _let_2 _let_1) (bvuge _let_2 (bvnot _let_1))) true))))
  :args (x740 m741 c742 nm743)
  :conclusion (= (bvult (@bv c742 nm743) (sign_extend m741 x740)) (bvult (extract (- (@bvsize x740) 1) 0 (@bv c742 nm743)) x740))
)
(declare-rule bv-sign-extend-ult-const-4 ((@n0 Int) (x744 (BitVec @n0)) (m745 Int) (c746 Int) (nm747 Int))
  :premises ((= (bvule (bvnot (bvshl (bvnot (@bv 0 nm747)) (@bv (- (@bvsize x744) 1) nm747))) (@bv c746 nm747)) true) (= (bvule (@bv c746 nm747) (bvnot (bvshl (@bv 1 nm747) (@bv (- (@bvsize x744) 1) nm747)))) true))
  :args (x744 m745 c746 nm747)
  :conclusion (= (bvult (@bv c746 nm747) (sign_extend m745 x744)) (eo::define ((_let_1 (- (@bvsize x744) 1))) (= (extract _let_1 _let_1 x744) (@bv 1 1))))
)
(declare-rule sets-eq-singleton-emp ((@T0 Type) (@T1 Type) (x812 (Set @T0)) (y813 @T1))
  :premises ((= (set.is_empty x812) true))
  :args (x812 y813)
  :conclusion (= (= x812 (set.singleton y813)) false)
)
(declare-rule sets-member-singleton ((@T0 Type) (@T1 Type) (x814 @T0) (y815 @T1))
  :args (x814 y815)
  :conclusion (= (set.member x814 (set.singleton y815)) (= x814 y815))
)
(declare-rule sets-member-emp ((@T0 Type) (@T1 Type) (x816 @T0) (y817 (Set @T1)))
  :premises ((= (set.is_empty y817) true))
  :args (x816 y817)
  :conclusion (= (set.member x816 y817) false)
)
(declare-rule sets-subset-elim ((@T0 Type) (@T1 Type) (x818 (Set @T0)) (y819 (Set @T1)))
  :args (x818 y819)
  :conclusion (= (set.subset x818 y819) (= (set.union x818 y819) y819))
)
(declare-rule sets-union-comm ((@T0 Type) (@T1 Type) (x820 (Set @T0)) (y821 (Set @T1)))
  :args (x820 y821)
  :conclusion (= (set.union x820 y821) (set.union y821 x820))
)
(declare-rule sets-inter-comm ((@T0 Type) (@T1 Type) (x822 (Set @T0)) (y823 (Set @T1)))
  :args (x822 y823)
  :conclusion (= (set.inter x822 y823) (set.inter y823 x822))
)
(declare-rule sets-inter-emp1 ((@T0 Type) (@T1 Type) (x824 (Set @T0)) (y825 (Set @T1)))
  :premises ((= (set.is_empty x824) true))
  :args (x824 y825)
  :conclusion (= (set.inter x824 y825) x824)
)
(declare-rule sets-inter-emp2 ((@T0 Type) (@T1 Type) (x826 (Set @T0)) (y827 (Set @T1)))
  :premises ((= (set.is_empty y827) true))
  :args (x826 y827)
  :conclusion (= (set.inter x826 y827) y827)
)
(declare-rule sets-minus-emp1 ((@T0 Type) (@T1 Type) (x828 (Set @T0)) (y829 (Set @T1)))
  :premises ((= (set.is_empty x828) true))
  :args (x828 y829)
  :conclusion (= (set.minus x828 y829) x828)
)
(declare-rule sets-minus-emp2 ((@T0 Type) (@T1 Type) (x830 (Set @T0)) (y831 (Set @T1)))
  :premises ((= (set.is_empty y831) true))
  :args (x830 y831)
  :conclusion (= (set.minus x830 y831) x830)
)
(declare-rule sets-union-emp1 ((@T0 Type) (@T1 Type) (x832 (Set @T0)) (y833 (Set @T1)))
  :premises ((= (set.is_empty x832) true))
  :args (x832 y833)
  :conclusion (= (set.union x832 y833) y833)
)
(declare-rule sets-union-emp2 ((@T0 Type) (@T1 Type) (x834 (Set @T0)) (y835 (Set @T1)))
  :premises ((= (set.is_empty y835) true))
  :args (x834 y835)
  :conclusion (= (set.union x834 y835) x834)
)
(declare-rule sets-inter-member ((@T0 Type) (@T1 Type) (@T2 Type) (x836 @T0) (y837 (Set @T1)) (z838 (Set @T2)))
  :args (x836 y837 z838)
  :conclusion (= (set.member x836 (set.inter y837 z838)) (and (set.member x836 y837) (set.member x836 z838)))
)
(declare-rule sets-minus-member ((@T0 Type) (@T1 Type) (@T2 Type) (x839 @T0) (y840 (Set @T1)) (z841 (Set @T2)))
  :args (x839 y840 z841)
  :conclusion (= (set.member x839 (set.minus y840 z841)) (and (set.member x839 y840) (not (set.member x839 z841))))
)
(declare-rule sets-union-member ((@T0 Type) (@T1 Type) (@T2 Type) (x842 @T0) (y843 (Set @T1)) (z844 (Set @T2)))
  :args (x842 y843 z844)
  :conclusion (= (set.member x842 (set.union y843 z844)) (or (set.member x842 y843) (set.member x842 z844)))
)
(declare-rule sets-choose-singleton ((@T0 Type) (x845 @T0))
  :args (x845)
  :conclusion (= (set.choose (set.singleton x845)) x845)
)
(declare-rule sets-card-singleton ((@T0 Type) (x846 @T0))
  :args (x846)
  :conclusion (= (set.card (set.singleton x846)) 1)
)
(declare-rule sets-card-union ((@T0 Type) (@T1 Type) (s847 (Set @T0)) (t848 (Set @T1)))
  :args (s847 t848)
  :conclusion (= (set.card (set.union s847 t848)) (- (+ (set.card s847) (set.card t848)) (set.card (set.inter s847 t848))))
)
(declare-rule sets-card-minus ((@T0 Type) (@T1 Type) (s849 (Set @T0)) (t850 (Set @T1)))
  :args (s849 t850)
  :conclusion (= (set.card (set.minus s849 t850)) (- (set.card s849) (set.card (set.inter s849 t850))))
)
(declare-rule sets-card-emp ((@T0 Type) (x851 (Set @T0)))
  :premises ((= (set.is_empty x851) true))
  :args (x851)
  :conclusion (= (set.card x851) 0)
)
(declare-rule str-eq-ctn-false ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x1854 (Seq @T0) :list) (x855 (Seq @T1)) (x2856 (Seq @T2) :list) (y857 (Seq @T3)))
  :premises ((= (seq.contains y857 x855) false))
  :args (x1854 x855 x2856 y857)
  :conclusion (= (= ($singleton_elim (seq.++ x1854 x855 x2856)) y857) false)
)
(declare-rule str-eq-ctn-full-false1 ((@T0 Type) (@T1 Type) (x858 (Seq @T0)) (y859 (Seq @T1)))
  :premises ((= (seq.contains y859 x858) false))
  :args (x858 y859)
  :conclusion (= (= x858 y859) false)
)
(declare-rule str-eq-ctn-full-false2 ((@T0 Type) (@T1 Type) (x860 (Seq @T0)) (y861 (Seq @T1)))
  :premises ((= (seq.contains x860 y861) false))
  :args (x860 y861)
  :conclusion (= (= x860 y861) false)
)
(declare-rule str-concat-flatten ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (xs862 (Seq @T0) :list) (s863 (Seq @T1)) (ys864 (Seq @T2) :list) (zs865 (Seq @T3) :list))
  :args (xs862 s863 ys864 zs865)
  :conclusion (= ($singleton_elim (seq.++ xs862 ($singleton_elim (seq.++ s863 ys864)) zs865)) ($singleton_elim (seq.++ xs862 s863 ys864 zs865)))
)
(declare-rule str-concat-flatten-eq ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x866 (Seq @T0)) (x1867 (Seq @T1) :list) (x2868 (Seq @T2) :list) (y869 (Seq @T3)))
  :args (x866 x1867 x2868 y869)
  :conclusion (= (= ($singleton_elim (seq.++ ($singleton_elim (seq.++ x866 x1867)) x2868)) y869) (= y869 ($singleton_elim (seq.++ x866 x1867 x2868))))
)
(declare-rule str-concat-flatten-eq-rev ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x870 (Seq @T0)) (x1871 (Seq @T1) :list) (x2872 (Seq @T2) :list) (y873 (Seq @T3)))
  :args (x870 x1871 x2872 y873)
  :conclusion (= (= ($singleton_elim (seq.++ x2872 ($singleton_elim (seq.++ x1871 x870)))) y873) (= y873 ($singleton_elim (seq.++ x2872 x1871 x870))))
)
(declare-rule str-substr-empty-str ((n874 Int) (m875 Int))
  :args (n874 m875)
  :conclusion (= (str.substr "" n874 m875) "")
)
(declare-rule str-substr-empty-range ((x876 String) (n877 Int) (m878 Int))
  :premises ((= (>= 0 m878) true))
  :args (x876 n877 m878)
  :conclusion (= (str.substr x876 n877 m878) "")
)
(declare-rule str-substr-empty-start ((x879 String) (n880 Int) (m881 Int))
  :premises ((= (>= n880 (str.len x879)) true))
  :args (x879 n880 m881)
  :conclusion (= (str.substr x879 n880 m881) "")
)
(declare-rule str-substr-empty-start-neg ((x882 String) (n883 Int) (m884 Int))
  :premises ((= (< n883 0) true))
  :args (x882 n883 m884)
  :conclusion (= (str.substr x882 n883 m884) "")
)
(declare-rule str-substr-eq-empty ((s885 String) (n886 Int) (m887 Int))
  :premises ((= n886 0) (= (> m887 n886) true))
  :args (s885 n886 m887)
  :conclusion (= (= (str.substr s885 n886 m887) "") (= s885 ""))
)
(declare-rule str-len-replace-inv ((@T0 Type) (@T1 Type) (@T2 Type) (t888 (Seq @T0)) (s889 (Seq @T1)) (r890 (Seq @T2)))
  :premises ((= (seq.len s889) (seq.len r890)))
  :args (t888 s889 r890)
  :conclusion (= (seq.len (seq.replace t888 s889 r890)) (seq.len t888))
)
(declare-rule str-len-update-inv ((@T0 Type) (@T1 Type) (t891 (Seq @T0)) (n892 Int) (r893 (Seq @T1)))
  :args (t891 n892 r893)
  :conclusion (= (seq.len (seq.update t891 n892 r893)) (seq.len t891))
)
(declare-rule str-len-substr-in-range ((@T0 Type) (s894 (Seq @T0)) (n895 Int) (m896 Int))
  :premises ((= (>= n895 0) true) (= (>= m896 0) true) (= (>= (seq.len s894) (+ n895 m896)) true))
  :args (s894 n895 m896)
  :conclusion (= (seq.len (seq.extract s894 n895 m896)) m896)
)
(declare-rule str-len-substr-ub1 ((@T0 Type) (s897 (Seq @T0)) (n898 Int) (m899 Int) (k900 Int))
  :premises ((= (>= k900 0) true) (= (>= k900 m899) true))
  :args (s897 n898 m899 k900)
  :conclusion (= (>= k900 (seq.len (seq.extract s897 n898 m899))) true)
)
(declare-rule str-len-substr-ub2 ((@T0 Type) (s901 (Seq @T0)) (n902 Int) (m903 Int) (k904 Int))
  :premises ((= (>= k904 0) true) (= (>= k904 (- (seq.len s901) n902)) true))
  :args (s901 n902 m903 k904)
  :conclusion (= (>= k904 (seq.len (seq.extract s901 n902 m903))) true)
)
(declare-rule str-concat-clash ((s1905 String) (s2906 String :list) (t1907 String) (t2908 String :list))
  :premises ((= (= s1905 t1907) false) (= (str.len s1905) (str.len t1907)))
  :args (s1905 s2906 t1907 t2908)
  :conclusion (= (= ($singleton_elim (str.++ s1905 s2906)) ($singleton_elim (str.++ t1907 t2908))) false)
)
(declare-rule str-concat-clash-rev ((s1909 String) (s2910 String :list) (t1911 String) (t2912 String :list))
  :premises ((= (= s1909 t1911) false) (= (str.len s1909) (str.len t1911)))
  :args (s1909 s2910 t1911 t2912)
  :conclusion (= (= ($singleton_elim (str.++ s2910 s1909)) ($singleton_elim (str.++ t2912 t1911))) false)
)
(declare-rule str-concat-clash2 ((s1913 String) (t1914 String) (t2915 String :list))
  :premises ((= (= s1913 t1914) false) (= (str.len s1913) (str.len t1914)))
  :args (s1913 t1914 t2915)
  :conclusion (= (= s1913 ($singleton_elim (str.++ t1914 t2915))) false)
)
(declare-rule str-concat-clash2-rev ((s1916 String) (t1917 String) (t2918 String :list))
  :premises ((= (= s1916 t1917) false) (= (str.len s1916) (str.len t1917)))
  :args (s1916 t1917 t2918)
  :conclusion (= (= s1916 ($singleton_elim (str.++ t2918 t1917))) false)
)
(declare-rule str-concat-unify ((s1919 String) (s2920 String) (s3921 String :list) (t2922 String) (t3923 String :list))
  :args (s1919 s2920 s3921 t2922 t3923)
  :conclusion (= (= (str.++ s1919 s2920 s3921) (str.++ s1919 t2922 t3923)) (= ($singleton_elim (str.++ s2920 s3921)) ($singleton_elim (str.++ t2922 t3923))))
)
(declare-rule str-concat-unify-rev ((s1924 String) (s2925 String) (s3926 String :list) (t2927 String) (t3928 String :list))
  :args (s1924 s2925 s3926 t2927 t3928)
  :conclusion (= (= (str.++ s2925 s3926 s1924) (str.++ t2927 t3928 s1924)) (= ($singleton_elim (str.++ s2925 s3926)) ($singleton_elim (str.++ t2927 t3928))))
)
(declare-rule str-concat-unify-base ((s929 String) (t1930 String) (t2931 String :list))
  :args (s929 t1930 t2931)
  :conclusion (= (= s929 (str.++ s929 t1930 t2931)) (= "" ($singleton_elim (str.++ t1930 t2931))))
)
(declare-rule str-concat-unify-base-rev ((s932 String) (t1933 String) (t2934 String :list))
  :args (s932 t1933 t2934)
  :conclusion (= (= s932 (str.++ t1933 t2934 s932)) (= "" ($singleton_elim (str.++ t1933 t2934))))
)
(declare-rule str-concat-clash-char ((s1935 String) (s2936 String :list) (s3937 String :list) (t1938 String) (t2939 String :list) (t3940 String :list))
  :premises ((= (= s1935 t1938) false) (= (str.len s1935) (str.len t1938)))
  :args (s1935 s2936 s3937 t1938 t2939 t3940)
  :conclusion (= (= ($singleton_elim (str.++ ($singleton_elim (str.++ s1935 s2936)) s3937)) ($singleton_elim (str.++ ($singleton_elim (str.++ t1938 t2939)) t3940))) false)
)
(declare-rule str-concat-clash-char-rev ((s1941 String) (s2942 String :list) (s3943 String :list) (t1944 String) (t2945 String :list) (t3946 String :list))
  :premises ((= (= s1941 t1944) false) (= (str.len s1941) (str.len t1944)))
  :args (s1941 s2942 s3943 t1944 t2945 t3946)
  :conclusion (= (= ($singleton_elim (str.++ s3943 ($singleton_elim (str.++ s2942 s1941)))) ($singleton_elim (str.++ t3946 ($singleton_elim (str.++ t2945 t1944))))) false)
)
(declare-rule str-prefixof-elim ((@T0 Type) (@T1 Type) (s947 (Seq @T0)) (t948 (Seq @T1)))
  :args (s947 t948)
  :conclusion (= (seq.prefixof s947 t948) (= s947 (seq.extract t948 0 (seq.len s947))))
)
(declare-rule str-suffixof-elim ((@T0 Type) (@T1 Type) (s949 (Seq @T0)) (t950 (Seq @T1)))
  :args (s949 t950)
  :conclusion (= (seq.suffixof s949 t950) (eo::define ((_let_1 (seq.len s949))) (= s949 (seq.extract t950 (- (seq.len t950) _let_1) _let_1))))
)
(declare-rule str-prefixof-one ((@T0 Type) (@T1 Type) (s951 (Seq @T0)) (t952 (Seq @T1)))
  :premises ((= (seq.len t952) 1))
  :args (s951 t952)
  :conclusion (= (seq.prefixof s951 t952) (seq.contains t952 s951))
)
(declare-rule str-suffixof-one ((@T0 Type) (@T1 Type) (s953 (Seq @T0)) (t954 (Seq @T1)))
  :premises ((= (seq.len t954) 1))
  :args (s953 t954)
  :conclusion (= (seq.suffixof s953 t954) (seq.contains t954 s953))
)
(declare-rule str-substr-combine1 ((s955 String) (n1956 Int) (m1957 Int) (n2958 Int) (m2959 Int))
  :premises ((= (>= n1956 0) true) (= (>= n2958 0) true) (= (>= (- m2959 (- m1957 n2958)) 0) true))
  :args (s955 n1956 m1957 n2958 m2959)
  :conclusion (= (str.substr (str.substr s955 n1956 m1957) n2958 m2959) (str.substr s955 (+ n1956 n2958) (- m1957 n2958)))
)
(declare-rule str-substr-combine2 ((s960 String) (n1961 Int) (m1962 Int) (n2963 Int) (m2964 Int))
  :premises ((= (>= n1961 0) true) (= (>= n2963 0) true) (= (>= (- (- m1962 n2963) m2964) 0) true))
  :args (s960 n1961 m1962 n2963 m2964)
  :conclusion (= (str.substr (str.substr s960 n1961 m1962) n2963 m2964) (str.substr s960 (+ n1961 n2963) m2964))
)
(declare-rule str-substr-combine3 ((s965 String) (n1966 Int) (m1967 Int) (n2968 Int) (m2969 Int))
  :premises ((= (>= n1966 0) true) (= (>= n2968 0) true) (= (>= (str.len (str.substr s965 n1966 m1967)) (+ n2968 m2969)) true))
  :args (s965 n1966 m1967 n2968 m2969)
  :conclusion (= (str.substr (str.substr s965 n1966 m1967) n2968 m2969) (str.substr s965 (+ n1966 n2968) m2969))
)
(declare-rule str-substr-combine4 ((s970 String) (n1971 Int) (m1972 Int) (n2973 Int) (m2974 Int))
  :premises ((= (>= n1971 0) true) (= (>= n2973 0) true) (= (>= (+ n2973 m2974) (str.len (str.substr s970 n1971 m1972))) true))
  :args (s970 n1971 m1972 n2973 m2974)
  :conclusion (= (str.substr (str.substr s970 n1971 m1972) n2973 m2974) (str.substr s970 (+ n1971 n2973) (- m1972 n2973)))
)
(declare-rule str-substr-concat1 ((@T0 Type) (@T1 Type) (s1975 (Seq @T0)) (s2976 (Seq @T1) :list) (n977 Int) (m978 Int))
  :premises ((= (>= n977 0) true) (= (>= (seq.len s1975) (+ n977 m978)) true))
  :args (s1975 s2976 n977 m978)
  :conclusion (= (seq.extract ($singleton_elim (seq.++ s1975 s2976)) n977 m978) (seq.extract s1975 n977 m978))
)
(declare-rule str-substr-concat2 ((@T0 Type) (@T1 Type) (@T2 Type) (s1979 (Seq @T0)) (s2980 (Seq @T1)) (s3981 (Seq @T2) :list) (n982 Int) (m983 Int))
  :premises ((= (>= n982 (seq.len s1979)) true))
  :args (s1979 s2980 s3981 n982 m983)
  :conclusion (= (seq.extract (seq.++ s1979 s2980 s3981) n982 m983) (seq.extract ($singleton_elim (seq.++ s2980 s3981)) (- n982 (seq.len s1979)) m983))
)
(declare-rule str-substr-full ((@T0 Type) (s984 (Seq @T0)) (n985 Int))
  :premises ((= (>= n985 (seq.len s984)) true))
  :args (s984 n985)
  :conclusion (= (seq.extract s984 0 n985) s984)
)
(declare-rule str-substr-full-eq ((@T0 Type) (s986 (Seq @T0)) (n987 Int))
  :premises ((= (seq.len s986) n987))
  :args (s986 n987)
  :conclusion (= (seq.extract s986 0 n987) s986)
)
(declare-rule str-contains-refl ((@T0 Type) (x988 (Seq @T0)))
  :args (x988)
  :conclusion (= (seq.contains x988 x988) true)
)
(declare-rule str-contains-concat-find ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (xs989 (Seq @T0) :list) (z990 (Seq @T1)) (y991 (Seq @T2)) (zs992 (Seq @T3) :list))
  :premises ((= (seq.contains z990 y991) true))
  :args (xs989 z990 y991 zs992)
  :conclusion (= (seq.contains ($singleton_elim (seq.++ xs989 z990 zs992)) y991) true)
)
(declare-rule str-contains-split-char ((@T0 Type) (@T1 Type) (@T2 Type) (@T3 Type) (x993 (Seq @T0)) (y994 (Seq @T1)) (z995 (Seq @T2) :list) (w996 (Seq @T3)))
  :premises ((= (seq.len w996) 1))
  :args (x993 y994 z995 w996)
  :conclusion (= (seq.contains (seq.++ x993 y994 z995) w996) (or (seq.contains x993 w996) (seq.contains ($singleton_elim (seq.++ y994 z995)) w996)))
)
(declare-rule str-contains-lt-len ((x997 String) (y998 String))
  :premises ((= (> (str.len y998) (str.len x997)) true))
  :args (x997 y998)
  :conclusion (= (str.contains x997 y998) false)
)
(declare-rule str-contains-leq-len-eq ((x999 String) (y1000 String))
  :premises ((= (>= (str.len y1000) (str.len x999)) true))
  :args (x999 y1000)
  :conclusion (= (str.contains x999 y1000) (= x999 y1000))
)
(declare-rule str-contains-emp ((x1001 String) (y1002 String))
  :premises ((= (str.len y1002) 0))
  :args (x1001 y1002)
  :conclusion (= (str.contains x1001 y1002) true)
)
(declare-rule str-contains-is-emp ((x1003 String) (y1004 String))
  :premises ((= (str.len x1003) 0))
  :args (x1003 y1004)
  :conclusion (= (str.contains x1003 y1004) (= x1003 y1004))
)
(declare-rule str-concat-emp ((xs1005 String :list) (ys1006 String :list))
  :args (xs1005 ys1006)
  :conclusion (= ($singleton_elim (str.++ xs1005 "" ys1006)) ($singleton_elim (str.++ xs1005 ys1006)))
)
(declare-rule str-at-elim ((@T0 Type) (x1007 (Seq @T0)) (n1008 Int))
  :args (x1007 n1008)
  :conclusion (= (seq.at x1007 n1008) (seq.extract x1007 n1008 1))
)
(declare-rule str-replace-self ((@T0 Type) (@T1 Type) (t1009 (Seq @T0)) (s1010 (Seq @T1)))
  :args (t1009 s1010)
  :conclusion (= (seq.replace t1009 t1009 s1010) s1010)
)
(declare-rule str-replace-no-contains ((@T0 Type) (@T1 Type) (@T2 Type) (t1011 (Seq @T0)) (s1012 (Seq @T1)) (r1013 (Seq @T2)))
  :premises ((= (seq.contains t1011 s1012) false))
  :args (t1011 s1012 r1013)
  :conclusion (= (seq.replace t1011 s1012 r1013) t1011)
)
(declare-rule str-replace-empty ((@T0 Type) (@T1 Type) (t1014 (Seq @T0)) (s1015 (Seq @T1)))
  :args (t1014 s1015)
  :conclusion (= (seq.replace t1014 "" s1015) (seq.++ s1015 t1014))
)
(declare-rule str-len-concat-rec ((@T0 Type) (@T1 Type) (@T2 Type) (s11016 (Seq @T0)) (s21017 (Seq @T1)) (s31018 (Seq @T2) :list))
  :args (s11016 s21017 s31018)
  :conclusion (= (seq.len (seq.++ s11016 s21017 s31018)) (+ (seq.len s11016) (seq.len ($singleton_elim (seq.++ s21017 s31018)))))
)
(declare-rule str-indexof-self ((t1019 String) (n1020 Int))
  :args (t1019 n1020)
  :conclusion (= (str.indexof t1019 t1019 n1020) (str.indexof "" "" n1020))
)
(declare-rule str-indexof-no-contains ((t1021 String) (s1022 String) (n1023 Int))
  :premises ((= (str.contains (str.substr t1021 n1023 (str.len t1021)) s1022) false))
  :args (t1021 s1022 n1023)
  :conclusion (= (str.indexof t1021 s1022 n1023) (- 1))
)
(declare-rule str-to-lower-concat ((s11024 String) (s21025 String) (s31026 String :list))
  :args (s11024 s21025 s31026)
  :conclusion (= (str.to_lower (str.++ s11024 s21025 s31026)) (str.++ (str.to_lower s11024) (str.to_lower ($singleton_elim (str.++ s21025 s31026)))))
)
(declare-rule str-to-upper-concat ((s11027 String) (s21028 String) (s31029 String :list))
  :args (s11027 s21028 s31029)
  :conclusion (= (str.to_upper (str.++ s11027 s21028 s31029)) (str.++ (str.to_upper s11027) (str.to_upper ($singleton_elim (str.++ s21028 s31029)))))
)
(declare-rule str-to-lower-upper ((s1030 String))
  :args (s1030)
  :conclusion (= (str.to_lower (str.to_upper s1030)) (str.to_lower s1030))
)
(declare-rule str-to-upper-lower ((s1031 String))
  :args (s1031)
  :conclusion (= (str.to_upper (str.to_lower s1031)) (str.to_upper s1031))
)
(declare-rule re-all-elim ()
  :args ()
  :conclusion (= re.all (re.* re.allchar))
)
(declare-rule re-opt-elim ((x1032 RegLan))
  :args (x1032)
  :conclusion (= (re.opt x1032) (re.union (str.to_re "") x1032))
)
(declare-rule re-diff-elim ((x1033 RegLan) (y1034 RegLan))
  :args (x1033 y1034)
  :conclusion (= (re.diff x1033 y1034) (re.inter x1033 (re.comp y1034)))
)
(declare-rule re-concat-emp ((xs1035 RegLan :list) (ys1036 RegLan :list))
  :args (xs1035 ys1036)
  :conclusion (= ($singleton_elim (re.++ xs1035 (str.to_re "") ys1036)) ($singleton_elim (re.++ xs1035 ys1036)))
)
(declare-rule re-concat-none ((xs1037 RegLan :list) (ys1038 RegLan :list))
  :args (xs1037 ys1038)
  :conclusion (= ($singleton_elim (re.++ xs1037 re.none ys1038)) re.none)
)
(declare-rule re-concat-flatten ((xs1039 RegLan :list) (s1040 RegLan) (ys1041 RegLan :list) (zs1042 RegLan :list))
  :args (xs1039 s1040 ys1041 zs1042)
  :conclusion (= ($singleton_elim (re.++ xs1039 ($singleton_elim (re.++ s1040 ys1041)) zs1042)) ($singleton_elim (re.++ xs1039 s1040 ys1041 zs1042)))
)
(declare-rule re-concat-star-swap ((xs1043 RegLan :list) (r1044 RegLan) (ys1045 RegLan :list))
  :args (xs1043 r1044 ys1045)
  :conclusion (= (re.++ xs1043 (re.* r1044) r1044 ys1045) (re.++ xs1043 r1044 (re.* r1044) ys1045))
)
(declare-rule re-concat-merge ((xs1046 RegLan :list) (s1047 String) (t1048 String) (ys1049 RegLan :list))
  :args (xs1046 s1047 t1048 ys1049)
  :conclusion (= (re.++ xs1046 (str.to_re s1047) (str.to_re t1048) ys1049) ($singleton_elim (re.++ xs1046 (str.to_re (str.++ s1047 t1048)) ys1049)))
)
(declare-rule re-union-all ((xs1050 RegLan :list) (ys1051 RegLan :list))
  :args (xs1050 ys1051)
  :conclusion (= ($singleton_elim (re.union xs1050 (re.* re.allchar) ys1051)) (re.* re.allchar))
)
(declare-rule re-union-none ((xs1052 RegLan :list) (ys1053 RegLan :list))
  :args (xs1052 ys1053)
  :conclusion (= ($singleton_elim (re.union xs1052 re.none ys1053)) ($singleton_elim (re.union xs1052 ys1053)))
)
(declare-rule re-union-flatten ((xs1054 RegLan :list) (b1055 RegLan) (ys1056 RegLan :list) (zs1057 RegLan :list))
  :args (xs1054 b1055 ys1056 zs1057)
  :conclusion (= ($singleton_elim (re.union xs1054 ($singleton_elim (re.union b1055 ys1056)) zs1057)) ($singleton_elim (re.union xs1054 b1055 ys1056 zs1057)))
)
(declare-rule re-union-dup ((xs1058 RegLan :list) (b1059 RegLan) (ys1060 RegLan :list) (zs1061 RegLan :list))
  :args (xs1058 b1059 ys1060 zs1061)
  :conclusion (= (re.union xs1058 b1059 ys1060 b1059 zs1061) ($singleton_elim (re.union xs1058 b1059 ys1060 zs1061)))
)
(declare-rule re-inter-all ((xs1062 RegLan :list) (ys1063 RegLan :list))
  :args (xs1062 ys1063)
  :conclusion (= ($singleton_elim (re.inter xs1062 (re.* re.allchar) ys1063)) ($singleton_elim (re.inter xs1062 ys1063)))
)
(declare-rule re-inter-none ((xs1064 RegLan :list) (ys1065 RegLan :list))
  :args (xs1064 ys1065)
  :conclusion (= ($singleton_elim (re.inter xs1064 re.none ys1065)) re.none)
)
(declare-rule re-inter-flatten ((xs1066 RegLan :list) (b1067 RegLan) (ys1068 RegLan :list) (zs1069 RegLan :list))
  :args (xs1066 b1067 ys1068 zs1069)
  :conclusion (= ($singleton_elim (re.inter xs1066 ($singleton_elim (re.inter b1067 ys1068)) zs1069)) ($singleton_elim (re.inter xs1066 b1067 ys1068 zs1069)))
)
(declare-rule re-inter-dup ((xs1070 RegLan :list) (b1071 RegLan) (ys1072 RegLan :list) (zs1073 RegLan :list))
  :args (xs1070 b1071 ys1072 zs1073)
  :conclusion (= (re.inter xs1070 b1071 ys1072 b1071 zs1073) ($singleton_elim (re.inter xs1070 b1071 ys1072 zs1073)))
)
(declare-rule re-loop-neg ((n1074 Int) (m1075 Int) (r1076 RegLan))
  :premises ((= (> n1074 m1075) true))
  :args (n1074 m1075 r1076)
  :conclusion (= (re.loop n1074 m1075 r1076) re.none)
)
(declare-rule re-inter-cstring ((xs1077 RegLan :list) (ys1078 RegLan :list) (s1079 String))
  :premises ((= (str.in_re s1079 ($singleton_elim (re.inter xs1077 ys1078))) true))
  :args (xs1077 ys1078 s1079)
  :conclusion (= ($singleton_elim (re.inter xs1077 (str.to_re s1079) ys1078)) (str.to_re s1079))
)
(declare-rule re-inter-cstring-neg ((xs1080 RegLan :list) (ys1081 RegLan :list) (s1082 String))
  :premises ((= (str.in_re s1082 ($singleton_elim (re.inter xs1080 ys1081))) false))
  :args (xs1080 ys1081 s1082)
  :conclusion (= ($singleton_elim (re.inter xs1080 (str.to_re s1082) ys1081)) re.none)
)
(declare-rule str-substr-len-include ((@T0 Type) (@T1 Type) (s11083 (Seq @T0)) (s21084 (Seq @T1) :list) (n1085 Int))
  :premises ((= n1085 (seq.len s11083)))
  :args (s11083 s21084 n1085)
  :conclusion (= (seq.extract ($singleton_elim (seq.++ s11083 s21084)) 0 n1085) s11083)
)
(declare-rule str-substr-len-include-pre ((@T0 Type) (@T1 Type) (@T2 Type) (s11086 (Seq @T0)) (s21087 (Seq @T1)) (s31088 (Seq @T2) :list) (n1089 Int))
  :premises ((= (>= n1089 (seq.len s11086)) true))
  :args (s11086 s21087 s31088 n1089)
  :conclusion (= (seq.extract (seq.++ s11086 s21087 s31088) 0 n1089) (seq.++ s11086 (seq.extract ($singleton_elim (seq.++ s21087 s31088)) 0 (- n1089 (seq.len s11086)))))
)
(declare-rule str-substr-len-skip ((@T0 Type) (@T1 Type) (@T2 Type) (s11090 (Seq @T0)) (s21091 (Seq @T1)) (s31092 (Seq @T2) :list) (n1093 Int) (m1094 Int))
  :premises ((= (>= n1093 (seq.len s11090)) true))
  :args (s11090 s21091 s31092 n1093 m1094)
  :conclusion (= (seq.extract (seq.++ s11090 s21091 s31092) n1093 m1094) (seq.extract ($singleton_elim (seq.++ s21091 s31092)) (- n1093 (seq.len s11090)) m1094))
)
(declare-rule seq-rev-concat ((@T0 Type) (@T1 Type) (@T2 Type) (x1095 (Seq @T0)) (y1096 (Seq @T1) :list) (z1097 (Seq @T2)))
  :args (x1095 y1096 z1097)
  :conclusion (= (seq.rev (seq.++ x1095 y1096 z1097)) (seq.++ (seq.rev z1097) (seq.rev ($singleton_elim (seq.++ x1095 y1096)))))
)
(declare-rule seq-len-unit ((@T0 Type) (x1098 @T0))
  :args (x1098)
  :conclusion (= (seq.len (seq.unit x1098)) 1)
)
(declare-rule seq-nth-unit ((@T0 Type) (x1099 @T0))
  :args (x1099)
  :conclusion (= (seq.nth (seq.unit x1099) 0) x1099)
)
(declare-rule seq-rev-unit ((@T0 Type) (x1100 @T0))
  :args (x1100)
  :conclusion (= (seq.rev (seq.unit x1100)) (seq.unit x1100))
)
(declare-rule re-in-empty ((t1132 String))
  :args (t1132)
  :conclusion (= (str.in_re t1132 re.none) false)
)
(declare-rule re-in-sigma ((t1133 String))
  :args (t1133)
  :conclusion (= (str.in_re t1133 re.allchar) (= (str.len t1133) 1))
)
(declare-rule re-in-sigma-star ((t1134 String))
  :args (t1134)
  :conclusion (= (str.in_re t1134 (re.* re.allchar)) true)
)
(declare-rule re-in-cstring ((t1135 String) (s1136 String))
  :args (t1135 s1136)
  :conclusion (= (str.in_re t1135 (str.to_re s1136)) (= t1135 s1136))
)
(declare-rule re-in-comp ((t1137 String) (r1138 RegLan))
  :args (t1137 r1138)
  :conclusion (= (str.in_re t1137 (re.comp r1138)) (not (str.in_re t1137 r1138)))
)
(declare-rule str-in-re-union-elim ((s1139 String) (r11140 RegLan) (r21141 RegLan) (rs1142 RegLan :list))
  :args (s1139 r11140 r21141 rs1142)
  :conclusion (= (str.in_re s1139 (re.union r11140 r21141 rs1142)) (or (str.in_re s1139 r11140) (str.in_re s1139 ($singleton_elim (re.union r21141 rs1142)))))
)
(declare-rule str-in-re-inter-elim ((s1143 String) (r11144 RegLan) (r21145 RegLan) (rs1146 RegLan :list))
  :args (s1143 r11144 r21145 rs1146)
  :conclusion (= (str.in_re s1143 (re.inter r11144 r21145 rs1146)) (and (str.in_re s1143 r11144) (str.in_re s1143 ($singleton_elim (re.inter r21145 rs1146)))))
)
(declare-rule str-in-re-range-elim ((s1147 String) (c11148 String) (c21149 String))
  :premises ((= (str.len c11148) 1) (= (str.len c21149) 1))
  :args (s1147 c11148 c21149)
  :conclusion (= (str.in_re s1147 (re.range c11148 c21149)) (eo::define ((_let_1 (str.to_code s1147))) (and (<= (str.to_code c11148) _let_1) (<= _let_1 (str.to_code c21149)))))
)
(declare-rule str-in-re-contains ((t1150 String) (s1151 String))
  :args (t1150 s1151)
  :conclusion (= (eo::define ((_let_1 (re.* re.allchar))) (str.in_re t1150 (re.++ _let_1 (str.to_re s1151) _let_1))) (str.contains t1150 s1151))
)
(declare-rule str-in-re-strip-prefix ((s1152 String) (s11153 String) (s21154 String :list) (sr11155 String) (sr21156 String :list) (r1157 RegLan :list))
  :args (s1152 s11153 s21154 sr11155 sr21156 r1157)
  :conclusion (= (str.in_re (str.++ s1152 s11153 s21154) ($singleton_elim (re.++ (str.to_re (str.++ s1152 sr11155 sr21156)) r1157))) (str.in_re ($singleton_elim (str.++ s11153 s21154)) ($singleton_elim (re.++ (str.to_re ($singleton_elim (str.++ sr11155 sr21156))) r1157))))
)
(declare-rule str-in-re-strip-prefix-neg ((s1158 String) (t1159 String) (s11160 String) (s21161 String :list) (sr11162 String) (sr21163 String :list) (r1164 RegLan :list))
  :premises ((= (str.len s1158) (str.len t1159)) (= (= s1158 t1159) false))
  :args (s1158 t1159 s11160 s21161 sr11162 sr21163 r1164)
  :conclusion (= (str.in_re (str.++ s1158 s11160 s21161) ($singleton_elim (re.++ (str.to_re (str.++ t1159 sr11162 sr21163)) r1164))) false)
)
(declare-rule str-in-re-strip-prefix-sr-single ((s1165 String) (s11166 String) (s21167 String :list) (r11168 RegLan) (r21169 RegLan :list))
  :args (s1165 s11166 s21167 r11168 r21169)
  :conclusion (= (str.in_re (str.++ s1165 s11166 s21167) (re.++ (str.to_re s1165) r11168 r21169)) (str.in_re ($singleton_elim (str.++ s11166 s21167)) ($singleton_elim (re.++ r11168 r21169))))
)
(declare-rule str-in-re-strip-prefix-sr-single-neg ((s1170 String) (t1171 String) (s11172 String) (s21173 String :list) (r11174 RegLan) (r21175 RegLan :list))
  :premises ((= (str.len s1170) (str.len t1171)) (= (= s1170 t1171) false))
  :args (s1170 t1171 s11172 s21173 r11174 r21175)
  :conclusion (= (str.in_re (str.++ s1170 s11172 s21173) (re.++ (str.to_re t1171) r11174 r21175)) false)
)
(declare-rule str-in-re-strip-prefix-srs-single ((s1176 String) (r11177 RegLan) (r21178 RegLan :list))
  :args (s1176 r11177 r21178)
  :conclusion (= (str.in_re s1176 (re.++ (str.to_re s1176) r11177 r21178)) (str.in_re "" ($singleton_elim (re.++ r11177 r21178))))
)
(declare-rule str-in-re-strip-prefix-srs-single-neg ((s1179 String) (t1180 String) (r11181 RegLan) (r21182 RegLan :list))
  :premises ((= (str.len s1179) (str.len t1180)) (= (= s1179 t1180) false))
  :args (s1179 t1180 r11181 r21182)
  :conclusion (= (str.in_re s1179 (re.++ (str.to_re t1180) r11181 r21182)) false)
)
(declare-rule str-in-re-strip-prefix-s-single ((s1183 String) (sr11184 String) (sr21185 String :list) (r1186 RegLan :list))
  :args (s1183 sr11184 sr21185 r1186)
  :conclusion (= (str.in_re s1183 ($singleton_elim (re.++ (str.to_re (str.++ s1183 sr11184 sr21185)) r1186))) (str.in_re "" ($singleton_elim (re.++ (str.to_re ($singleton_elim (str.++ sr11184 sr21185))) r1186))))
)
(declare-rule str-in-re-strip-prefix-s-single-neg ((s1187 String) (t1188 String) (sr11189 String) (sr21190 String :list) (r1191 RegLan :list))
  :premises ((= (str.len s1187) (str.len t1188)) (= (= s1187 t1188) false))
  :args (s1187 t1188 sr11189 sr21190 r1191)
  :conclusion (= (str.in_re s1187 ($singleton_elim (re.++ (str.to_re (str.++ t1188 sr11189 sr21190)) r1191))) false)
)
(declare-rule str-in-re-strip-prefix-base ((s1192 String) (s11193 String) (s21194 String :list) (sr11195 String) (sr21196 String :list))
  :args (s1192 s11193 s21194 sr11195 sr21196)
  :conclusion (= (str.in_re (str.++ s1192 s11193 s21194) (str.to_re (str.++ s1192 sr11195 sr21196))) (str.in_re ($singleton_elim (str.++ s11193 s21194)) (str.to_re ($singleton_elim (str.++ sr11195 sr21196)))))
)
(declare-rule str-in-re-strip-prefix-base-neg ((s1197 String) (t1198 String) (s11199 String) (s21200 String :list) (sr11201 String) (sr21202 String :list))
  :premises ((= (str.len s1197) (str.len t1198)) (= (= s1197 t1198) false))
  :args (s1197 t1198 s11199 s21200 sr11201 sr21202)
  :conclusion (= (str.in_re (str.++ s1197 s11199 s21200) (str.to_re (str.++ t1198 sr11201 sr21202))) false)
)
(declare-rule str-in-re-strip-prefix-base-s-single ((s1203 String) (sr11204 String) (sr21205 String :list))
  :args (s1203 sr11204 sr21205)
  :conclusion (= (str.in_re s1203 (str.to_re (str.++ s1203 sr11204 sr21205))) (str.in_re "" (str.to_re ($singleton_elim (str.++ sr11204 sr21205)))))
)
(declare-rule str-in-re-strip-prefix-base-s-single-neg ((s1206 String) (t1207 String) (sr11208 String) (sr21209 String :list))
  :premises ((= (str.len s1206) (str.len t1207)) (= (= s1206 t1207) false))
  :args (s1206 t1207 sr11208 sr21209)
  :conclusion (= (str.in_re s1206 (str.to_re (str.++ t1207 sr11208 sr21209))) false)
)
(declare-rule str-in-re-strip-char ((s1210 String) (s11211 String) (s21212 String :list) (r11213 RegLan) (r21214 RegLan :list))
  :premises ((= (str.len s1210) 1))
  :args (s1210 s11211 s21212 r11213 r21214)
  :conclusion (= (str.in_re (str.++ s1210 s11211 s21212) (re.++ re.allchar r11213 r21214)) (str.in_re ($singleton_elim (str.++ s11211 s21212)) ($singleton_elim (re.++ r11213 r21214))))
)
(declare-rule str-in-re-strip-char-s-single ((s1215 String) (r11216 RegLan) (r21217 RegLan :list))
  :premises ((= (str.len s1215) 1))
  :args (s1215 r11216 r21217)
  :conclusion (= (str.in_re s1215 (re.++ re.allchar r11216 r21217)) (str.in_re "" ($singleton_elim (re.++ r11216 r21217))))
)
(declare-rule str-in-re-strip-prefix-rev ((s1218 String) (s11219 String) (s21220 String :list) (sr11221 String) (sr21222 String :list) (r1223 RegLan :list))
  :args (s1218 s11219 s21220 sr11221 sr21222 r1223)
  :conclusion (= (str.in_re (str.++ s11219 s21220 s1218) ($singleton_elim (re.++ r1223 (str.to_re (str.++ sr11221 sr21222 s1218))))) (str.in_re ($singleton_elim (str.++ s11219 s21220)) ($singleton_elim (re.++ r1223 (str.to_re ($singleton_elim (str.++ sr11221 sr21222)))))))
)
(declare-rule str-in-re-strip-prefix-neg-rev ((s1224 String) (t1225 String) (s11226 String) (s21227 String :list) (sr11228 String) (sr21229 String :list) (r1230 RegLan :list))
  :premises ((= (str.len s1224) (str.len t1225)) (= (= s1224 t1225) false))
  :args (s1224 t1225 s11226 s21227 sr11228 sr21229 r1230)
  :conclusion (= (str.in_re (str.++ s11226 s21227 s1224) ($singleton_elim (re.++ r1230 (str.to_re (str.++ sr11228 sr21229 t1225))))) false)
)
(declare-rule str-in-re-strip-prefix-sr-single-rev ((s1231 String) (s11232 String) (s21233 String :list) (r11234 RegLan) (r21235 RegLan :list))
  :args (s1231 s11232 s21233 r11234 r21235)
  :conclusion (= (str.in_re (str.++ s11232 s21233 s1231) (re.++ r11234 r21235 (str.to_re s1231))) (str.in_re ($singleton_elim (str.++ s11232 s21233)) ($singleton_elim (re.++ r11234 r21235))))
)
(declare-rule str-in-re-strip-prefix-sr-single-neg-rev ((s1236 String) (t1237 String) (s11238 String) (s21239 String :list) (r11240 RegLan) (r21241 RegLan :list))
  :premises ((= (str.len s1236) (str.len t1237)) (= (= s1236 t1237) false))
  :args (s1236 t1237 s11238 s21239 r11240 r21241)
  :conclusion (= (str.in_re (str.++ s11238 s21239 s1236) (re.++ r11240 r21241 (str.to_re t1237))) false)
)
(declare-rule str-in-re-strip-prefix-srs-single-rev ((s1242 String) (r11243 RegLan) (r21244 RegLan :list))
  :args (s1242 r11243 r21244)
  :conclusion (= (str.in_re s1242 (re.++ r11243 r21244 (str.to_re s1242))) (str.in_re "" ($singleton_elim (re.++ r11243 r21244))))
)
(declare-rule str-in-re-strip-prefix-srs-single-neg-rev ((s1245 String) (t1246 String) (r11247 RegLan) (r21248 RegLan :list))
  :premises ((= (str.len s1245) (str.len t1246)) (= (= s1245 t1246) false))
  :args (s1245 t1246 r11247 r21248)
  :conclusion (= (str.in_re s1245 (re.++ r11247 r21248 (str.to_re t1246))) false)
)
(declare-rule str-in-re-strip-prefix-s-single-rev ((s1249 String) (sr11250 String) (sr21251 String :list) (r1252 RegLan :list))
  :args (s1249 sr11250 sr21251 r1252)
  :conclusion (= (str.in_re s1249 ($singleton_elim (re.++ r1252 (str.to_re (str.++ sr11250 sr21251 s1249))))) (str.in_re "" ($singleton_elim (re.++ r1252 (str.to_re ($singleton_elim (str.++ sr11250 sr21251)))))))
)
(declare-rule str-in-re-strip-prefix-s-single-neg-rev ((s1253 String) (t1254 String) (sr11255 String) (sr21256 String :list) (r1257 RegLan :list))
  :premises ((= (str.len s1253) (str.len t1254)) (= (= s1253 t1254) false))
  :args (s1253 t1254 sr11255 sr21256 r1257)
  :conclusion (= (str.in_re s1253 ($singleton_elim (re.++ r1257 (str.to_re (str.++ sr11255 sr21256 t1254))))) false)
)
(declare-rule str-in-re-strip-prefix-base-rev ((s1258 String) (s11259 String) (s21260 String :list) (sr11261 String) (sr21262 String :list))
  :args (s1258 s11259 s21260 sr11261 sr21262)
  :conclusion (= (str.in_re (str.++ s11259 s21260 s1258) (str.to_re (str.++ sr11261 sr21262 s1258))) (str.in_re ($singleton_elim (str.++ s11259 s21260)) (str.to_re ($singleton_elim (str.++ sr11261 sr21262)))))
)
(declare-rule str-in-re-strip-prefix-base-neg-rev ((s1263 String) (t1264 String) (s11265 String) (s21266 String :list) (sr11267 String) (sr21268 String :list))
  :premises ((= (str.len s1263) (str.len t1264)) (= (= s1263 t1264) false))
  :args (s1263 t1264 s11265 s21266 sr11267 sr21268)
  :conclusion (= (str.in_re (str.++ s11265 s21266 s1263) (str.to_re (str.++ sr11267 sr21268 t1264))) false)
)
(declare-rule str-in-re-strip-prefix-base-s-single-rev ((s1269 String) (sr11270 String) (sr21271 String :list))
  :args (s1269 sr11270 sr21271)
  :conclusion (= (str.in_re s1269 (str.to_re (str.++ sr11270 sr21271 s1269))) (str.in_re "" (str.to_re ($singleton_elim (str.++ sr11270 sr21271)))))
)
(declare-rule str-in-re-strip-prefix-base-s-single-neg-rev ((s1272 String) (t1273 String) (sr11274 String) (sr21275 String :list))
  :premises ((= (str.len s1272) (str.len t1273)) (= (= s1272 t1273) false))
  :args (s1272 t1273 sr11274 sr21275)
  :conclusion (= (str.in_re s1272 (str.to_re (str.++ sr11274 sr21275 t1273))) false)
)
(declare-rule str-in-re-strip-char-rev ((s1276 String) (s11277 String) (s21278 String :list) (r11279 RegLan) (r21280 RegLan :list))
  :premises ((= (str.len s1276) 1))
  :args (s1276 s11277 s21278 r11279 r21280)
  :conclusion (= (str.in_re (str.++ s11277 s21278 s1276) (re.++ r11279 r21280 re.allchar)) (str.in_re ($singleton_elim (str.++ s11277 s21278)) ($singleton_elim (re.++ r11279 r21280))))
)
(declare-rule str-in-re-strip-char-s-single-rev ((s1281 String) (r11282 RegLan) (r21283 RegLan :list))
  :premises ((= (str.len s1281) 1))
  :args (s1281 r11282 r21283)
  :conclusion (= (str.in_re s1281 (re.++ r11282 r21283 re.allchar)) (str.in_re "" ($singleton_elim (re.++ r11282 r21283))))
)
(declare-rule str-in-re-req-unfold ((s1284 String) (r11285 RegLan) (r21286 RegLan) (r31287 RegLan :list))
  :premises ((= (str.in_re s1284 ($singleton_elim (re.++ r21286 r31287))) false))
  :args (s1284 r11285 r21286 r31287)
  :conclusion (= (str.in_re s1284 (re.++ (re.* r11285) r21286 r31287)) (str.in_re s1284 (re.++ r11285 (re.* r11285) r21286 r31287)))
)
(declare-rule str-in-re-req-unfold-rev ((s1288 String) (r11289 RegLan) (r21290 RegLan :list) (r31291 RegLan))
  :premises ((= (str.in_re s1288 ($singleton_elim (re.++ r11289 r21290))) false))
  :args (s1288 r11289 r21290 r31291)
  :conclusion (= (str.in_re s1288 (re.++ r11289 r21290 (re.* r31291))) (str.in_re s1288 (re.++ r11289 r21290 (re.* r31291) r31291)))
)
(declare-rule str-in-re-skip-unfold ((s1292 String) (r11293 RegLan) (r21294 RegLan) (r31295 RegLan :list))
  :premises ((= (str.in_re s1292 (re.++ r11293 (re.* r11293) r21294 r31295)) false))
  :args (s1292 r11293 r21294 r31295)
  :conclusion (= (str.in_re s1292 (re.++ (re.* r11293) r21294 r31295)) (str.in_re s1292 ($singleton_elim (re.++ r21294 r31295))))
)
(declare-rule str-in-re-skip-unfold-rev ((s1296 String) (r11297 RegLan) (r21298 RegLan :list) (r31299 RegLan))
  :premises ((= (str.in_re s1296 (re.++ r11297 r21298 (re.* r31299) r31299)) false))
  :args (s1296 r11297 r21298 r31299)
  :conclusion (= (str.in_re s1296 (re.++ r11297 r21298 (re.* r31299))) (str.in_re s1296 ($singleton_elim (re.++ r11297 r21298))))
)
(declare-rule str-in-re-test-unfold ((s1300 String) (r11301 RegLan) (r21302 RegLan) (r31303 RegLan :list))
  :premises ((= (str.in_re s1300 ($singleton_elim (re.++ r21302 r31303))) false) (= (str.in_re s1300 (re.++ r11301 (re.* r11301) r21302 r31303)) false))
  :args (s1300 r11301 r21302 r31303)
  :conclusion (= (str.in_re s1300 (re.++ (re.* r11301) r21302 r31303)) false)
)
(declare-rule str-in-re-test-unfold-rev ((s1304 String) (r11305 RegLan) (r21306 RegLan :list) (r31307 RegLan))
  :premises ((= (str.in_re s1304 ($singleton_elim (re.++ r11305 r21306))) false) (= (str.in_re s1304 (re.++ r11305 r21306 (re.* r31307) r31307)) false))
  :args (s1304 r11305 r21306 r31307)
  :conclusion (= (str.in_re s1304 (re.++ r11305 r21306 (re.* r31307))) false)
)
(declare-rule eq-refl ((@T0 Type) (t1329 @T0))
  :args (t1329)
  :conclusion (= (= t1329 t1329) true)
)
(declare-rule eq-symm ((@T0 Type) (@T1 Type) (t1330 @T0) (s1331 @T1))
  :args (t1330 s1331)
  :conclusion (= (= t1330 s1331) (= s1331 t1330))
)
(declare-rule distinct-binary-elim ((@T0 Type) (@T1 Type) (t1332 @T0) (s1333 @T1))
  :args (t1332 s1333)
  :conclusion (= (distinct t1332 s1333) (not (= t1332 s1333)))
)
(declare-rule uf-bv2nat-geq-elim ((@n0 Int) (x1334 (BitVec @n0)) (n1335 Int))
  :args (x1334 n1335)
  :conclusion (= (>= (bv2nat x1334) n1335) (eo::define ((_let_1 (@bvsize x1334))) (ite (>= n1335 _let_1) false (ite (< n1335 0) true (bvuge x1334 (int2bv _let_1 n1335))))))
)
