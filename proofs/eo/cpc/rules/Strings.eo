(include "../theories/Strings.eo")
(include "../theories/Quantifiers.eo")
(include "../programs/Strings.eo")

;;-------------------- Core

; rule: string_length_pos
; implements: ProofRule::STRING_LENGTH_POS
; args:
; - s String: The string term.
; conclusion: >
;   The length of s is zero and it is the empty string, or its length is
;   strictly greater than zero.
(declare-rule string_length_pos ((U Type) (s U))
  :args (s)
  :conclusion
    (or (and (= (str.len s) 0) (= s ($mk_emptystr (eo::typeof s)))) (> (str.len s) 0))
)

; rule: string_length_non_empty
; implements: ProofRule::STRING_LENGTH_NON_EMPTY
; premises:
; - deq: A disequality between strings s and t.
; requires: t is the empty string.
; conclusion: The length of s is not zero.
(declare-rule string_length_non_empty ((U Type) (s (Seq U)) (t (Seq U)))
  :premises ((not (= s t)))
  :requires ((($str_is_empty t) true))
  :conclusion (not (= (str.len s) 0))
)

; rule: concat_eq
; implements: ProofRule::CONCAT_EQ
; premises:
; - eq: An equality between strings s and t.
; args:
; - rev Bool: Whether we are reasoning about the end of strings s and t.
; conclusion: >
;   An equality between the components of s and t beyond their equal components.
;   For example, from (= (str.++ x y) (str.++ x z)), we conclude (= y z).
(declare-rule concat_eq ((U Type) (s U) (t U) (rev Bool))
  :premises ((= s t))
  :args (rev)
  :conclusion
    (eo::match ((ss U) (ts U))
      ($str_strip_prefix
           ($str_to_nary_form s rev)
           ($str_to_nary_form t rev))
      (((@pair ss ts)
        (= 
          ($str_from_nary_form ss rev)
          ($str_from_nary_form ts rev)))))
)

; rule: concat_unify
; implements: ProofRule::CONCAT_UNIFY
; premises:
; - eq: An equality between strings s and t.
; - leq: An equality between the lengths of child strings of s and t.
; args:
; - rev Bool: Whether we are reasoning about the end of strings s and t.
; requires: >
;   leq refers to children that are the first (resp. last) components
;   of s and t.
; conclusion: an equality between the given children of s and t. 
(declare-rule concat_unify ((U Type) (s U) (t U) (s1 U) (t1 U) (rev Bool))
  :premises ((= s t) (= (str.len s1) (str.len t1)))
  :args (rev)
  :requires ((($str_head ($str_to_nary_form s rev)) s1)
             (($str_head ($str_to_nary_form t rev)) t1))
  :conclusion (= s1 t1)
)

; rule: concat_csplit
; implements: ProofRule::CONCAT_CSPLIT
; premises:
; - eq: An equality between strings t and s.
; - ldeq: A disequality stating that the length of u is non-zero.
; args:
; - rev Bool: Whether we are reasoning about the end of strings t and s.
; conclusion: >
;   Assuming u is the first (resp. last) child of t and the string s begins with
;   a string literal, this constructs an equality that decomposes u based on
;   its first character.
(declare-rule concat_csplit ((U Type) (t (Seq U)) (s (Seq U)) (u (Seq U)) (rev Bool))
  :premises ((= t s) (not (= (str.len u) 0)))
  :args (rev)
  :conclusion
    (eo::define ((t1 ($str_head ($str_to_nary_form t rev))))
    (eo::define ((s1 ($str_head ($str_to_nary_form s rev))))
      (eo::requires ($str_check_length_one s1) true    ; checks if char
        (= u
          (eo::ite rev
            (str.++ (@purify ($str_prefix u (- (str.len u) 1))) s1)
            (str.++ s1 (@purify ($str_suffix_rem u 1))))))))
)

; rule: concat_split
; implements: ProofRule::CONCAT_SPLIT
; premises:
; - eq: An equality between strings t and s.
; - lieq: An disequality between the lengths of child strings of t and s.
; args:
; - rev Bool: Whether we are reasoning about the end of strings t and s.
; conclusion: >
;   A splitting lemma based on the children referred to in leq. In particular,
;   we case split based on which string is longer.
(declare-rule concat_split ((U Type) (t (Seq U)) (s (Seq U)) (tc (Seq U)) (sc (Seq U)) (rev Bool))
  :premises ((= t s) (not (= (str.len tc) (str.len sc))))
  :args (rev)
  :conclusion
    (eo::define ((t1 ($str_head ($str_to_nary_form t rev))))
    (eo::define ((s1 ($str_head ($str_to_nary_form s rev))))
    (eo::define ((k (@purify ($str_unify_split t1 s1 rev))))
      (eo::requires t1 tc
      (eo::requires s1 sc
        (and 
          (or 
            (= t1
              (eo::ite rev
                (str.++ k s1)
                (str.++ s1 k)))
            (= s1
              (eo::ite rev
                (str.++ k t1)
                (str.++ t1 k))))
            (not (= k ($mk_emptystr (eo::typeof k))))
            (> (str.len k) 0)
        ))))))
)

; rule: concat_lprop
; implements: ProofRule::CONCAT_LPROP
; premises:
; - eq: An equality between strings t and s.
; - leq: An inequality stating that the first (resp. last) child of t is longer than the child of s.
; args:
; - rev Bool: Whether we are reasoning about the end of strings t and s.
; conclusion: >
;   An equality that decomposes the first (resp. last) child of t based on the
;   length of the corresponding child in s.
(declare-rule concat_lprop ((U Type) (t (Seq U)) (s (Seq U)) (tc (Seq U)) (sc (Seq U)) (rev Bool))
  :premises ((= t s) (> (str.len tc) (str.len sc)))
  :args (rev)
  :conclusion
    (eo::define ((t1 ($str_head ($str_to_nary_form t rev))))
    (eo::define ((s1 ($str_head ($str_to_nary_form s rev))))
      (eo::requires t1 tc
      (eo::requires s1 sc
        (eo::define ((k (@purify ($str_unify_split t1 s1 rev))))
          (and
            (= t1
              (eo::ite rev
                (str.++ k s1)
                (str.++ s1 k)))
            (not (= k ($mk_emptystr (eo::typeof k))))
            (> (str.len k) 0)))))))
)

; rule: concat_cprop
; implements: ProofRule::CONCAT_CPROP
; premises:
; - eq: An equality between strings t and s.
; - ldeq: A disequality stating the first (resp. last) child of t is non-empty.
; args:
; - rev Bool: Whether we are reasoning about the end of strings t and s.
; conclusion: >
;   An equality involving the given child of t. In particular, we infer what
;   portion of the prefix (resp. suffix) it is entailed to be based on
;   reasoning about adjacent constants.
(declare-rule concat_cprop ((U Type) (t (Seq U)) (tc (Seq U)) (s (Seq U)) (rev Bool))
  :premises ((= t s) (not (= (str.len tc) 0)))
  :args (rev)
  :conclusion
    (eo::define ((tn ($str_to_nary_form t rev)))
    (eo::define ((t1 ($str_head tn)))
    (eo::define ((t2 (eo::list_nth str.++ tn 1))) ; get the second component
    (eo::define ((s1 ($str_head ($str_to_nary_form s rev))))
    (eo::define ((s1len (eo::len s1)))
    (eo::define ((s1s (eo::ite rev (eo::extract s1 0 (eo::add s1len -2)) (eo::extract s1 1 s1len))))  ; remove one character from s1
    (eo::define ((v (eo::add 1 ($str_overlap s1s t2 rev)))) ; get the overlap, plus one
      (eo::requires t1 tc
        (= tc
          (eo::ite rev
            (eo::define ((oc ($str_suffix s1 v)))
              (str.++ (@purify ($str_prefix tc ($arith_mk_binary_minus (str.len tc) (str.len oc)))) oc))
            (eo::define ((oc ($str_prefix s1 v)))
              (str.++ oc (@purify ($str_suffix_rem tc (str.len oc)))))))))))))))
)

; rule: concat_conflict
; implements: ProofRule::CONCAT_CONFLICT
; premises:
; - eq: An equality between strings t and s.
; args:
; - rev Bool: Whether we are reasoning about the end of strings t and s.
; conclusion: >
;   false if the prefix (resp. suffix) involves clashing characters at the same
;   position.
; note: This rule is used for strings only, not sequences.
(declare-rule concat_conflict ((s String) (t String) (rev Bool))
  :premises ((= s t))
  :args (rev)
  :conclusion
      (eo::define ((cs ($str_head ($str_to_nary_form s rev))))
      (eo::define ((ct ($str_head ($str_to_nary_form t rev))))
        ; ensure they are disequal, return false
        (eo::requires (eo::is_str cs) true
        (eo::requires (eo::is_str ct) true
        (eo::requires (eo::len cs) (eo::len ct)
          false)))))
)

; rule: concat_conflict_deq
; implements: ProofRule::CONCAT_CONFLICT_DEQ
; premises:
; - eq: An equality between strings s and t.
; - cdeq: A disequality between two unit terms corresponding to children of s and t.
; args:
; - rev Bool: Whether we are reasoning about the end of strings s and t.
; conclusion: >
;   false if we can show that cdeq indeed refers to a prefix (resp. suffix) of s and t.
; note: This rule is used for sequences only, not strings.
(declare-rule concat_conflict_deq ((U Type) (s (Seq U)) (t (Seq U)) (x U) (y U) (rev Bool))
  :premises ((= s t) (not (= (seq.unit x) (seq.unit y))))
  :args (rev)
  :conclusion
    ; take the first character from each side, should give x and y
    (eo::requires ($str_head ($str_to_nary_form s rev)) (seq.unit x)
    (eo::requires ($str_head ($str_to_nary_form t rev)) (seq.unit y)
        false))
)

; rule: string_decompose
; implements: ProofRule::STRING_DECOMPOSE
; premises:
; - a: An inequality between the length of some string term s and integer n.
; args:
; - b Bool: Whether we are the reverse variant of this inference.
; conclusion: >
;   A conjunction stating that s is equal to two purification skolems
;   corresponding to decomposing s at position n, and that the decomposed term
;   has length n.
(declare-rule string_decompose ((U Type) (s (Seq U)) (n Int) (b Bool))
  :premises ((>= (str.len s) n))
  :args (b)
  :conclusion (eo::ite b
                (eo::define ((kp (@purify ($str_prefix_rem s n)))
                      (ks (@purify ($str_suffix s n))))
                (and (= s (str.++ kp ks)) (= (str.len ks) n)))
                (eo::define ((kp (@purify ($str_prefix s n)))
                      (ks (@purify ($str_suffix_rem s n))))
                (and (= s (str.++ kp ks)) (= (str.len kp) n)))))

; rule: string_code_inj
; implements: ProofRule::STRING_CODE_INJ
; args:
; - t String: The first string.
; - s String: The second string.
; conclusion: >
;   A disjunction of three cases, indicating that t is not a string of length
;   one, its code point is different from that of s, or t and s are equal.
(declare-rule string_code_inj ((t String) (s String))
  :args (t s)
  :conclusion (or (= (str.to_code t) -1) (not (= (str.to_code t) (str.to_code s))) (= t s))
)

; rule: string_seq_unit_inj
; implements: ProofRule::STRING_SEQ_UNIT_INJ
; premises:
; - eq: An equality stating that the unit sequences of elements a and b are equal.
; conclusion: That a and b are equal.
(declare-rule string_seq_unit_inj ((U Type) (a U) (b U))
  :premises ((= (seq.unit a) (seq.unit b)))
  :conclusion (= a b)
)

;;-------------------- Regular expressions

;;;;; ProofRule::RE_INTER

; rule: re_inter
; implements: ProofRule::RE_INTER
; premises:
; - m1: The first membership
; - m2: The second membership, for the same string.
; conclusion: >
;   The string is in the intersection of the regular expressions referred to in 
;   the premises.
(declare-rule re_inter ((x String) (s RegLan) (t RegLan))
  :premises ((str.in_re x s) (str.in_re x t))
  :conclusion (str.in_re x (re.inter s t))
)

;;;;; ProofRule::RE_CONCAT

; program: $mk_re_concat
; args:
; - E: A conjunction of regular expression memberships.
; return: >
;   The concatenation of the strings in E is in the concatenation of the regular
;   expressions in E.
(program $mk_re_concat ((Es Bool :list) (s String) (r RegLan))
  (Bool) Bool
  (
  (($mk_re_concat (and (str.in_re s r) Es)) (eo::match ((s1 String) (r1 RegLan))
                                              ($mk_re_concat Es)
                                              (((str.in_re s1 r1) (str.in_re (eo::cons str.++ s s1) (eo::cons re.++ r r1))))))
  (($mk_re_concat true)                     (str.in_re "" @re.empty))
  )
)

; rule: re_concat
; implements: ProofRule::RE_CONCAT
; premises:
; - E [:list]: A conjunction of regular expression memberships.
; conclusion: >
;   The concatenation of the strings in E is in the concatenation of the regular
;   expressions in E.
(declare-rule re_concat ((E Bool))
  :premise-list E and
  :conclusion ($mk_re_concat E)
)

;;;;; ProofRule::RE_UNFOLD_POS

; rule: re_unfold_pos
; implements: ProofRule::RE_UNFOLD_POS
; premises:
; - m: A regular expression membership (str.in_re t r).
; conclusion: >
;   The single step reduction of m. At a high level, this either reasons about
;   unfolding a regular expression star, or decomposes the components of t in
;   r if the latter is a regular expression concatenation.
(declare-rule re_unfold_pos ((t String) (r RegLan))
  :premises ((str.in_re t r))
  :conclusion
    (eo::match ((r1 RegLan) (r2 RegLan :list))
      r
      (
        ((re.* r1)
            (eo::match ((k1 String) (k2 String) (k3 String) (M Bool :list))
            ($re_unfold_pos_concat t (re.++ r1 r r1))
            (((@pair (str.++ k1 k2 k3) M)
                (or 
                (= t "") 
                (str.in_re t r1)
                (and
                    (eo::cons and (= t (str.++ k1 k2 k3)) M)
                    (not (= k1 ""))
                    (not (= k3 ""))))))))
        ((re.++ r1 r2)
            (eo::match ((tk String) (M Bool :list))
            ($re_unfold_pos_concat t r)
            (((@pair tk M)
                (eo::define ((teq (= t tk))) (eo::ite (eo::is_eq M true) teq (and teq M)))))))
    ))
)

;;;;; ProofRule::RE_UNFOLD_NEG_CONCAT_FIXED

; rule: re_unfold_neg_concat_fixed
; implements: ProofRule::RE_UNFOLD_NEG_CONCAT_FIXED
; premises:
; - m: The negation of a regular expression membership.
; args:
; - rev Bool: Whether we are looking at the end of a regular expression concatenation.
; conclusion: >
;   A split based on the information that the first (resp. last) child of the
;   regular expression in question has a fixed length. This is an optimized
;   version of ProofRule::RE_UNFOLD_NEG that does not introduce a quantified
;   formula for reasoning about length.
(declare-rule re_unfold_neg_concat_fixed ((s String) (r RegLan) (rev Bool))
  :premises ((not (str.in_re s r)))
  :args (rev)
  :conclusion
    (eo::match ((r1 RegLan) (r2 RegLan :list))
      ($str_rev rev r)
      (
        ((re.++ r1 r2) (eo::define ((n ($str_fixed_len_re r1)))
                       (eo::ite rev
                       (or (not (str.in_re ($str_suffix s n) r1))
                           (not (str.in_re ($str_prefix s (- (str.len s) n)) ($singleton_elim ($str_rev rev r2)))))
                       (or (not (str.in_re ($str_prefix s n) r1))
                           (not (str.in_re ($str_suffix_rem s n) ($singleton_elim r2)))))))
    ))
)

;;;;; ProofRule::RE_UNFOLD_NEG

; rule: re_unfold_neg
; implements: ProofRule::RE_UNFOLD_NEG
; premises:
; - m: A negated regular expression membership (not (str.in_re t r)).
; conclusion: >
;   The single step reduction of m. At a high level, this introduces a bounded
;   quantified formula stating that no decomposition of t occurs in the
;   corresponding decomposition of r.
(declare-rule re_unfold_neg ((t String) (r RegLan))
  :premises ((not (str.in_re t r)))
  :conclusion
    (eo::match ((r1 RegLan) (r2 RegLan :list))
      r
      (
        ((re.* r1)
          (and
            (not (= t ""))
            (forall ((@var.str_index Int))
              (or (<= @var.str_index 0)
                  (< (str.len t) @var.str_index)
                  (not (str.in_re ($str_prefix t @var.str_index) r1))
                  (not (str.in_re ($str_suffix_rem t @var.str_index) r))))))
        ((re.++ r1 r2)
          (forall ((@var.str_index Int))
            (or (< @var.str_index 0)
                (< (str.len t) @var.str_index)
                (not (str.in_re ($str_prefix t @var.str_index) r1))
                (not (str.in_re ($str_suffix_rem t @var.str_index) ($singleton_elim r2))))))
    ))
)

;;;;; ProofRule::STRING_EXT

; rule: string_ext
; implements: ProofRule::STRING_EXT
; premises:
; - deq: A disequality between strings or sequences.
; conclusion: The strings have different length or are disequal for a witness index, as given by the skolem (@strings_deq_diff s t).
(declare-rule string_ext ((T Type)  (s (Seq T)) (t (Seq T)))
  :premises ((not (= s t)))
  :conclusion (eo::define ((k (@strings_deq_diff s t)))
              (or (not (= (str.len s) (str.len t))) 
                  (and (not (= ($str_mk_nth s k) ($str_mk_nth t k)))
                       (<= 0 k)
                       (< k (str.len s)))))
)

;;-------------------- Extended functions 

; rule: string_reduction
; implements: ProofRule::STRING_REDUCTION
; args:
; - s (Seq U): The term to reduce.
; conclusion: The reduction predicate for s.
(declare-rule string_reduction ((U Type) (s U))
  :args (s)
  :conclusion (and ($str_reduction_pred s) (= s (@purify s)))
)

; rule: string_eager_reduction
; implements: ProofRule::STRING_EAGER_REDUCTION
; args:
; - s (Seq U): The term to reduce.
; conclusion: The eager reduction predicate for s.
(declare-rule string_eager_reduction ((U Type) (s U))
  :args (s)
  :conclusion ($mk_str_eager_reduction s)
)

;;-------------------- Instances of THEORY_REWRITE

; rule: arith-string-pred-entail
; implements: ProofRewriteRule::ARITH_STRING_PRED_ENTAIL
; args:
; - eq Bool: The equality to prove between an integer inequality and true.
; requires: showing that n is entailed to be greater than 0 using $str_arith_entail_simple.
; conclusion: The given equality.
(declare-rule arith-string-pred-entail ((n Int))
  :args ((= (>= n 0) true))
  :requires ((($str_arith_entail_simple n) true))
  :conclusion (= (>= n 0) true)
)

; rule: arith-string-pred-entail
; implements: ProofRewriteRule::ARITH_STRING_SAFE_APPROX
; args:
; - eq Bool: The equality to prove between integer inequalities.
; requires:
; - showing that the right hand side is a valid under-approximation of the left hand side. In other words (>= n m) is entailed.
; - showing that the right hand side is entailed to be true, that is, (>= m 0) is true and thus (>= n 0) is true.
; conclusion: The given equality.
(declare-rule arith-string-pred-safe-approx ((n Int) (m Int))
  :args ((= (>= n 0) (>= m 0)))
  :requires ((($str_arith_entail_is_approx n m true) true)
             (($str_arith_entail_simple_pred (>= m 0)) true))
  :conclusion (= (>= n 0) (>= m 0))
)

; rule: str-in-re-eval
; implements: ProofRewriteRule::STR_IN_RE_EVAL
; args:
; - eq Bool: The equality to prove whose left hand side is a regular expression membership.
; requires: >
;   Showing that the regular expression membership evaluates to the right hand side.
; conclusion: The given equality.
(declare-rule str-in-re-eval ((s String) (r RegLan) (b Bool))
  :args ((= (str.in_re s r) b))
  :requires ((($str_eval_str_in_re s r) b))
  :conclusion (= (str.in_re s r) b)
)

; rule: str-in-re-consume
; implements: ProofRewriteRule::STR_IN_RE_CONSUME
; args:
; - eq Bool: The equality to prove whose left hand side is a regular expression membership.
; requires: >
;   Showing that consuming portions of the regular expression membership using the
;   method $str_re_consume results in b, where b is either false or the result of
;   stripping constant prefixes and suffixes from the arguments of the left hand side
;   of the given equality.
; conclusion: The given equality.
(declare-rule str-in-re-consume ((s String) (r RegLan) (b Bool))
  :args ((= (str.in_re s r) b))
  :requires ((($str_re_consume s r) b))
  :conclusion (= (str.in_re s r) b)
)

; rule: re-loop-elim
; implements: ProofRewriteRule::RE_LOOP_ELIM
; args:
; - eq Bool: The equality to prove whose left hand side is a regular expression loop.
; requires: >
;   Showing that the right hand side of the equality is the result of
;   eliminating the regular expression loop term.
; conclusion: The given equality.
(declare-rule re-loop-elim ((l Int) (u Int) (r1 RegLan) (r2 RegLan))
  :args ((= (re.loop l u r1) r2))
  :requires (((eo::is_neg (eo::add (eo::neg l) u)) false)
             (($str_mk_re_loop_elim l (eo::add (eo::neg l) u) r1) r2))
  :conclusion (= (re.loop l u r1) r2)
)

; rule: re-inter-inclusion
; implements: ProofRewriteRule::RE_INTER_INCLUSION
; args:
; - eq Bool: The equality between regular expressions to prove.
; requires: >
;   the left hand side is the intersection of the complement of a regular
;   expression and one that it includes.
; conclusion: The given equality.
(declare-rule re-inter-inclusion ((r1 RegLan) (r2 RegLan))
  :args ((= (re.inter r1 (re.comp r2)) re.none))
  :requires ((($str_re_includes r2 r1) true))
  :conclusion (= (re.inter r1 (re.comp r2)) re.none)
)

; rule: re-union-inclusion
; implements: ProofRewriteRule::RE_UNION_INCLUSION
; args:
; - eq Bool: The equality between regular expressions to prove.
; requires: >
;   the left hand side is the union of the complement of a regular
;   expression and one that it is included by.
; conclusion: The given equality.
(declare-rule re-union-inclusion ((r1 RegLan) (r2 RegLan))
  :args ((= (re.union r1 (re.comp r2)) (re.* re.allchar)))
  :requires ((($str_re_includes r1 r2) true))
  :conclusion (= (re.union r1 (re.comp r2)) (re.* re.allchar))
)

; rule: str-in-re-concat-star-char
; implements: ProofRewriteRule::STR_IN_RE_CONCAT_STAR_CHAR
; args:
; - eq Bool: The equality between regular expression membership and a formula.
; requires:
; - The regular expression we are considering is of the form (re.* r) where r has fixed length one.
; - The right hand side of the equality is the result of rewriting the membership.
; conclusion: The given equality.
(declare-rule str-in-re-concat-star-char ((s1 String) (s2 String :list) (r RegLan) (b Bool))
  :args ((= (str.in_re (str.++ s1 s2) (re.* r)) b))
  :requires ((($str_fixed_len_re r) 1) 
             (($str_mk_str_in_re_concat_star_char (str.++ s1 s2) (re.* r)) b))
  :conclusion (= (str.in_re (str.++ s1 s2) (re.* r)) b)
)

; rule: str-in-re-sigma
; implements: ProofRewriteRule::STR_IN_RE_SIGMA
; args:
; - eq Bool: The equality between regular expression membership and a formula.
; requires: >
;   The right hand side of the equality is the result of rewriting the
;   membership.
; conclusion: The given equality.
(declare-rule str-in-re-sigma ((s String) (r RegLan) (b Bool))
  :args ((= (str.in_re s r) b))
  :requires ((($str_mk_str_in_re_sigma s r) b))
  :conclusion (= (str.in_re s r) b)
)

; rule: str-in-re-sigma-star
; implements: ProofRewriteRule::STR_IN_RE_SIGMA_STAR
; args:
; - eq Bool: The equality between regular expression membership and a formula.
; requires: >
;   The right hand side of the equality is the result of rewriting the
;   membership.
; conclusion: The given equality.
(declare-rule str-in-re-sigma-star ((s String) (r RegLan) (b Bool))
  :args ((= (str.in_re s (re.* r)) b))
  :requires ((($str_mk_str_in_re_sigma_star s r) b))
  :conclusion (= (str.in_re s (re.* r)) b)
)

;;;;; ProofRewriteRule::STR_CTN_MULTISET_SUBSET

; program: $str_multiset_overapprox
; args:
; - s (Seq T): the term.
; return: >
;   The multiset over-approximation of s, which is a (flattened) list of
;   terms which represents an overapproximation of what s may contain.
;   In particular, note that all string literals are broken up into string
;   literals of size one.
(program $str_multiset_overapprox ((T Type) (s (Seq T)) (ss (Seq T) :list) (t (Seq T)) (r (Seq T)) (n Int) (m Int))
    ((Seq T)) @List
    (
      (($str_multiset_overapprox (str.++ s ss))        (eo::list_concat @list ($str_multiset_overapprox s) ($str_multiset_overapprox ss)))
      (($str_multiset_overapprox (str.substr s n m))   ($str_multiset_overapprox s))
      (($str_multiset_overapprox (str.replace s t r))  (eo::list_concat @list ($str_multiset_overapprox s) ($str_multiset_overapprox r)))
      (($str_multiset_overapprox s)                    (eo::ite ($str_is_empty s)
                                                          @list.nil
                                                          (eo::ite (eo::is_str s)
                                                            (eo::ite (eo::gt (eo::len s) 1)
                                                              ; if a string constant of size > 1, flatten to characters and add to list
                                                              ($str_multiset_overapprox ($str_flatten_word s))
                                                              (@list s))
                                                            (@list s))))
    )
)

; program: $str_is_multiset_subset_strict
; args:
; - s (Seq T): a string term, expected to be in flattened form.
; - xs @List: the multiset (over)approximation of a string term.
; - nr @List: the accumulated list of previously processed terms from s that were not removed from xs.
; return: >
;   True if the string approximated by s is definitely not contained in the string
;   approximated by t. We compute this by iteratively removing the components of
;   s from t, and then checking if a term in nr is provably distinct from the final xs.
(program $str_is_multiset_subset_strict ((T Type :implicit) (emp (Seq T)) (s (Seq T)) (ss (Seq T) :list) (xs @List) (nr @List :list))
    ((Seq T) @List @List) Bool
    (
      (($str_is_multiset_subset_strict (str.++ s ss) xs nr) (eo::define ((xsr ($nary_remove @list @list.nil s xs)))
                                                            (eo::define ((nrem (eo::is_eq xs xsr)))
                                                              ($str_is_multiset_subset_strict ss xsr
                                                                ; we add s to the accumulated list if it was not removed from xs
                                                                (eo::ite nrem (@list s nr) nr)))))
      (($str_is_multiset_subset_strict emp xs (@list s nr)) (eo::ite ($are_distinct_terms_list_rec s xs (eo::typeof s))
                                                              ; if something was in s that is provably distinct from the remainder of t, we succeed
                                                              true
                                                              ($str_is_multiset_subset_strict emp xs nr)))
      (($str_is_multiset_subset_strict emp xs nr)           false)
    )
)

; rule: str-ctn-multiset-subset
; implements: ProofRewriteRule::STR_CTN_MULTISET_SUBSET
; args:
; - eq Bool: The equality between a contains predicate and false
; requires: >
;   The contains predicate can be shown false by multiset reasoning
; conclusion: The given equality.
(declare-rule str-ctn-multiset-subset ((T Type) (t (Seq T)) (s (Seq T)))
  :args ((= (str.contains t s) false))
  :requires ((($str_is_multiset_subset_strict
                ($str_to_flat_form s false)
                ($str_multiset_overapprox t) @list.nil) true))
  :conclusion (= (str.contains t s) false)
)

;;;;; ProofRewriteRule::STR_OVERLAP_SPLIT_CTN

; rule: str-overlap-split-ctn
; implements: ProofRewriteRule::STR_OVERLAP_SPLIT_CTN
; args:
; - eq Bool: The equality between a contains predicate and a disjunction.
; requires: >
;   The middle component of the first argument to contains has no forward
;   overlap with the second argument, and the second argument has not forward
;   overlap with the middle component of the first argument.
; conclusion: The given equality.
(declare-rule str-overlap-split-ctn ((T Type) (emp (Seq T) :list)
                                     (t (Seq T)) (s (Seq T)) (c (Seq T)) (d (Seq T)))
  :args ((= (str.contains (str.++ t c s emp) d)
            (or (str.contains t d) (str.contains s d))))
  :requires ((($str_is_empty emp) true)
             (($str_has_overlap c d false) false)
             (($str_has_overlap d c false) false))
  :conclusion (= (str.contains (str.++ t c s emp) d)
                 (or (str.contains t d) (str.contains s d)))
)

;;;;; ProofRewriteRule::STR_OVERLAP_ENDPOINTS_CTN

; rule: str-overlap-endpoints-ctn
; implements: ProofRewriteRule::STR_OVERLAP_ENDPOINTS_CTN
; args:
; - eq Bool: The equality between a contains predicate and a miniscoped version.
; requires: >
;   the first components of the arguments to contains have no forward overlap,
;   and the last components of the arguments to contains have no reverse
;   overlap.
; conclusion: The given equality.
(declare-rule str-overlap-endpoints-ctn ((T Type) (emp (Seq T) :list)
                                         (c1 (Seq T)) (s (Seq T)) (c2 (Seq T))
                                         (d1 (Seq T)) (t (Seq T)) (d2 (Seq T)))
  :args ((= (str.contains (str.++ c1 s c2 emp) (str.++ d1 t d2 emp))
            (str.contains s (str.++ d1 t d2 emp))))
  :requires ((($str_is_empty emp) true)
             (($str_has_overlap c1 d1 false) false)
             (($str_has_overlap c2 d2 true) false))
  :conclusion (= (str.contains (str.++ c1 s c2 emp) (str.++ d1 t d2 emp))
                 (str.contains s (str.++ d1 t d2 emp)))
)

;;;;; ProofRewriteRule::STR_OVERLAP_ENDPOINTS_INDEXOF

; rule: str-overlap-endpoints-indexof
; implements: ProofRewriteRule::STR_OVERLAP_ENDPOINTS_INDEXOF
; args:
; - eq Bool: The equality between a indexof term and miniscoped one.
; requires: >
;  the last components of the first two arguments to indexof have no reverse
;  overlap.
; conclusion: The given equality.
(declare-rule str-overlap-endpoints-indexof ((T Type) (emp (Seq T) :list)
                                             (s (Seq T)) (c (Seq T)) (t (Seq T)) (d (Seq T)))
  :args ((= (str.indexof (str.++ s c emp) (str.++ t d emp) 0)
            (str.indexof s (str.++ t d emp) 0)))
  :requires ((($str_is_empty emp) true)
             (($str_has_overlap c d true) false))
  :conclusion (= (str.indexof (str.++ s c emp) (str.++ t d emp) 0)
                 (str.indexof s (str.++ t d emp) 0))
)

;;;;; ProofRewriteRule::STR_OVERLAP_REPLACE

; rule: str-overlap-endpoints-replace
; implements: ProofRewriteRule::STR_OVERLAP_REPLACE
; args:
; - eq Bool: The equality between a replace term and a miniscoped one.
; requires: >
;   the first components of the first two arguments to replace have no forward
;   overlap, and the last components of the first two arguments to replace have
;   no reverse overlap.
; conclusion: The given equality.
(declare-rule str-overlap-endpoints-replace ((T Type) (emp (Seq T) :list)
                                             (c1 (Seq T)) (s (Seq T)) (c2 (Seq T))
                                             (d1 (Seq T)) (t (Seq T)) (d2 (Seq T)) (r (Seq T)))
  :args ((= (str.replace (str.++ c1 s c2 emp) (str.++ d1 t d2 emp) r)
            (str.++ c1 (str.replace s (str.++ d1 t d2 emp) r) c2 emp)))
  :requires ((($str_is_empty emp) true)
             (($str_has_overlap c1 d1 false) false)
             (($str_has_overlap c2 d2 true) false))
  :conclusion (= (str.replace (str.++ c1 s c2 emp) (str.++ d1 t d2 emp) r)
                 (str.++ c1 (str.replace s (str.++ d1 t d2 emp) r) c2 emp))
)

;;;;; ProofRewriteRule::STR_INDEXOF_RE_EVAL

; define: $str_eval_indexof_re
; args:
; - s String: A string.
; - r RegLan: A regular expression to match.
; - n Int: A start position.
; return: >
;   The result of evaluating (str.indexof_re s r n).
(define $str_eval_indexof_re ((s String) (r RegLan) (n Int))
  (eo::ite (eo::or (eo::gt n (eo::len s)) (eo::is_neg n))
    -1
    (eo::match ((sp Int) (ep Int))
      ($str_first_match (eo::extract s n (eo::len s)) r)
      (
      ((@pair -1 -1) -1)
      ((@pair sp ep) (eo::add n sp))
      ))))


; rule: str-indexof-re-eval
; implements: ProofRewriteRule::STR_INDEXOF_RE_EVAL
; args:
; - eq Bool: The equality between a indexof_re term and an integer.
; requires: >
;   Evaluating the left hand side gives the right hand side.
; conclusion: The given equality.
(declare-rule str-indexof-re-eval ((s String) (r RegLan) (n Int) (m Int))
  :args ((= (str.indexof_re s r n) m))
  :requires ((($str_eval_indexof_re s r n) m))
  :conclusion (= (str.indexof_re s r n) m)
)

;;;;; ProofRewriteRule::STR_REPLACE_RE_EVAL

; define: $str_eval_indexof_re
; args:
; - s String: A string.
; - r RegLan: A regular expression.
; - t String: A string to replace with.
; return: >
;   The result of evaluating (str.replace_re s r t), which is either s or a
;   concatenation of the prefix of s before the match, t and the suffix of s
;   after the match.
(define $str_eval_replace_re ((s String) (r RegLan) (t String))
  (eo::match ((sp Int) (ep Int))
    ($str_first_match s r)
    (
    ((@pair -1 -1) s)
    ; note that t does not need to be a constant, so the returned term is a concat term
    ((@pair sp ep) (str.++ (eo::extract s 0 (eo::add sp -1)) t (eo::extract s ep (eo::len s))))
    )))

; rule: str-replace-re-eval
; implements: ProofRewriteRule::STR_REPLACE_RE_EVAL
; args:
; - eq Bool: The equality between a replace_re term and a string.
; requires: >
;   Evaluating the left hand side gives the right hand side.
; conclusion: The given equality.
(declare-rule str-replace-re-eval ((s String) (r RegLan) (t String) (u String))
  :args ((= (str.replace_re s r t) u))
  :requires ((($str_eval_replace_re s r t) u))
  :conclusion (= (str.replace_re s r t) u)
)

;;;;; ProofRewriteRule::STR_REPLACE_RE_ALL_EVAL

; program: $str_eval_replace_re_all_rec
; args:
; - s String: A string.
; - r RegLan: A regular expression not containing the empty string.
; - t String: A string to replace with.
; - p @Pair: The result of finding the first match of r in s.
; return: >
;   The result of evaluating (str.replace_re_all s r t), which is a concatenation.
(program $str_eval_replace_re_all_rec ((s String) (r RegLan) (t String) (sp Int) (ep Int))
  (String RegLan String (@Pair Int Int)) String
  (
  (($str_eval_replace_re_all_rec "" r t (@pair -1 -1))  "")
  (($str_eval_replace_re_all_rec s r t (@pair -1 -1))   (eo::cons str.++ s ""))
  (($str_eval_replace_re_all_rec s r t (@pair sp ep))   (eo::define ((snext (eo::extract s ep (eo::len s))))
                                                        (eo::cons str.++ (eo::extract s 0 (eo::add sp -1))
                                                        (eo::cons str.++ t
                                                          ($str_eval_replace_re_all_rec snext r t ($str_first_match snext r))))))
  )
)

; define: $str_eval_replace_re_all
; args:
; - s String: A string.
; - r RegLan: A regular expression.
; - t String: A string to replace with.
; return: >
;   The result of evaluating (str.replace_re_all s r t).
(define $str_eval_replace_re_all ((s String) (r RegLan) (t String))
  (eo::define ((rnemp (re.inter r (re.comp (str.to_re ""))))) ; looking for non-empty matches
  ($singleton_elim ($str_eval_replace_re_all_rec s rnemp t ($str_first_match s rnemp)))))

; rule: str-replace-re-all-eval
; implements: ProofRewriteRule::STR_REPLACE_RE_ALL_EVAL
; args:
; - eq Bool: The equality between a replace_re_all term and a string.
; requires: >
;   Evaluating the left hand side gives the right hand side.
; conclusion: The given equality.
(declare-rule str-replace-re-all-eval ((s String) (r RegLan) (t String) (u String))
  :args ((= (str.replace_re_all s r t) u))
  :requires ((($str_eval_replace_re_all s r t) u))
  :conclusion (= (str.replace_re_all s r t) u)
)
