(include "../theories/Datatypes.eo")



(program $mk_dt_split_rec ((D Type) (x D) (T Type) (c T) (xs eo::List :list))
  (eo::List D) Bool
  (
    (($mk_dt_split_rec eo::List::nil x)          false)
    (($mk_dt_split_rec (eo::List::cons c xs) x)  (eo::cons or (is c x) ($mk_dt_split_rec xs x)))
  )
)

(program $mk_dt_split ((D Type) (x D) (T1 Type) (T2 Type :list) (DC (-> Type Type)))
  (Type D) Bool
  (
    (($mk_dt_split (Tuple T1 T2) x) (is-tuple x))
    (($mk_dt_split UnitTuple x)     (is-tuple x))
    (($mk_dt_split (DC T1) x)       ($mk_dt_split DC x))  ; parameteric datatypes, traverse
    (($mk_dt_split D x)             ($mk_dt_split_rec (eo::dt_constructors D) x)) ; user-defined datatypes
  )
)

(declare-rule dt_split ((D Type) (x D))
  :args (x)
  :conclusion ($singleton_elim ($mk_dt_split (eo::typeof x) x))
)

(program $mk_dt_inst_rec ((D Type) (x D) (T Type) (t T) (S Type) (s S) (xs eo::List :list))
  (eo::List D T) Bool
  (
    (($mk_dt_inst_rec eo::List::nil x t)          t)
    (($mk_dt_inst_rec (eo::List::cons s xs) x t)  ($mk_dt_inst_rec xs x (t (s x))))
  )
)

(program $mk_dt_inst_tuple_rec ((D Type) (x D) (T Type) (t T) (T1 Type) (T2 Type :list) (n Int))
  (Type D Int T) Bool
  (
    (($mk_dt_inst_tuple_rec UnitTuple x n t)     (t tuple.unit))
    (($mk_dt_inst_tuple_rec (Tuple T1 T2) x n t) ($mk_dt_inst_tuple_rec T2 x (eo::add n 1) (t (tuple.select n x))))
  )
)

(program $mk_dt_inst ((C Type) (D Type) (x D) (c C) (T1 Type) (T2 Type :list) (DC (-> Type Type)))
  (Type C D) Bool
  (
    (($mk_dt_inst (Tuple T1 T2) c x) ($mk_dt_inst_tuple_rec (Tuple T1 T2) x 0 c))
    (($mk_dt_inst UnitTuple c x)     tuple.unit)
    (($mk_dt_inst (DC T1) c x)       ($mk_dt_inst DC c x))  ; parameteric datatypes, traverse
    (($mk_dt_inst D c x)             ($mk_dt_inst_rec (eo::dt_selectors c) x c)) ; user-defined datatypes
  )
)

(declare-rule dt-inst ((D Type) (T Type) (c T) (x D) (t T))
  :args ((= (is c x) (= x t)))
  :requires ((($mk_dt_inst (eo::typeof x) c x) t))
  :conclusion (= (is c x) (= x t))
)
