(include "../theories/Builtin.eo")
(include "../theories/Ints.eo")
(include "../programs/Nary.eo")

; rule: split
; implements: ProofRule::SPLIT.
; args:
; - F Bool: The formula to split on.
; conclusion: The split of F, which the disjunction of F and its negation.
(declare-rule split ((F Bool))
    :args (F)
    :conclusion (or F (not F))
)

; program: $to_clause
; args:
; - F Bool: The formula to convert to a clause.
; return: >
;   The result of converting F to a clause. In particular, if F is not
;   an or-list, we return (or F), otherwise F is unchanged.
(program $to_clause ((F1 Bool) (F2 Bool :list))
  :signature (Bool) Bool
  (
    (($to_clause (or F1 F2)) (or F1 F2))
    (($to_clause false)      false)
    (($to_clause F1)         (or F1))
  )
)

; program: $from_clause
; args:
;- F Bool: >
;   The clause to convert to a normal formula (i.e. one that is
;   not a singleton or-list).
; return: >
;   The result of converting F to a normal formula. In particular, if F
;   is (or F), we return F, otherwise F is unchanged.
(program $from_clause ((F1 Bool) (F2 Bool :list))
  :signature (Bool) Bool
  (
    (($from_clause (or F1 F2)) (eo::ite (eo::eq F2 false) F1 (or F1 F2)))
    (($from_clause F1)         F1)
  )
)

; define: $remove_maybe_self
; args:
; - l Bool: The literal to remove.
; - c Bool: The clause (i.e. or-list) to remove from.
; return: >
;   The result of removing l from C, where additionally if C itself is
;   l, then we return the empty or-list false.
(define $remove_maybe_self ((l Bool) (C Bool))
  (eo::ite (eo::eq l C) false (eo::list_erase or C l)))

; define: $resolve
; args:
; - C1 Bool: The first formula in the resolution step.
; - C2 Bool: The second formula in the resolution step.
; - pol Bool: >
;   The polarity (true of false) of the literal L in C1. Its
;   negation must appear in C2.
; - L Bool: The pivot of the resolution step.
; return: >
;   The result of simple resolution of C1 and C2 with pivot L of polarity
;   pol. To compute this, we first convert C1 and C2 to or-lists. We then ensure
;   that L is removed with the appropriate polarity in both clauses. We then
;   concatentate the results, converting back to a unit formula if necessary.
(define $resolve ((C1 Bool) (C2 Bool) (pol Bool) (L Bool))
    (eo::define ((lp (eo::ite pol L (not L))))
    (eo::define ((ln (eo::ite pol (not L) L)))
        ($from_clause (eo::list_concat or
            ($remove_maybe_self lp ($to_clause C1))
            ($remove_maybe_self ln ($to_clause C2))))))
)

; rule: resolution
; implements: ProofRule::RESOLUTION.
; premises:
; - C1: The first formula in the resolution step.
; - C2: The second formula in the resolution step.
; args:
; - pol Bool: >
;   The polarity (true of false) of the literal L in C1. Its
;   negation must appear in C2.
; - L Bool: The pivot of the resolution step.
; conclusion: >
;   The result of simple resolution of C1 and C2 with pivot L of
;   polarity pol.
(declare-rule resolution ((C1 Bool) (C2 Bool) (pol Bool) (L Bool))
    :premises (C1 C2)
    :args (pol L)
    :conclusion ($resolve C1 C2 pol L)
)

; program: $chain_m_resolve_rec_step
; args:
; - p (@Pair Bool Bool): >
;   A pair corresponding to the partial result of chain resolution, which is a
;   resultant clause and a list of (positive) pivots to remove.
; - Cc Bool: The current clause to process.
; - pol Bool: The current polarity of the pivot.
; - L Bool: The pivot literal.
; return: >
;   A pair corresponding to the result of chain resolution for the clauses in C for
;   the given pivots and a list of (positive) pivots to remove in prior clauses.
(program $chain_m_resolve_rec_step ((Cr Bool) (Cc Bool) (rl Bool :list) (pol Bool) (L Bool))
  :signature ((@Pair Bool Bool) Bool Bool Bool) (@Pair Bool Bool)
  (
  (($chain_m_resolve_rec_step (@pair Cr rl) Cc pol L)
    (eo::define ((lp (eo::ite pol L (not L))))
    (eo::define ((ln (eo::ite pol (not L) L)))
    (eo::define ((rln (or ln rl)))
    (eo::define ((rlp (or lp rl)))
      ; if the clause is not a unit literal to remove
      (eo::ite (eo::eq ln Cc)
        (@pair Cr rlp)
        ; concatenate the result of removing the negative pivot and all further positive pivots
        (@pair (eo::list_concat or (eo::list_diff or Cc rln) Cr) rlp)))))))
  )
)

; program: $chain_m_resolve_rec
; args:
; - C Bool: A conjunction of clauses.
; - pols @List: >
;   The list of polarities of the remaining resolution steps.
;   This is a list of Booleans values of the same length as C.
; - lits @List: >
;   The list of pivots of the remaining resolution steps.
;   This is a list of Boolean terms of the same length as pols.
; return: >
;   A pair corresponding to the result of chain resolution for the clauses in C for
;   the given pivots and a list of (positive) pivots to remove in prior clauses.
(program $chain_m_resolve_rec ((C1 Bool) (C2 Bool) (Cs Bool :list) (pol Bool) (pols @List :list) (L Bool) (lits @List :list))
  :signature (Bool @List @List) (@Pair Bool Bool)
  (
  (($chain_m_resolve_rec true @list.nil @list.nil)  (@pair false false))
  (($chain_m_resolve_rec (and C1 Cs) (@list pol pols) (@list L lits))
     ($chain_m_resolve_rec_step ($chain_m_resolve_rec Cs pols lits) C1 pol L))
  )
)

; program: $chain_m_resolve_final
; args:
; - C1 Bool: The leftmost clause.
; - p (@Pair Bool Bool): >
;   A pair corresponding to a partial result of chain resolution, which is a
;   resultant clause and a list of (positive) pivots to remove.
; return: The result of chain resolution for C1 given p.
(program $chain_m_resolve_final ((C1 Bool) (C2 Bool) (rl Bool :list) (L Bool))
  :signature (Bool (@Pair Bool Bool)) Bool
  (
  (($chain_m_resolve_final C1 (@pair C2 (or L rl)))
    (eo::ite (eo::eq C1 L)
      C2
      (eo::list_concat or (eo::list_diff or C1 (or L rl)) C2)))
  )
)

; program: $chain_m_resolve
; args:
; - C Bool: A conjunction of clauses.
; - pols @List: >
;   The list of polarities of the remaining resolution steps.
;   This is a list of Booleans values.
; - lits @List: >
;   The list of pivots of the remaining resolution steps.
;   This is a list of Boolean terms of the same length as pols.
; return: The result of chain resolution for the clauses in C for the given pivots.
; note: >
;   This side condition uses an optimization that positive pivots are
;   accumulated in reverse order and are removed in batch from clauses that
;   occur earlier in the chain of resolution steps.
(program $chain_m_resolve ((C1 Bool) (C2 Bool :list) (pols @List :list) (lits @List :list))
  :signature (Bool @List @List) Bool
  (
  (($chain_m_resolve (and C1 C2) pols lits) ($chain_m_resolve_final C1 ($chain_m_resolve_rec C2 pols lits)))
  )
)

; rule: chain_resolution
; implements: ProofRule::CHAIN_RESOLUTION.
; premises:
; - Cs [:list]: >
;   The premises of the chain resolution step, collected as
;   a conjunction. The first is taken as the left resolvent, and the remaining
;   are taken as the right resolvents, to be resolved in order.
; args:
; - pols @List: >
;   The list of polarities of the remaining resolution steps.
;   This is a list of Booleans values.
; - lits @List: >
;   The list of pivots of the remaining resolution steps.
;   This is a list of Boolean terms of the same length as pols.
; conclusion: >
;   The result of the chain resolution of the premises clauses for
;   the given polarities and pivots.
(declare-rule chain_resolution ((C Bool) (pols @List) (lits @List))
    :premise-list C and
    :args (pols lits)
    :conclusion ($from_clause ($chain_m_resolve C pols lits))
)

; rule: chain_m_resolution
; implements: ProofRule::CHAIN_M_RESOLUTION.
; premises:
; - C [:list]: >
;   The premises of the chain resolution step, collected as
;   a conjunction. The first is taken as the left resolvent, and the remaining
;   are taken as the right resolvents, to be resolved in order.
; args:
; - Cr Bool: The desired conclusion.
; - pols @List: >
;   The list of polarities of the remaining resolution steps.
;   This is a list of Booleans values.
; - lits @List: >
;   The list of pivots of the remaining resolution steps.
;   This is a list of Boolean terms of the same length as pols.
; requires: >
;   That the first argument is equivalent to, or includes all literals from the return of the chain resolution.
; conclusion: >
;   The conclusion given by the first argument.
(declare-rule chain_m_resolution ((C Bool) (pols @List) (lits @List) (Cr Bool))
    :premise-list C and
    :args (Cr pols lits)
    :requires (((eo::define ((Cc (eo::list_setof or ($chain_m_resolve C pols lits))))
                  (eo::ite (eo::eq ($from_clause Cc) Cr) true (eo::list_minclude or Cr Cc))) true))
    :conclusion Cr
)

; rule: factoring
; implements: ProofRule::FACTORING
; premises:
; - C: The clause to factor.
; conclusion: >
;   The result of factoring the literals of C based on the
;   $factor_literals routine.
(declare-rule factoring ((C Bool))
    :premises (C)
    :conclusion ($from_clause (eo::list_setof or C))
)

; rule: reordering
; implements: ProofRule::REORDERING
; premises:
; - C1: The clause to reorder.
; args:
; - C2 Bool: The desired reordered form of C1.
; requires: Showing that C1 can be reordered to obtain C2.
; conclusion: The desired clause C2.
; note: >
;   The implementation here checks only that C1 is a subset of C2, making the
;   rule sound. The internal proof checker in cvc5 ensures this rule is only
;   applied when C1 and C2 have exactly the same literals when considered as
;   a multiset.
(declare-rule reordering ((C1 Bool) (C2 Bool))
    :premises (C1)
    :args (C2)
    :requires (((eo::list_minclude or C1 C2) true))
    :conclusion C2
)

; rule: eq_resolve
; implements: ProofRule::EQ_RESOLVE
; premises:
; - F1: The formula to resolve on the left hand side of the equivalence.
; - G: The equivalence between F1 and another formula F2.
; conclusion: the formula F2.
(declare-rule eq_resolve ((F1 Bool) (F2 Bool))
    :premises (F1 (= F1 F2))
    :conclusion F2
)

; rule: modus_ponens
; implements: ProofRule::MODUS_PONENS
; premises:
; - F1: The formula to resolve on the left hand side of the implication.
; - G: The implication between F1 and another formula F2.
; conclusion: the formula F2.
(declare-rule modus_ponens ((F1 Bool) (F2 Bool))
    :premises (F1 (=> F1 F2))
    :conclusion F2
)

; rule: not_not_elim
; implements: ProofRule::NOT_NOT_ELIM
; premises:
; - F1: The application of a double negation.
; conclusion: The formula that F1 is the double negation of.
(declare-rule not_not_elim ((F Bool))
    :premises ((not (not F)))
    :conclusion F
)

; rule: contra
; implements: ProofRule::CONTRA
; premises:
; - F1: A formula.
; - F2: The negation of F1.
; conclusion: false.
(declare-rule contra ((F Bool))
    :premises (F (not F))
    :conclusion false
)

; rule: and_elim
; implements: ProofRule::AND_ELIM
; premises:
; - Fs [:list]: The formula to process.
; args:
; - i Int: The child index of t to process.
; conclusion: The i^th child of Fs.
(declare-rule and_elim ((Fs Bool) (i Int))
    :premises (Fs)
    :args (i)
    :conclusion (eo::list_nth and Fs i)
)

; rule: and_intro
; implements: ProofRule::AND_INTRO
; premises:
; - Fs [:list]: The premises of this rule, collected as an and-list.
; conclusion: The result of collecting the premises as an and-list.
(declare-rule and_intro ((F Bool))
    :premise-list F and
    :conclusion F
)

; rule: not_or_elim
; implements: ProofRule::NOT_OR_ELIM
; premises:
; - F Bool: The formula to process, which should be the negation of an or-list Fs.
; args:
; - i Int: The child index of Fs to process.
; conclusion: the negation of the i^th child of the or-list Fs.
(declare-rule not_or_elim ((Fs Bool) (i Int))
    :premises ((not Fs))
    :args (i)
    :conclusion (not (eo::list_nth or Fs i))
)

; rule: implies_elim
; implements: ProofRule::IMPLIES_ELIM
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule implies_elim ((F1 Bool) (F2 Bool))
    :premises ((=> F1 F2))
    :conclusion (or (not F1) F2)
)

; rule: not_implies_elim1
; implements: ProofRule::NOT_IMPLIES_ELIM1
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule not_implies_elim1 ((F1 Bool) (F2 Bool))
    :premises ((not (=> F1 F2)))
    :conclusion F1
)

; rule: not_implies_elim2
; implements: ProofRule::NOT_IMPLIES_ELIM2
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule not_implies_elim2 ((F1 Bool) (F2 Bool))
    :premises ((not (=> F1 F2)))
    :conclusion (not F2)
)

; rule: equiv_elim1
; implements: ProofRule::EQUIV_ELIM1
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule equiv_elim1 ((F1 Bool) (F2 Bool))
    :premises ((= F1 F2))
    :conclusion (or (not F1) F2)
)

; rule: equiv_elim2
; implements: ProofRule::EQUIV_ELIM2
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule equiv_elim2 ((F1 Bool) (F2 Bool))
    :premises ((= F1 F2))
    :conclusion (or F1 (not F2))
)

; rule: not_equiv_elim1
; implements: ProofRule::NOT_EQUIV_ELIM1
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule not_equiv_elim1 ((F1 Bool) (F2 Bool))
    :premises ((not (= F1 F2)))
    :conclusion (or F1 F2)
)

; rule: not_equiv_elim2
; implements: ProofRule::NOT_EQUIV_ELIM2
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule not_equiv_elim2 ((F1 Bool) (F2 Bool))
    :premises ((not (= F1 F2)))
    :conclusion (or (not F1) (not F2))
)

; rule: xor_elim1
; implements: ProofRule::XOR_ELIM1
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule xor_elim1 ((F1 Bool) (F2 Bool))
    :premises ((xor F1 F2))
    :conclusion (or F1 F2)
)

; rule: xor_elim2
; implements: ProofRule::XOR_ELIM2
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule xor_elim2 ((F1 Bool) (F2 Bool))
    :premises ((xor F1 F2))
    :conclusion (or (not F1) (not F2))
)

; rule: not_xor_elim1
; implements: ProofRule::NOT_XOR_ELIM1
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule not_xor_elim1 ((F1 Bool) (F2 Bool))
    :premises ((not (xor F1 F2)))
    :conclusion (or F1 (not F2))
)

; rule: not_xor_elim2
; implements: ProofRule::NOT_XOR_ELIM2
; premises:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule not_xor_elim2 ((F1 Bool) (F2 Bool))
    :premises ((not (xor F1 F2)))
    :conclusion (or (not F1) F2)
)

; rule: ite_elim1
; implements: ProofRule::ITE_ELIM1
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule ite_elim1 ((C Bool) (F1 Bool) (F2 Bool))
    :premises ((ite C F1 F2))
    :conclusion (or (not C) F1)
)

; rule: ite_elim2
; implements: ProofRule::ITE_ELIM2
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule ite_elim2 ((C Bool) (F1 Bool) (F2 Bool))
    :premises ((ite C F1 F2))
    :conclusion (or C F2)
)

; rule: not_ite_elim1
; implements: ProofRule::NOT_ITE_ELIM1
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule not_ite_elim1 ((C Bool) (F1 Bool) (F2 Bool))
    :premises ((not (ite C F1 F2)))
    :conclusion (or (not C) (not F1))
)

; rule: not_ite_elim2
; implements: ProofRule::NOT_ITE_ELIM2
; premises:
; - F: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule not_ite_elim2 ((C Bool) (F1 Bool) (F2 Bool))
    :premises ((not (ite C F1 F2)))
    :conclusion (or C (not F2))
)

; program: $lower_not_and
; args:
;- F Bool: The formula to process, which should be an and-list.
; return: >
;   the result of negating F by turning it into a disjunction. For
;   example, we return (or (not l1) ... (not ln)) given input (and l1 .. ln).
(program $lower_not_and ((l Bool) (ls Bool :list))
    :signature (Bool) Bool
    (
        (($lower_not_and true)       false) ; Terminator changes
        (($lower_not_and (and l ls)) (eo::cons or (not l) ($lower_not_and ls)))
    )
)

; rule: not_and
; implements: ProofRule::NOT_AND
; premises:
; - F: The formula to process, which should be the negation of an and-list.
; conclusion: The result of converting F to a disjunction.
(declare-rule not_and ((F Bool))
    :premises ((not F))
    :conclusion ($lower_not_and F)
)

; rule: cnf_and_pos
; implements: ProofRule::CNF_AND_POS
; args:
; - t Bool: The formula to process, which should be an and-list.
; - i : Int. The child index to process.
; conclusion: >
;   A clause corresponding to one of the cases of converting t to CNF
;   involving i^th child of t.
(declare-rule cnf_and_pos ((Fs Bool) (i Int))
    :args (Fs i)
    :conclusion (or (not Fs) (eo::list_nth and Fs i))
)

; rule: cnf_and_neg
; implements: ProofRule::CNF_AND_NEG
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_and_neg ((Fs Bool))
    :args (Fs)
    :conclusion (eo::cons or Fs ($lower_not_and Fs))
)

; rule: cnf_or_pos
; implements: ProofRule::CNF_OR_POS
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_or_pos ((Fs Bool :list))
    :args (Fs)
    :conclusion (or (not Fs) Fs)
)

; rule: cnf_or_neg
; implements: ProofRule::CNF_OR_NEG
; args:
; - t Bool: The formula to process, which should be an or-list.
; - i : Int. The child index to process.
; conclusion:
;   A clause corresponding to one of the cases of converting t to CNF
;   involving i^th child of t.
(declare-rule cnf_or_neg ((Fs Bool) (i Int))
    :args (Fs i)
    :conclusion (or Fs (not (eo::list_nth or Fs i)))
)

; rule: cnf_implies_pos
; implements: ProofRule::CNF_IMPLIES_POS
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_implies_pos ((F1 Bool) (F2 Bool))
    :args ((=> F1 F2))
    :conclusion (or (not (=> F1 F2)) (not F1) F2)
)

; rule: cnf_implies_neg1
; implements: ProofRule::CNF_IMPLIES_NEG1
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_implies_neg1 ((F1 Bool) (F2 Bool))
    :args ((=> F1 F2))
    :conclusion (or (=> F1 F2) F1)
)

; rule: cnf_implies_neg2
; implements: ProofRule::CNF_IMPLIES_NEG2
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_implies_neg2 ((F1 Bool) (F2 Bool))
    :args ((=> F1 F2))
    :conclusion (or (=> F1 F2) (not F2))
)

; rule: cnf_equiv_pos1
; implements: ProofRule::CNF_EQUIV_POS1
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_equiv_pos1 ((F1 Bool) (F2 Bool))
    :args ((= F1 F2))
    :conclusion (or (not (= F1 F2)) (not F1) F2)
)

; rule: cnf_equiv_pos2
; implements: ProofRule::CNF_EQUIV_POS2
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_equiv_pos2 ((F1 Bool) (F2 Bool))
    :args ((= F1 F2))
    :conclusion (or (not (= F1 F2)) F1 (not F2))
)

; rule: cnf_equiv_neg1
; implements: ProofRule::CNF_EQUIV_NEG1
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_equiv_neg1 ((F1 Bool) (F2 Bool))
    :args ((= F1 F2))
    :conclusion (or (= F1 F2) F1 F2)
)

; rule: cnf_equiv_neg2
; implements: ProofRule::CNF_EQUIV_NEG2
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_equiv_neg2 ((F1 Bool) (F2 Bool))
    :args ((= F1 F2))
    :conclusion (or (= F1 F2) (not F1) (not F2))
)

; rule: cnf_xor_pos1
; implements: ProofRule::CNF_XOR_POS1
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_xor_pos1 ((F1 Bool) (F2 Bool))
    :args ((xor F1 F2))
    :conclusion (or (not (xor F1 F2)) F1 F2)
)

; rule: cnf_xor_pos2
; implements: ProofRule::CNF_XOR_POS2
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_xor_pos2 ((F1 Bool) (F2 Bool))
    :args ((xor F1 F2))
    :conclusion (or (not (xor F1 F2)) (not F1) (not F2))
)

; rule: cnf_xor_neg1
; implements: ProofRule::CNF_XOR_NEG1
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_xor_neg1 ((F1 Bool) (F2 Bool))
    :args ((xor F1 F2))
    :conclusion (or (xor F1 F2) (not F1) F2)
)

; rule: cnf_xor_neg2
; implements: ProofRule::CNF_XOR_NEG2
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_xor_neg2 ((F1 Bool) (F2 Bool))
    :args ((xor F1 F2))
    :conclusion (or (xor F1 F2) F1 (not F2))
)

; rule: cnf_ite_pos1
; implements: ProofRule::CNF_ITE_POS1
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_ite_pos1 ((C Bool) (F1 Bool) (F2 Bool))
    :args ((ite C F1 F2))
    :conclusion (or (not (ite C F1 F2)) (not C) F1)
)

; rule: cnf_ite_pos2
; implements: ProofRule::CNF_ITE_POS2
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_ite_pos2 ((C Bool) (F1 Bool) (F2 Bool))
    :args ((ite C F1 F2))
    :conclusion (or (not (ite C F1 F2)) C F2)
)

; rule: cnf_ite_pos3
; implements: ProofRule::CNF_ITE_POS3
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_ite_pos3 ((C Bool) (F1 Bool) (F2 Bool))
    :args ((ite C F1 F2))
    :conclusion (or (not (ite C F1 F2)) F1 F2)
)

; rule: cnf_ite_neg1
; implements: ProofRule::CNF_ITE_NEG1
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_ite_neg1 ((C Bool) (F1 Bool) (F2 Bool))
    :args ((ite C F1 F2))
    :conclusion (or (ite C F1 F2) (not C) (not F1))
)

; rule: cnf_ite_neg2
; implements: ProofRule::CNF_ITE_NEG2
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_ite_neg2 ((C Bool) (F1 Bool) (F2 Bool))
    :args ((ite C F1 F2))
    :conclusion (or (ite C F1 F2) C (not F2))
)

; rule: cnf_ite_neg3
; implements: ProofRule::CNF_ITE_NEG3
; args:
; - F Bool: The formula to process.
; conclusion: A clause corresponding to one of the cases of converting t to CNF.
(declare-rule cnf_ite_neg3 ((C Bool) (F1 Bool) (F2 Bool))
    :args ((ite C F1 F2))
    :conclusion (or (ite C F1 F2) (not F1) (not F2))
)
