(include "../programs/Quantifiers.eo")
(include "../theories/Quantifiers.eo")


; rule: instantiate
; implements: ProofRule::INSTANTIATE.
; premises:
; - Q Bool: The quantified formula to instantiate.
; args:
; - ts @List: The list of terms to instantiate with.
; conclusion: The result of substituting free occurrences of xs in F with ts.
(declare-rule instantiate ((F Bool) (xs @List) (ts @List))
  :premises ((forall xs F))
  :args (ts)
  :conclusion ($substitute_list xs ts F))

; program: $mk_skolems
; args:
; - arg1 @List: The bound variable list to process.
; - arg2 Bool: The body of the quantified formula. This impacts the definition of the introduced skolems.
; - arg3 Int: The number of indices we have already processed in arg1.
; return: >
;   The list of skolem variables for the quantified formula whose bound variable list
;   is arg1 and whose body is arg2.
(program $mk_skolems ((x @List) (xs @List :list) (F Bool) (i Int))
  (@List Bool Int) @List
  (
    (($mk_skolems (@list x xs) F i) (eo::cons @list (@quantifiers_skolemize F i) ($mk_skolems xs F (eo::add i 1))))
    (($mk_skolems @list.nil F i)    @list.nil)
  )
)

; rule: skolemize
; implements: ProofRule::SKOLEMIZE.
; premises:
; - Q Bool: The quantified formula to skolemize. This is either an existential or a negated universal.
; conclusion: >
;   The skolemized body of Q, where its variables are replaced by skolems
;   introduced via $mk_skolems.
(declare-rule skolemize ((x @List) (G Bool))
  :premises ((not (forall x G)))
  :conclusion ($substitute_list x ($mk_skolems x (forall x G) 0) (not G))
)

; rule: skolem_intro
; implements: ProofRule::SKOLEM_INTRO.
; args:
; - t T: The purification skolem.
; conclusion: >
;   An equality equating t to its original form. This indicates that
;   the purification skolem for any term x can be assumed to be equal to x.
(declare-rule skolem_intro ((T Type) (x T))
  :args ((@purify x))
  :conclusion (= (@purify x) x)
)

; rule: alpha_equiv
; implements: ProofRule::ALPHA_EQUIV.
; args:
; - B Bool: The formula to apply to alpha equivalence to.
; - vs @List: The list of variables to substitute from.
; - ts @List: The list of (renamed) variables to substitute into.
; requires: B does not contain any occurence of the range variables ts.
; conclusion: >
;   The result of applying the substitution specified by vs and ts to
;   B. The substitution is valid renaming due to the requirement check.
(declare-rule alpha_equiv ((B Bool) (vs @List) (ts @List))
  :args (B vs ts)
  :requires ((($contains_subterm_list B ts) false))
  :conclusion (= B ($substitute_list vs ts B))
)

; rule: beta_reduce implements ProofRewriteRule::BETA_REDUCE
; args:
; - eq : Bool. The equality to prove between terms a and b.
; requires: Showing that a beta-reduces to b.
; conclusion: The given equality.
(declare-rule beta-reduce ((T Type) (a T) (b T))
  :args ((= a b))
  :requires ((($beta_reduce a @list.nil) b))
  :conclusion (= a b)
)

; rule: quant_var_reordering
; implements: ProofRule::QUANT_VAR_REORDERING
; premises:
; - C1: The clause to reorder.
; args:
; - C2 Bool: The desired reordered form of C1.
; requires: Showing that C1 can be reordered to obtain C2.
; conclusion: The desired clause C2.
(declare-rule quant_var_reordering ((x @List) (y @List) (F Bool))
    :args ((= (forall x F) (forall y F)))
    :requires ((($nary_is_eq_set @list @list.nil x y) true))
    :conclusion (= (forall x F) (forall y F))
)
;;;;; ProofRewriteRule::QUANT_MINISCOPE_FV

; program: $is_quant_miniscope_fv_var
; args:
; - x T: The variable.
; - G Bool: The formula in question, which is expected to be a disjunction.
; - b Bool: True if and only if we have seen x in a disjunct so far.
; return: >
;   True if and only if v is bound by at most one disjunct in G if b is false
;   or bound by none if b is true, and v does not occur freely in the other
;   disjuncts of G.
(program $is_quant_miniscope_fv_var ((T Type) (x T) (xs @List :list) (g Bool) (gs Bool :list) (b Bool))
  (T Bool Bool) Bool
  (
  (($is_quant_miniscope_fv_var x (or g gs) b)   (eo::ite ($is_quant_bound x g)
                                                  (eo::ite b
                                                    false ; already bound by another disjunct
                                                    ($is_quant_miniscope_fv_var x gs true))
                                                  (eo::ite ($contains_subterm g x)
                                                    false ; occurs free in this disjunct
                                                    ($is_quant_miniscope_fv_var x gs b))))
  (($is_quant_miniscope_fv_var x false b)       true)
  )
)

; program: $is_quant_miniscope_fv_var_list
; args:
; - L @List: The list of variables.
; - G Bool: The formula in question, which is expected to be a disjunction.
; return: >
;   True if and only if each variable in L is bound by at most one disjunct in
;   G and does not occur freely in the others.
(program $is_quant_miniscope_fv_var_list ((T Type) (x T) (xs @List :list) (G Bool))
  (@List Bool) Bool
  (
  (($is_quant_miniscope_fv_var_list (@list x xs) G) (eo::ite ($is_quant_miniscope_fv_var x G false)
                                                      ($is_quant_miniscope_fv_var_list xs G)
                                                      false))
  (($is_quant_miniscope_fv_var_list @list.nil G) true)
  )
)

; program: $is_quant_miniscope_fv_body
; args:
; - F Bool: The first formula in question.
; - G Bool: The second formula in question.
; return: >
;    True if and only if each disjunct if F is equal to the corresponding
;    disjunct in G, modulo possible quantification in G.
(program $is_quant_miniscope_fv_body ((f Bool) (fs Bool :list) (g Bool) (gs Bool :list))
  (Bool Bool) Bool
  (
  (($is_quant_miniscope_fv_body (or f fs) (or f gs))  ($is_quant_miniscope_fv_body fs gs))
  (($is_quant_miniscope_fv_body (or f fs) (or g gs))  (eo::ite ($is_quant_body f g)
                                                        ($is_quant_miniscope_fv_body fs gs)
                                                        false))
  (($is_quant_miniscope_fv_body false false)          true)
  (($is_quant_miniscope_fv_body f g)                  false)
  )
)

; rule: quant-miniscope-fv
; implements: ProofRewriteRule::QUANT_MINISCOPE_FV
; args:
; - eq Bool: The equality whose left hand side a quantified formula.
; requires: >
;   The right hand side of the equality is the result of miniscoping the left
;   hand side. This check is divided into two parts, checking that the variables
;   are bound by exactly one disjunct, and that the disjuncts of F and G align
;   modulo quantification.
; conclusion: The given equality.
(declare-rule quant-miniscope-fv ((x @List) (F Bool) (G Bool))
  :args ((= (forall x F) G))
  :requires ((($is_quant_miniscope_fv_var_list x G) true) (($is_quant_miniscope_fv_body F G) true))
  :conclusion (= (forall x F) G)
)
