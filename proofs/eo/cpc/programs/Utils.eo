; define: $compare_geq
; args:
; - x T: The first term to compare.
; - y T: The second term to compare.
; return: true if x >= y, where x and y are assumed to be arithmetic values.
(define $compare_geq ((T Type :implicit) (x T) (y T))
  (eo::ite (eo::is_eq x y) true (eo::gt x y)))

; define: $sgn
; args:
; - x T: The term to inspect. Assumed to be an arithmetic value.
; return: The sign of x: -1 if x < 0, 1 if x > 0, and 0 otherwise.
(define $sgn ((T Type :implicit) (x T))
  (eo::ite (eo::is_neg x) -1 (eo::ite (eo::is_neg (eo::neg x)) 1 0)))

(declare-type @Pair (Type Type))
(declare-const @pair (-> (! Type :var U :implicit) (! Type :var T :implicit) U T (@Pair U T)))

; untyped list
(declare-type @List ())
(declare-const @list.nil @List)
(declare-const @list (-> (! Type :var T :implicit) T @List @List) :right-assoc-nil @list.nil)

; note: This is a forward declaration of $evaluate_list defined in Cpc.eo.
(program $evaluate_list () (@List) @List)

; define: $evaluate
; args:
; - t S: The term to evaluate.
; return: The result of evaluating t.
; note: >
;   This method is defined in terms of the forward declaration $evaluate_list here.
;   The implementation of this method depends on defining the evaluation for all
;   theories and thus is contained in Cpc.eo.
(define $evaluate ((T Type :implicit) (t T)) (eo::list_nth @list ($evaluate_list (@list t)) 0))

; program: $get_fun
; args:
; - t S: The term to inspect.
; return: >
;   The function at the head of the application of t, or t itself if it is not
;   an application.
(program $get_fun ((T Type) (S Type) (U Type) (f (-> T S)) (x T) (y S))
  (S) U
  (
    (($get_fun (f x))  ($get_fun f))
    (($get_fun y)      y)
  )
)

; program: $get_arg_list_rec
; args:
; - t S: The term to inspect.
; - acc @List: The accumulator storing the arguments we have seen so far.
; return: >
;   The list of arguments provided to the function at the head of t appended to
;   acc, or acc if t is not a function application.
(program $get_arg_list_rec ((T Type) (S Type) (f (-> T S)) (x T) (y S) (acc @List))
  (S @List) @List
  (
    (($get_arg_list_rec (f x) acc)  ($get_arg_list_rec f (eo::cons @list x acc)))
    (($get_arg_list_rec y acc)      acc)
  )
)

; define: $get_arg_list
; args:
; - t T: The term to inspect.
; return: >
;   The list of arguments provided to the function at the head of t, or the nil
;   list if t is not a function application.
(define $get_arg_list ((T Type :implicit) (t T)) ($get_arg_list_rec t @list.nil))

; program: $is_app
; args:
; - f (-> T U): The function.
; - t S: The term to inspect.
; return: True if and only if t is an application of f.
(program $is_app ((T Type) (S Type) (U Type) (f (-> T U)) (g (-> T S)) (x T) (y S))
  ((-> T U) S) Bool
  (
    (($is_app f (g x))  ($is_app f g))
    (($is_app f x)      (eo::is_eq f x))
  )
)

; define: $compare_var
; args:
; - a T: The first term to compare.
; - b U: The second term to compare.
; return: true if a should be considered before b in an ordering where a and b are considered to be atomic variables.
; note: >
;   This method is used to have a canonical ordering of variables.
;   It could potentially be improved by having a builtin operator, e.g. eo::compare.
;   The variable ordering always returns true for the variable with the lower
;   hash. This leads to best case performance if sorting a term with distinct
;   children, where if we ask for the hash of the children in order and prefer
;   the ones where this compare returns true, then the term remains unchanged.
(define $compare_var ((T Type :implicit) (U Type :implicit) (a T) (b U))
  (eo::cmp b a))

; define: $head
; args:
; - x S: The term to inspect.
; return: >
;   The head of x, where x is expected to be an application of an n-ary
;   function marked :right-assoc-nil.
; return: the head of x, where x is expected to be a function application.
(define $head ((S Type :implicit) (x S))
  (eo::match ((T Type) (U Type) (f (-> T U U)) (x1 T) (x2 U :list))
    x
    (((f x1 x2) x1)))
)

; define: $tail
; args:
; - x S: The term to inspect.
; return: >
;   The tail of x, where x is expected to be an application of an n-ary
;   function marked :right-assoc-nil.
(define $tail ((U Type :implicit) (x U))
  (eo::match ((T Type) (U Type) (f (-> T U U)) (x1 T) (x2 U :list))
    x
    (((f x1 x2) x2)))
)

; program: $singleton_elim
; args:
; - s S: The term to proces.
; return: >
;   The result of applying singleton elimination for s. In particular,
;   if s is of the form (f x1 x2) where x2 is the nil terminator of f, then we
;   return x1. Otherwise, we return s unchanged.
(program $singleton_elim ((T Type) (S Type) (U Type) (f (-> T U S)) (x S) (x1 T) (x2 T :list))
  (S) S
  (
    (($singleton_elim (f x1 x2))  (eo::ite (eo::is_eq x2 (eo::nil f x1 x2)) x1 (f x1 x2)))
    (($singleton_elim x)          x)
  )
)

;; =============== for results

; Used for representing partial results of the method below.
(declare-const @result.null Bool)
(declare-const @result.invalid Bool)

; program: $result_combine
; args:
; - b1 Bool: The first Boolean result to combine.
; - b2 Bool: The second Boolean result to combine.
; return: >
;   The result of combining the two results if they agree, where @result.null
;   is treated as no result and @result.invalid is treated as an invalid result.
; note: >
;   In summary, ($result_combine b1 ... ($result_combine bn @result.null)) returns
;   b1 if b1...bn are the same or @result.invalid otherwise.
(program $result_combine ((b1 Bool) (b2 Bool))
  (Bool Bool) Bool
  (
    (($result_combine b1 @result.null) b1)
    (($result_combine b1 b1)           b1)
    (($result_combine b1 b2)           @result.invalid)
  )
)
;; =============== for pairwise

; program: $is_pairwise
; args:
; - f (-> T T U): The pairwise operator, e.g. distinct.
; - op (-> U U U): The combining operator, e.g. and for distinct.
; - a T: The current LHS element we are checking.
; - bs @List: The list of RHS elements that should be related to a next.
; - B U: The term that is potentially a pairwise application of f for the given elements.
; - rem @List: The list of elements we have yet to process on the LHS.
; return: True if B is a pairwise application of f for the given arguments.
(program $is_pairwise ((T Type) (U Type) (f (-> T T U)) (op (-> U U U)) (a T) (b T) (bs T :list) (B U :list) (nil U) (rem @List :list))
  ((-> T T U) (-> U U U) T @List U @List) Bool
  (
  (($is_pairwise f op a (@list b bs) (op (f a b) B) rem) ($is_pairwise f op a bs B rem))
  (($is_pairwise f op a @list.nil B (@list b rem))       ($is_pairwise f op b rem B rem))
  (($is_pairwise f op a @list.nil nil @list.nil)         (eo::requires nil (eo::nil op) true))
  )
)

; program: $extract_pairwise_args_rec
; args:
; - f (-> T T U): The pairwise operator, e.g. distinct.
; - op (-> U U U): The combining operator, e.g. and for distinct.
; - a T: The first LHS element.
; - B U: The term that is potentially a pairwise application of f starting with a.
; return: The list of arguments that a is related to.
(program $extract_pairwise_args_rec ((T Type) (U Type) (f (-> T T U)) (op (-> U U U)) (a T) (b T) (c T) (B U :list))
  ((-> T T U) (-> U U U) T U) @List
  (
  (($extract_pairwise_args_rec f op a (op (f a c) B)) (eo::cons @list c ($extract_pairwise_args_rec f op a B)))
  (($extract_pairwise_args_rec f op a B)              @list.nil)  ; no further elements
  )
)

; program: $extract_pairwise_args_rec
; args:
; - f (-> T T U): The pairwise operator, e.g. distinct.
; - op (-> U U U): The combining operator, e.g. and for distinct.
; - B U: The term that is potentially a pairwise application of f.
; return: The list of arguments that are the input to the pairwise application of f.
; note: >
;   This method is required since desugaring is applied at compile time. This
;   means to recognize whether a term originated from parsing e.g.
;   (distinct a b c) is non-trivial: it requires a scan to confirm that
;   its desugared version (and (distinct a b) (distinct a c) (distinct b c)) is
;   indeed obtained by desugaring distinct in the expected way.
(program $extract_pairwise_args ((T Type) (U Type) (f (-> T T U)) (op (-> U U U)) (a T) (b T) (B U :list))
  ((-> T T U) (-> U U U) U) @List
  (
  (($extract_pairwise_args f op (op (f a b) B)) (eo::define ((D (op (f a b) B)))
                                                (eo::define ((elems ($extract_pairwise_args_rec f op a D)))
                                                  (eo::requires ($is_pairwise f op a elems D elems) true (eo::cons @list a elems)))))
  (($extract_pairwise_args f op (f a b))        (@list a b)) ; binary case, trivial
  )
)
