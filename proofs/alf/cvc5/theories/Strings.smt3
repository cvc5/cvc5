(include "../theories/Builtin.smt3")
(include "../theories/Arith.smt3")

; The sequence type.
(declare-type Seq (Type))

(declare-type Char ())

; define: String
; return: >
;   The string type.
;   Note that string is treated as a sequence of characters in this signature.
;   This is only for the purposes of simplifying the type rules below.
;   Internally, cvc5 will never generate any proofs involving the Char type.
(define String () (Seq Char))

; The regular expression type.
(declare-type RegLan ())

; String literals are strings.
(declare-consts <string> String)

; Empty sequence
(declare-const seq.empty (-> (! Type :var T) T))

; program: mk_emptystr
; args:
; - U Type: The string-like type.
; return: The empty string of the given string-like sort U.
(program mk_emptystr ((U Type))
  (Type) U
  (
    ((mk_emptystr String)  "")
    ((mk_emptystr (Seq U)) (seq.empty (Seq U)))
  )
)

; Core functions of strings.
(declare-const str.len 
  (-> (! Type :var T :implicit)
      (Seq T) Int))
(declare-parameterized-const str.++ ((T Type))
  (-> (Seq T) (Seq T) (Seq T)) :right-assoc-nil (mk_emptystr (Seq T)))

; Extended functions for strings.
(declare-const str.substr (-> (! Type :var T :implicit)
                              (Seq T) Int Int (Seq T)))
(declare-const str.contains (-> (! Type :var T :implicit)
                                (Seq T) (Seq T) Bool))
(declare-const str.replace (-> (! Type :var T :implicit)
                               (Seq T) (Seq T) (Seq T) (Seq T)))
(declare-const str.indexof (-> (! Type :var T :implicit)
                               (Seq T) (Seq T) Int Int))
(declare-const str.at (-> (! Type :var T :implicit)
                          (Seq T) Int (Seq T)))
(declare-const str.prefixof (-> (! Type :var T :implicit)
                                (Seq T) (Seq T) Bool))
(declare-const str.suffixof (-> (! Type :var T :implicit)
                                (Seq T) (Seq T) Bool))
(declare-const str.rev (-> (! Type :var T :implicit)
                           (Seq T) (Seq T)))
(declare-const str.unit (-> Int String))
(declare-const str.update (-> (! Type :var T :implicit)
                              (Seq T) Int (Seq T) (Seq T)))
(declare-const str.to_lower (-> String String))
(declare-const str.to_upper (-> String String))
(declare-const str.to_code (-> String Int))
(declare-const str.from_code (-> Int String))
(declare-const str.is_digit (-> String Bool))
(declare-const str.to_int (-> String Int))
(declare-const str.from_int (-> Int String))
(declare-const str.< (-> String String Bool))
(declare-const str.<= (-> String String Bool))
(declare-const str.replace_all (-> (! Type :var T :implicit)
                                   (Seq T) (Seq T) (Seq T) (Seq T)))
(declare-const str.replace_re (-> String RegLan String String))
(declare-const str.replace_re_all (-> String RegLan String String))
(declare-const str.indexof_re (-> String RegLan Int Int))

; Regular expression operators.
(declare-const re.allchar RegLan)
(declare-const re.none RegLan)
(declare-const re.all RegLan)
(declare-const str.to_re (-> String RegLan))

; define: @re.empty
; return: The regular expression containing only the empty string.
(define @re.empty () (str.to_re ""))

(declare-const re.* (-> RegLan RegLan))
(declare-const re.+ (-> RegLan RegLan))
(declare-const re.opt (-> RegLan RegLan))
(declare-const re.comp (-> RegLan RegLan))
(declare-const re.range (-> String String RegLan))
(declare-const re.++ (-> RegLan RegLan RegLan) :right-assoc-nil @re.empty)
(declare-const re.inter (-> RegLan RegLan RegLan) :right-assoc-nil re.all)
(declare-const re.union (-> RegLan RegLan RegLan) :right-assoc-nil re.none)
(declare-const re.diff (-> RegLan RegLan RegLan))
(declare-const re.loop (-> Int Int RegLan RegLan))
(declare-const str.in_re (-> String RegLan Bool))

; Sequence-specific operators.
(declare-const seq.unit (-> (! Type :var T :implicit) T (Seq T)))
(declare-const seq.nth (-> (! Type :var T :implicit) (Seq T) Int (alf.ite (alf.is_eq T Char) Int T)))

; Sequence operators are automatically translated to the string operators.
(define seq.len () str.len)
(define seq.++ () str.++)
(define seq.extract () str.substr)
(define seq.contains () str.contains)
(define seq.replace () str.replace)
(define seq.indexof () str.indexof)
(define seq.prefixof () str.prefixof)
(define seq.suffixof () str.suffixof)
(define seq.rev () str.rev)
(define seq.update () str.update)
(define seq.at () str.at)

; Skolem functions for strings and sequences.

(declare-const @re_unfold_pos_component (-> (! String :opaque) (! RegLan :opaque) (! Int :opaque) String))
(declare-const @strings_deq_diff (-> (! Type :var T :implicit) (! (Seq T) :opaque) (! (Seq T) :opaque) Int))
(declare-const @strings_stoi_result (-> (! String :opaque) Int Int))
(declare-const @strings_stoi_non_digit (-> (! String :opaque) Int))
(declare-const @strings_itos_result (-> (! Int :opaque) Int Int))

(declare-const @strings_num_occur (-> (! Type :var T :implicit) (! (Seq T) :opaque) (! (Seq T) :opaque) Int))
(declare-const @strings_num_occur_re (-> (! String :opaque) (! RegLan :opaque) Int))
(declare-const @strings_occur_index (-> (! Type :var T :implicit) (! (Seq T) :opaque) (! (Seq T) :opaque) Int Int))
(declare-const @strings_occur_index_re (-> (! String :opaque) (! RegLan :opaque) Int Int))
(declare-const @strings_occur_len_re (-> (! String :opaque) (! RegLan :opaque) Int Int))

(declare-const @strings_replace_all_result (-> (! Type :var T :implicit) (! (Seq T) :opaque) Int (Seq T)))

(declare-const @re_first_match_pre (-> (! String :opaque) (! RegLan :opaque) String))
(declare-const @re_first_match (-> (! String :opaque) (! RegLan :opaque) String))
(declare-const @re_first_match_post (-> (! String :opaque) (! RegLan :opaque) String))


