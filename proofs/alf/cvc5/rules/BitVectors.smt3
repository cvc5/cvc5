(include "../programs/BitVectors.smt3")

; ---------------- ProofRewriteRule::BV_BITBLAST_STEP

; @program $bv_mk_bitblast_step_eq
; @arg arg1 : T. The left hand side of the equality.
; @arg arg2 : T. The right hand side of the equality.
; @return the bitblasted term for (= arg1 arg2).
(program $bv_mk_bitblast_step_eq ((T Type) (U Type) (W Type) (b1 Bool) (b2 Bool) (a1 W :list) (a2 W :list))
  (T T) Bool
  (
  (($bv_mk_bitblast_step_eq @bv_empty @bv_empty)        true)
  (($bv_mk_bitblast_step_eq (@bbT b1 a1) (@bbT b2 a2))  (alf.cons and (= b1 b2) ($bv_mk_bitblast_step_eq a1 a2)))
  )
)

; @define $bv_mk_bitblast_step_extract
; @arg u : Int. The upper index of the extract.
; @arg l : Int. The lower index of the extract.
; @arg a1 : (BitVec n). The argument of the extract.
; @return the bitblasted term for (extract u l a1).
(define $bv_mk_bitblast_step_extract ((n Int :implicit) (u Int) (l Int) (a1 (BitVec n)))
  (nary.subsequence @bbT @bv_empty l u a1))

; @program $bv_mk_bitblast_step_concat_rec
; @arg a : (BitVec n). The (reverse) of the bitvector concatenation term to
; process.
; @return the bitblasted term for concatenation term a, reversed.
(program $bv_mk_bitblast_step_concat_rec ((n Int) (a1 (BitVec n)) (m Int) (a2 (BitVec m) :list))
  ((BitVec n)) (BitVec n)
  (
  (($bv_mk_bitblast_step_concat_rec @bv_empty)      @bv_empty)
  (($bv_mk_bitblast_step_concat_rec (concat a1 a2)) (alf.list_concat @bbT a1 ($bv_mk_bitblast_step_concat_rec a2)))
  )
)

; @define $bv_mk_bitblast_step_concat
; @arg a : (BitVec n). The bitvector concatenation term to process.
; @return the bitblasted term for concatenation term a.
(define $bv_mk_bitblast_step_concat ((n Int :implicit) (a (BitVec n)))
  ($bv_mk_bitblast_step_concat_rec (nary.reverse a)))

; @define $bv_mk_bitblast_step_const
; @arg a : (BitVec n). The bitvector constant to bitblast.
; @return the bitblasted term for a, which is its reverse bitlist.
(define $bv_mk_bitblast_step_const ((n Int :implicit) (a (BitVec n)))
  (nary.reverse ($bv_const_to_bitlist a)))

; @program $bv_mk_bitblast_step_var_rec
; @arg a : (BitVec n). The bitvector variable to bitblast.
; @arg i : Int. The index of the bit we are currently processing.
; @return the bitblasted term for variable a.
(program $bv_mk_bitblast_step_var_rec ((n Int) (a (BitVec n)) (i Int))
  ((BitVec n) Int) (BitVec n)
  (
    (($bv_mk_bitblast_step_var_rec a -1)  @bv_empty)
    (($bv_mk_bitblast_step_var_rec a i)   (alf.cons @bbT (@bitOf i a) ($bv_mk_bitblast_step_var_rec a (alf.add i -1))))
  )
)

; @define $bv_mk_bitblast_step_var
; @arg a : (BitVec n). The bitvector variable to bitblast.
; @return the bitblasted term for variable a.
(define $bv_mk_bitblast_step_var ((n Int :implicit) (a (BitVec n)))
  (nary.reverse ($bv_mk_bitblast_step_var_rec a (alf.add ($bv_bitwidth (alf.typeof a)) -1))))

; @define $bv_mk_bitblast_step
; @arg a : T. The bitvector term or predicate to bitblast.
; @return the bitblasted term for a.
(define $bv_mk_bitblast_step ((T Type :implicit) (a T))
  (alf.match ((n Int) (a1 (BitVec n)) (a2 (BitVec n) :list) (u Int) (l Int) (m Int) (a3 (BitVec m) :list))
  a
  (
  ((= a1 a2)        ($singleton_elim ($bv_mk_bitblast_step_eq a1 a2)))
  ((extract u l a1) ($bv_mk_bitblast_step_extract u l a1))
  ((concat a1 a3)   ($bv_mk_bitblast_step_concat a))
  (a1               (alf.ite ($is_bin_literal a) 
                      ($bv_mk_bitblast_step_const a)
                      ($bv_mk_bitblast_step_var a)))    ; otherwise assume a variable
  ))
)

; @rule bv_bitblast_step implements ProofRule::BV_BITBLAST_STEP.
; @arg (= a b). The equality to prove.
; @requires We require that $bv_mk_bitblast_step applied to a returns b.
; @conclusion The equality between a and b.
; @note The current implementation only covers some of the operators that may
; appear in ProofRule::BV_BITBLAST_STEP.
(declare-rule bv_bitblast_step
  ((n Int) (a (BitVec n)) (b (BitVec n)))
  :args ((= a b))
  :requires ((($bv_mk_bitblast_step a) b))
  :conclusion (= a b)
)

