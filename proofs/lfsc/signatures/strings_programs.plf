; depends: nary_programs.plf theory_def.plf

; Make empty string of the given string-like sort s.
(program sc_mk_emptystr ((s sort)) term
  (match s
    ((Seq t) (seq.empty s))
    (String emptystr)))

; Get the term corresponding to the prefix of term s of fixed length n.
(program sc_skolem_prefix ((s term) (n term)) term 
  (str.substr s (int 0) n)
)

; Get the term corresponding to the suffix of term s of fixed length n.
(program sc_skolem_suffix_rem ((s term) (n term)) term
  (str.substr s n (a.- (str.len s) n))
)

; Get the term corresponding to the prefix of s before the first occurrence of
; t in s.
(program sc_skolem_first_ctn_pre ((s term) (t term)) term 
  (sc_skolem_prefix s (str.indexof s t (int 0))))

; Get the term corresponding to the suffix of s after the first occurrence of
; t in s.
(program sc_skolem_first_ctn_post ((s term) (t term)) term 
  (sc_skolem_suffix_rem s (a.+ (str.len (sc_skolem_first_ctn_pre s t)) (a.+ (str.len t) (int 0)))))

; Head and tail for string concatenation.
(program sc_string_head ((t term)) term (nary_head f_str.++ t))
(program sc_string_tail ((t term)) term (nary_tail f_str.++ t))

; Concatenation str.++ applications t1 and t2.
(program sc_string_concat ((t1 term) (t2 term)) term (nary_concat f_str.++ t1 t2 emptystr))

; Decompose str.++ term t into a head and tail.
(program sc_string_decompose ((t term)) termPair (nary_decompose f_str.++ t emptystr))

; Insert a string into str.++ term t.
(program sc_string_insert ((elem term) (t term)) term (nary_insert f_str.++ elem t emptystr))

; Return reverse of t if rev = tt, return t unchanged otherwise.
(program sc_string_rev ((t term) (rev flag)) term (ifequal rev tt (nary_reverse f_str.++ t emptystr) t))

; Convert a str.++ application t into its element, if it is a singleton, return t unchanged otherwise.
(program sc_string_nary_elim ((t term)) term (nary_elim f_str.++ t emptystr))

; Convert t into a str.++ application, if it is not already in n-ary form.
(program sc_string_nary_intro ((t term)) term (nary_intro f_str.++ t emptystr))

; Compute the reduction predicate for (str.substr x n m) of sort s.
(program sc_string_reduction_substr ((x term) (n term) (m term) (s sort)) term
  (let k (sc_mk_skolem (str.substr x n m))
  (let npm (a.+ n (a.+ m (int 0)))
  (let k1 (sc_mk_skolem (sc_skolem_prefix x n))
  (let k2 (sc_mk_skolem (sc_skolem_suffix_rem x npm))
  (ite
    ; condition
    (and (a.>= n (int 0))
      (and (a.> (str.len x) n)
        (and (a.> m (int 0))
          true)))
    ; if branch
    (and (= x (str.++ k1 (str.++ k (str.++ k2 (sc_mk_emptystr s)))))
      (and (= (str.len k1) n)
        (and (or (= (str.len k2) (a.- (str.len x) npm))
                (or (= (str.len k2) (int 0))
                  false))
          (and (a.<= (str.len k) m)
            true))))
    ; else branch
    (= k (sc_mk_emptystr s))
    )))))
)

; Compute the reduction predicate for (str.indexof x y n) of sort s.
(program sc_string_reduction_indexof ((x term) (y term) (n term) (s sort)) term
  (let k (sc_mk_skolem (str.indexof x y n))
  (let xn (str.substr x n (a.- (str.len x) n))
  (let k1 (sc_mk_skolem (sc_skolem_first_ctn_pre xn y))
  (let k2 (sc_mk_skolem (sc_skolem_first_ctn_post xn y))
  (ite
    (or (not (str.contains xn y))
      (or (a.> n (str.len x))
        (or (a.> (int 0) n)
          false)))
    (= k (int (~ 1)))
    (ite
      (= y (sc_mk_emptystr s))
      (= k n)
      (and (= xn (str.++ k1 (str.++ y (str.++ k2 (sc_mk_emptystr s)))))
        (and (not (str.contains (str.++ k1 (str.++ (str.substr y (int 0) (a.- (str.len y) (int 1))) (sc_mk_emptystr s))) y))
          (and (= k (a.+ n (a.+ (str.len k1) (int 0))))
            true)))
)))))))

; Compute the reduction predicate for term t of sort s.
(program sc_string_reduction_pred ((t term) (s sort)) term
  (match t 
    ((apply t1 t2)
      (match t1
        ((apply t11 t12)
          (match t11
            ;(f_str.contains true)  ; TODO
            ((apply t111 t112) 
              (match t111
                (f_str.substr (sc_string_reduction_substr t112 t12 t2 s))
                (f_str.indexof (sc_string_reduction_indexof t112 t12 t2 s))
                ;(f_str.replace true)
            ; str.update
            ; str.from_int
            ; str.to_int
            ; seq.nth
            ; str.replaceall
            ; str.replace_re
            ; str.replace_re_all
            ; str.tolower
            ; str.toupper
            ; str.rev
            ; str.leq
))))))))

; Returns the reduction predicate and purification equality for term t
; of sort s.
(program sc_string_reduction ((t term) (s sort)) term
  (and (sc_string_reduction_pred t s) (and (= t (sc_mk_skolem t)) true))
)

; Compute the eager reduction predicate for (str.contains t r) where s
; is the sort of t and r.
; This is the formula:
;    (ite (str.contains t r), (= t (str.++ sk1 r sk2)), (not (= t r)))
(program sc_string_eager_reduction_contains ((t term) (r term) (s sort)) term
  (let k1 (sc_mk_skolem (sc_skolem_first_ctn_pre t r))
  (let k2 (sc_mk_skolem (sc_skolem_first_ctn_post t r))
  (ite
    (str.contains t r)
    (= t (str.++ k1 (str.++ r (str.++ k2 (sc_mk_emptystr s)))))
    (not (= t r)))
  ))
)

; Compute the eager reduction predicate for (str.code s), which is the formula:
;   (ite (= (str.len s) 1) 
;     (and (<= 0 (str.code s)) (< (str.code s) A))
;     (= (str.code s) (- 1)))
(program sc_string_eager_reduction_to_code ((s term)) term
  (let t (str.to_code s)
  (ite
    (= (str.len s) (int 1))
    (and (a.>= t (int 0)) (and (a.< t (int 196608)) true))
    (= t (int (~ 1)))))
)

; Compute the eager reduction predicate for (str.indexof x y n), which is the
; formula: 
; (and 
;   (or (= (str.indexof x y n) (- 1)) (>= (str.indexof x y n) n)) 
;   (<= (str.indexof x y n) (str.len x)))
(program sc_string_eager_reduction_indexof ((x term) (y term) (n term)) term
  (let t (str.indexof x y n)
  (and (or (= t (int (~ 1))) (or (a.>= t n) false))
    (and (a.<= t (str.len x))
      true)))
)

; Compute the eager reduction predicate of term t of sort s.
(program sc_string_eager_reduction ((t term) (s sort)) term
  (match t 
    ((apply t1 t2)
      (match t1
        (f_str.to_code (sc_string_eager_reduction_to_code t2))
        ((apply t11 t12)
          (match t11
            (f_str.contains (sc_string_eager_reduction_contains t12 t2 s))
            ((apply t111 t112)
              (match t111
                (f_str.indexof (sc_string_eager_reduction_indexof t112 t12 t2)))))))))
)

(program sc_re_unfold_pos_concat ((t term) (r term) (ro term) (i mpz)) termPair
  (match r
    ((apply r1 r2)
      (match (sc_re_unfold_pos_concat t r2 ro (mp_add i 1))
        ((pair p1 p2)
        (let r12 (getarg f_re.++ r1)
        (let r122 (try_getarg f_str.to_re r12)
        (ifequal r122 r12 
          (let k (skolem_re_unfold_pos t ro i)
          (pair (str.++ k p1) (and (str.in_re k r12) p2)))
          (pair (str.++ r122 p1) p2)))))))
    (default (pair emptystr true))
))

(program sc_non_empty_concats ((t term)) term
  (match t
    ((apply t1 t2)
      (and (not (= (getarg f_str.++ t1) emptystr)) (sc_non_empty_concats t2)))
    (emptystr true)))

(program sc_re_unfold_pos ((t term) (r term)) term
  (match r
    ((apply r1 r2)
      (match r1
        ; case for star
        (f_re.*
          (let rr (re.++ r2 (re.++ r (re.++ r2 re.empty)))
          (match (sc_re_unfold_pos_concat t rr rr 0)
            ((pair p1 p2)
              (or (= t emptystr)
                (or (str.in_re t r2)
                  (or (and (sc_string_nary_elim (and (= t p1) p2)) (sc_non_empty_concats p1))
                    false)))))))
        ((apply r11 r12)
          (match r11
            ; case for concatenation
            (f_re.++
              (match (sc_re_unfold_pos_concat t r r 0)
                ((pair p1 p2) (sc_string_nary_elim (and (= t p1) p2)))))
))))))
