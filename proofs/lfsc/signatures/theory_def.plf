; depends: core_defs.plf

; This file defines the sort and function symbols for all SMT-LIB standard
; theories, as well as extensions supported by cvc5.

;; ---- Sorts

; Booleans
(declare Bool sort)
; Integers
(declare Int sort)
; Reals
(declare Real sort)
; Arrays, parametrized by index and element sorts
(declare Array (! i sort (! e sort sort)))
; Strings
(declare String sort)
; Sequences, parametrized by an element sort
(declare Seq (! e sort sort))
; Regular languages
(declare RegLan sort)
; Bit-vectors, parametrized by an integer bit-width
(declare BitVec (! w mpz sort))
; Floating points, parametrized by exponent and significand bit-widths
(declare FloatingPoint (! e mpz (! s mpz sort)))
; Rounding modes for floating points
(declare RoundingMode sort)
; Sets, parametrized by an element sort
(declare Set (! e sort sort))
; Bags (i.e. multi-sets), parametrized by an element sort
(declare Bag (! e sort sort))
; Finite fields
(declare FiniteField (! s mpz sort))

;; ---- Arithmetic

; We define the signature for theories of integer and real arithmetic with
; extensions here. Apart from real and integer values, the signature does
; not distinguish between integer and real versions of the overloaded operators
; of arithmetic. Instead, a single operator is used for both versions, which
; we prefix its name with `a.` where "a" is for "arithmetic". For example,
; `f_a.+` denotes the function for arithmetic addition and is used for
; applications of addition for both real and integer terms. Other non-overloaded
; operators, e.g. for transcendentals, are not prefixed by `a.`.

; a real-valued constant, indexed by its rational value, represented as an mpq.
(declare real (! v mpq term))
; a integer-valued constant, indexed by its integer value, represented as an mpz.
(declare int (! v mpz term))
(declare f_a.+ term)
(define a.+ (# x term (# y term (apply (apply f_a.+ x) y))))
(declare f_a.- term)
(define a.- (# x term (# y term (apply (apply f_a.- x) y))))
(declare f_a.u- term)
(define a.u- (# x term (apply f_a.u- x)))
(declare f_a.* term)
(define a.* (# x term (# y term (apply (apply f_a.* x) y))))
(declare f_a./ term)
(define a./ (# x term (# y term (apply (apply f_a./ x) y))))
(declare f_a./_total term)
(define a./_total (# x term (# y term (apply (apply f_a./_total x) y))))
(declare f_a.> term)
(define a.> (# x term (# y term (apply (apply f_a.> x) y))))
(declare f_a.>= term)
(define a.>= (# x term (# y term (apply (apply f_a.>= x) y))))
(declare f_a.< term)
(define a.< (# x term (# y term (apply (apply f_a.< x) y))))
(declare f_a.<= term)
(define a.<= (# x term (# y term (apply (apply f_a.<= x) y))))
(declare f_a.^ term)
(define a.^ (# x term (# y term (apply (apply f_a.^ x) y))))
; Transcendentals
(declare real.pi term)
(declare f_exp term)
(define exp (# x term (apply f_exp x)))
(declare f_sin term)
(define sin (# x term (apply f_sin x)))
(declare f_cos term)
(define cos (# x term (apply f_cos x)))
(declare f_tan term)
(define tan (# x term (apply f_tan x)))
(declare f_csc term)
(define csc (# x term (apply f_csc x)))
(declare f_sec term)
(define sec (# x term (apply f_sec x)))
(declare f_cot term)
(define cot (# x term (apply f_cot x)))
(declare f_arcsin term)
(define arcsin (# x term (apply f_arcsin x)))
(declare f_arccos term)
(define arccos (# x term (apply f_arccos x)))
(declare f_arctan term)
(define arctan (# x term (apply f_arctan x)))
(declare f_arccsc term)
(define arccsc (# x term (apply f_arccsc x)))
(declare f_arcsec term)
(define arcsec (# x term (apply f_arcsec x)))
(declare f_arccot term)
(define arccot (# x term (apply f_arccot x)))
(declare f_sqrt term)
(define sqrt (# x term (apply f_sqrt x)))
(declare f_a.div term)
(define a.div (# x term (# y term (apply (apply f_a.div x) y))))
(declare f_a.mod term)
(define a.mod (# x term (# y term (apply (apply f_a.mod x) y))))
(declare f_a.div_total term)
(define a.div_total (# x term (# y term (apply (apply f_a.div_total x) y))))
(declare f_a.mod_total term)
(define a.mod_total (# x term (# y term (apply (apply f_a.mod_total x) y))))
; Other extended terms
(declare f_to_real term)
(define to_real (# x term (apply f_to_real x)))
(declare f_to_int term)
(define to_int (# x term (apply f_to_int x)))
(declare f_is_int term)
(define is_int (# x term (apply f_is_int x)))
(declare f_abs term)
(define abs (# x term (apply f_abs x)))
; "integer-and", see Zohar et al VMCAI 2022.
(declare f_iand (! x mpz term))
(define iand (# x mpz (# y term (# z term (apply (apply (f_iand x) y) z)))))
(declare f_int.pow2 term)
(define int.pow2 (# x term (apply f_int.pow2 x)))

;; ---- Arrays
(declare f_select term)
(define select (# x term (# y term (apply (apply f_select x) y))))
(declare f_store term)
(define store (# x term (# y term (# z term (apply (apply (apply f_store x) y) z)))))
(declare f_array_const (! s sort term))
(define array_const (# x sort (# y term (apply (f_array_const x) y))))
(declare f_eqrange term)
(define eqrange (# x term (# y term (# z term (# w term (apply (apply (apply (apply f_eqrange x) y) z) w))))))

;; ---- Datatypes
; tester, indexed by the constructor that it tests
(declare is (! c term term))
; updater, indexed by the selector field that it updates
(declare update (! s term term))
; "shared selector" for (sort, index), see Reynolds et al IJCAR 2018.
(declare sel (! s sort (! z mpz term)))

;; ---- Strings

; In strings, values (i.e. word constants) are represented as null-terminated
; concatenation chains of character constants, indexed by Unicode code points.
; This means that the SMT-LIB syntax "ABC" denoting a string of length 3 is
; represented in LFSC as the term:
;   `(str.++ (char 65) (str.++ (char 66) (str.++ (char 67) emptystr)))`

; The empty string 
(declare emptystr term)
; A character constant, indexed by its Unicode code point
(declare char (! v mpz term))
(declare f_str.len term)
(define str.len (# x term (apply f_str.len x)))
(declare f_str.++ term)
(define str.++ (# x term (# y term (apply (apply f_str.++ x) y))))
(declare f_str.substr term)
(define str.substr (# x term (# y term (# z term (apply (apply (apply f_str.substr x) y) z)))))
(declare f_str.contains term)
(define str.contains (# x term (# y term (apply (apply f_str.contains x) y))))
(declare f_str.replace term)
(define str.replace (# x term (# y term (# z term (apply (apply (apply f_str.replace x) y) z)))))
(declare f_str.indexof term)
(define str.indexof (# x term (# y term (# z term (apply (apply (apply f_str.indexof x) y) z)))))
(declare f_str.at term)
(define str.at (# x term (# y term (apply (apply f_str.at x) y))))
(declare f_str.prefixof term)
(define str.prefixof (# x term (# y term (apply (apply f_str.prefixof x) y))))
(declare f_str.suffixof term)
(define str.suffixof (# x term (# y term (apply (apply f_str.suffixof x) y))))
(declare f_str.rev term)
(define str.rev (# x term (apply f_str.rev x)))
(declare f_str.unit term)
(define str.unit (# x term (apply f_str.unit x)))
(declare f_str.update term)
(define str.update (# x term (# y term (# z term (apply (apply (apply f_str.update x) y) z)))))
(declare f_str.to_lower term)
(define str.to_lower (# x term (apply f_str.to_lower x)))
(declare f_str.to_upper term)
(define str.to_upper (# x term (apply f_str.to_upper x)))
(declare f_str.to_code term)
(define str.to_code (# x term (apply f_str.to_code x)))
(declare f_str.from_code term)
(define str.from_code (# x term (apply f_str.from_code x)))
(declare f_str.is_digit term)
(define str.is_digit (# x term (apply f_str.is_digit x)))
(declare f_str.to_int term)
(define str.to_int (# x term (apply f_str.to_int x)))
(declare f_str.from_int term)
(define str.from_int (# x term (apply f_str.from_int x)))
(declare f_str.< term)
(define str.< (# x term (# y term (apply (apply f_str.< x) y))))
(declare f_str.<= term)
(define str.<= (# x term (# y term (apply (apply f_str.<= x) y))))
(declare f_str.replace_all term)
(define str.replace_all (# x term (# y term (# z term (apply (apply (apply f_str.replace_all x) y) z)))))
(declare f_str.indexof_re term)
(define str.indexof_re (# x term (# y term (# z term (apply (apply (apply f_str.indexof_re x) y) z)))))
(declare f_str.replace_re term)
(define str.replace_re (# x term (# y term (# z term (apply (apply (apply f_str.replace_re x) y) z)))))
(declare f_str.replace_re_all term)
(define str.replace_re_all (# x term (# y term (# z term (apply (apply (apply f_str.replace_re_all x) y) z)))))
; Regular expressions
(declare re.allchar term)
(declare re.none term)
(declare re.all term)
(declare re.empty term) ; singleton RE containing empty string, used as null terminator
(declare f_str.to_re term)
(define str.to_re (# x term (apply f_str.to_re x)))
(declare f_re.* term)
(define re.* (# x term (apply f_re.* x)))
(declare f_re.+ term)
(define re.+ (# x term (apply f_re.+ x)))
(declare f_re.opt term)
(define re.opt (# x term (apply f_re.opt x)))
(declare f_re.comp term)
(define re.comp (# x term (apply f_re.comp x)))
(declare f_re.range term)
(define re.range (# x term (# y term (apply (apply f_re.range x) y))))
(declare f_re.++ term)
(define re.++ (# x term (# y term (apply (apply f_re.++ x) y))))
(declare f_re.inter term)
(define re.inter (# x term (# y term (apply (apply f_re.inter x) y))))
(declare f_re.union term)
(define re.union (# x term (# y term (apply (apply f_re.union x) y))))
(declare f_re.diff term)
(define re.diff (# x term (# y term (apply (apply f_re.diff x) y))))
(declare f_re.loop (! n1 mpz (! n2 mpz term)))
(define re.loop (# n1 mpz (# n2 mpz (# x term (apply (f_re.loop n1 n2) x)))))
(declare f_str.in_re term)
(define str.in_re (# x term (# y term (apply (apply f_str.in_re x) y))))
; Sequences
(declare seq.empty (! s sort term))
(declare f_seq.unit term)
(define seq.unit (# x term (apply f_seq.unit x)))
(declare f_seq.nth term)
(define seq.nth (# x term (# y term (apply (apply f_seq.nth x) y))))
(declare f_seq.len term)
(define seq.len (# x term (apply f_seq.len x)))
(declare f_seq.++ term)
(define seq.++ (# x term (# y term (apply (apply f_seq.++ x) y))))
(declare f_seq.extract term)
(define seq.extract (# x term (# y term (# z term (apply (apply (apply f_seq.extract x) y) z)))))
(declare f_seq.contains term)
(define seq.contains (# x term (# y term (apply (apply f_seq.contains x) y))))
(declare f_seq.replace term)
(define seq.replace (# x term (# y term (# z term (apply (apply (apply f_seq.replace x) y) z)))))
(declare f_seq.indexof term)
(define seq.indexof (# x term (# y term (# z term (apply (apply (apply f_seq.indexof x) y) z)))))
(declare f_seq.prefixof term)
(define seq.prefixof (# x term (# y term (apply (apply f_seq.prefixof x) y))))
(declare f_seq.suffixof term)
(define seq.suffixof (# x term (# y term (apply (apply f_seq.suffixof x) y))))
(declare f_seq.rev term)
(define seq.rev (# x term (apply f_seq.rev x)))
(declare f_seq.update term)
(define seq.update (# x term (# y term (# z term (apply (apply (apply f_seq.update x) y) z)))))
; skolem types
(declare skolem_re_unfold_pos (! t term (! r term (! z mpz term))))

;; ---- Bit-vectors

; A bit-vector constant, indexed by a bitvec, denoting its value.
(declare bv (! b bitvec term))
(declare f_bvnot term)
(define bvnot (# x term (apply f_bvnot x)))
(declare f_bvand term)
(define bvand (# x term (# y term (apply (apply f_bvand x) y))))
(declare f_bvor term)
(define bvor (# x term (# y term (apply (apply f_bvor x) y))))
(declare f_bvxor term)
(define bvxor (# x term (# y term (apply (apply f_bvxor x) y))))
(declare f_bvnand term)
(define bvnand (# x term (# y term (apply (apply f_bvnand x) y))))
(declare f_bvnor term)
(define bvnor (# x term (# y term (apply (apply f_bvnor x) y))))
(declare f_bvxnor term)
(define bvxnor (# x term (# y term (apply (apply f_bvxnor x) y))))
(declare f_bvmul term)
(define bvmul (# x term (# y term (apply (apply f_bvmul x) y))))
(declare f_bvneg term)
(define bvneg (# x term (apply f_bvneg x)))
(declare f_bvadd term)
(define bvadd (# x term (# y term (apply (apply f_bvadd x) y))))
(declare f_bvsub term)
(define bvsub (# x term (# y term (apply (apply f_bvsub x) y))))
(declare f_bvudiv term)
(define bvudiv (# x term (# y term (apply (apply f_bvudiv x) y))))
(declare f_bvurem term)
(define bvurem (# x term (# y term (apply (apply f_bvurem x) y))))
(declare f_bvsdiv term)
(define bvsdiv (# x term (# y term (apply (apply f_bvsdiv x) y))))
(declare f_bvsrem term)
(define bvsrem (# x term (# y term (apply (apply f_bvsrem x) y))))
(declare f_bvsmod term)
(define bvsmod (# x term (# y term (apply (apply f_bvsmod x) y))))
(declare f_bvshl term)
(define bvshl (# x term (# y term (apply (apply f_bvshl x) y))))
(declare f_bvlshr term)
(define bvlshr (# x term (# y term (apply (apply f_bvlshr x) y))))
(declare f_bvashr term)
(define bvashr (# x term (# y term (apply (apply f_bvashr x) y))))
(declare f_bvult term)
(define bvult (# x term (# y term (apply (apply f_bvult x) y))))
(declare f_bvule term)
(define bvule (# x term (# y term (apply (apply f_bvule x) y))))
(declare f_bvugt term)
(define bvugt (# x term (# y term (apply (apply f_bvugt x) y))))
(declare f_bvuge term)
(define bvuge (# x term (# y term (apply (apply f_bvuge x) y))))
(declare f_bvslt term)
(define bvslt (# x term (# y term (apply (apply f_bvslt x) y))))
(declare f_bvsle term)
(define bvsle (# x term (# y term (apply (apply f_bvsle x) y))))
(declare f_bvsgt term)
(define bvsgt (# x term (# y term (apply (apply f_bvsgt x) y))))
(declare f_bvsge term)
(define bvsge (# x term (# y term (apply (apply f_bvsge x) y))))
(declare f_bvcomp term)
(define bvcomp (# x term (# y term (apply (apply f_bvcomp x) y))))
(declare f_concat term)
(define concat (# x term (# y term (apply (apply f_concat x) y))))
(declare f_bvuaddo term)
(define bvuaddo (# x term (# y term (apply (apply f_bvuaddo x) y))))
(declare f_bvsaddo term)
(define bvsaddo (# x term (# y term (apply (apply f_bvsaddo x) y))))
(declare f_bvumulo term)
(define bvumulo (# x term (# y term (apply (apply f_bvumulo x) y))))
(declare f_bvsmulo term)
(define bvsmulo (# x term (# y term (apply (apply f_bvsmulo x) y))))
(declare f_bvusubo term)
(define bvusubo (# x term (# y term (apply (apply f_bvusubo x) y))))
(declare f_bvssubo term)
(define bvssubo (# x term (# y term (apply (apply f_bvssubo x) y))))
(declare f_bvsdivo term)
(define bvsdivo (# x term (# y term (apply (apply f_bvsdivo x) y))))
(declare f_rotate_left (! v mpz term))
(define rotate_left (# x mpz (# y term (apply (f_rotate_left x) y))))
(declare f_rotate_right (! v mpz term))
(define rotate_right (# x mpz (# y term (apply (f_rotate_right x) y))))
(declare f_zero_extend (! v mpz term))
(define zero_extend (# x mpz (# y term (apply (f_zero_extend x) y))))
(declare f_sign_extend (! v mpz term))
(define sign_extend (# x mpz (# y term (apply (f_sign_extend x) y))))
(declare f_repeat (! v mpz term))
(define repeat (# x mpz (# y term (apply (f_repeat x) y))))
(declare f_extract (! i mpz (! j mpz term)))
(define extract (# x mpz (# y mpz (# z term (apply (f_extract x y) z)))))
(declare f_bv2nat term)
(define bv2nat (# x term (apply f_bv2nat x)))
(declare f_int2bv (! i mpz term))
(define int2bv (# x mpz (# y term (apply (f_int2bv x) y))))
; Internal definitions for Bitblasting
(declare f_bbT term)
(define bbT (# x term (# y term (apply (apply f_bbT x) y))))
(declare f_bitOf (! b mpz term))
(define bitOf (# b mpz (# x term (apply (f_bitOf b) x))))
(declare f_BITVECTOR_EAGER_ATOM term)
(define BITVECTOR_EAGER_ATOM (# x term (apply f_BITVECTOR_EAGER_ATOM x)))
(declare f_BITVECTOR_ITE term)
(define BITVECTOR_ITE (# x term (# y term (# z term (apply (apply (apply f_BITVECTOR_ITE x) y) z)))))
(declare f_BITVECTOR_SLTBV term)
(define BITVECTOR_SLTBV (# x term (# y term (apply (apply f_BITVECTOR_SLTBV x) y))))
(declare f_BITVECTOR_ULTBV term)
(define BITVECTOR_ULTBV (# x term (# y term (apply (apply f_BITVECTOR_ULTBV x) y))))
; The empty bitvector, which is used as the null terminator of bvconcat chains
(declare emptybv term)


;; ---- Floating points

; A floating point constant is a term having 3 bitvector children.
; Note this is used for both FLOATINGPOINT_FP and CONST_FLOATINGPOINT
(declare f_fp term)
(define fp (# x term (# y term (# z term (apply (apply (apply f_fp x) y) z)))))
(declare f_fp.add term)
(define fp.add (# x term (# y term (# z term (apply (apply (apply f_fp.add x) y) z)))))
(declare f_fp.sub term)
(define fp.sub (# x term (# y term (# z term (apply (apply (apply f_fp.sub x) y) z)))))
(declare f_fp.mul term)
(define fp.mul (# x term (# y term (# z term (apply (apply (apply f_fp.mul x) y) z)))))
(declare f_fp.div term)
(define fp.div (# x term (# y term (# z term (apply (apply (apply f_fp.div x) y) z)))))
(declare f_fp.fma term)
(define fp.fma (# x term (# y term (# z term (# w term (apply (apply  (apply (apply f_fp.fma x) y) z) w))))))
(declare f_fp.sqrt term)
(define fp.sqrt (# x term (# y term (apply (apply f_fp.sqrt x) y))))
(declare f_fp.rem term)
(define fp.rem (# x term (# y term (apply (apply f_fp.rem x) y))))
(declare f_fp.roundToIntegral term)
(define fp.roundToIntegral (# x term (# y term (apply (apply f_fp.roundToIntegral x) y))))
(declare f_fp.min term)
(define fp.min (# x term (# y term (apply (apply f_fp.min x) y))))
(declare f_fp.max term)
(define fp.max (# x term (# y term (apply (apply f_fp.max x) y))))
(declare f_fp.leq term)
(define fp.leq (# x term (# y term (apply (apply f_fp.leq x) y))))
(declare f_fp.lt term)
(define fp.lt (# x term (# y term (apply (apply f_fp.lt x) y))))
(declare f_fp.geq term)
(define fp.geq (# x term (# y term (apply (apply f_fp.geq x) y))))
(declare f_fp.gt term)
(define fp.gt (# x term (# y term (apply (apply f_fp.gt x) y))))
(declare f_fp.eq term)
(define fp.eq (# x term (# y term (apply (apply f_fp.eq x) y))))
(declare f_to_fp_unsigned (! i mpz (! j mpz term)))
(define to_fp_unsigned (# x mpz (# y mpz (# z term (# w term (apply (apply (f_to_fp_unsigned x y) z) w))))))
(declare f_fp.to_ubv (! i mpz term))
(define fp.to_ubv (# x mpz (# z term (# w term (apply (apply (f_fp.to_ubv x) z) w)))))
(declare f_fp.to_sbv (! i mpz term))
(define fp.to_sbv (# x mpz (# z term (# w term (apply (apply (f_fp.to_sbv x) z) w)))))
(declare f_fp.abs term)
(define fp.abs (# x term (apply f_fp.abs x)))
(declare f_fp.neg term)
(define fp.neg (# x term (apply f_fp.neg x)))
(declare f_fp.isNormal term)
(define fp.isNormal (# x term (apply f_fp.isNormal x)))
(declare f_fp.isSubnormal term)
(define fp.isSubnormal (# x term (apply f_fp.isSubnormal x)))
(declare f_fp.isZero term)
(define fp.isZero (# x term (apply f_fp.isZero x)))
(declare f_fp.isInfinite term)
(define fp.isInfinite (# x term (apply f_fp.isInfinite x)))
(declare f_fp.isNaN term)
(define fp.isNaN (# x term (apply f_fp.isNaN x)))
(declare f_fp.isNegative term)
(define fp.isNegative (# x term (apply f_fp.isNegative x)))
(declare f_fp.isPositive term)
(define fp.isPositive (# x term (apply f_fp.isPositive x)))
(declare f_fp.to_real term)
(define fp.to_real (# x term (apply f_fp.to_real x)))
; to avoid overloading, must distinguish types
(declare f_to_fp_fp (! i mpz (! j mpz term)))
(define to_fp_fp (# x mpz (# y mpz (# z term (# w term (apply (apply (f_to_fp_fp x y) z) w))))))
(declare f_to_fp_real (! i mpz (! j mpz term)))
(define to_fp_real (# x mpz (# y mpz (# z term (# w term (apply (apply (f_to_fp_real x y) z) w))))))
(declare f_to_fp_sbv (! i mpz (! j mpz term)))
(define to_fp_sbv (# x mpz (# y mpz (# z term (# w term (apply (apply (f_to_fp_sbv x y) z) w))))))
(declare f_to_fp_ieee_bv (! i mpz (! j mpz term)))
(define to_fp_ieee_bv (# x mpz (# y mpz (# z term (apply (f_to_fp_ieee_bv x y) z)))))
(declare f_to_fp_bv (! i mpz (! j mpz term)))
(define to_fp_bv (# x mpz (# y mpz (# z term (apply (f_to_fp_bv x y) z)))))
(declare f_fp.to_ubv_total (! i mpz term))
(define fp.to_ubv_total (# x mpz (# z term (# w term (# u term (apply (apply (apply (f_fp.to_ubv_total x) z) w) u))))))
(declare f_fp.to_sbv_total (! i mpz term))
(define fp.to_sbv_total (# x mpz (# z term (# w term (# u term (apply (apply (apply (f_fp.to_sbv_total x) z) w) u))))))
; rounding modes
(declare roundNearestTiesToEven term)
(declare roundNearestTiesToAway term)
(declare roundTowardPositive term)
(declare roundTowardNegative term)
(declare roundTowardZero term)
; internally generated terms
(declare f_EXPONENT term)
(define EXPONENT (# x term (apply f_EXPONENT x)))
(declare f_SIGN term)
(define SIGN (# x term (apply f_SIGN x)))
(declare f_SIGNIFICAND term)
(define SIGNIFICAND (# x term (apply f_SIGNIFICAND x)))
(declare f_ZERO term)
(define ZERO (# x term (apply f_ZERO x)))
(declare f_INF term)
(define INF (# x term (apply f_INF x)))
(declare f_NAN term)
(define NAN (# x term (apply f_NAN x)))

;; ---- Sets
(declare set.empty (! s sort term))
(declare set.universe (! s sort term))
(declare f_set.singleton term)
(define set.singleton (# x term (apply f_set.singleton x)))
(declare f_set.union term)
(define set.union (# x term (# y term (apply (apply f_set.union x) y))))
(declare f_set.inter term)
(define set.inter (# x term (# y term (apply (apply f_set.inter x) y))))
(declare f_set.minus term)
(define set.minus (# x term (# y term (apply (apply f_set.minus x) y))))
(declare f_set.complement term)
(define set.complement (# x term (apply f_set.complement x)))
(declare f_set.member term)
(define set.member (# x term (# y term (apply (apply f_set.member x) y))))
(declare f_set.subset term)
(define set.subset (# x term (# y term (apply (apply f_set.subset x) y))))
(declare f_set.card term)
(define set.card (# x term (apply f_set.card x)))
(declare f_set.choose term)
(define set.choose (# x term (apply f_set.choose x)))
(declare f_set.is_singleton term)
(define set.is_singleton (# x term (apply f_set.is_singleton x)))
(declare f_rel.join term)
(define rel.join (# x term (# y term (apply (apply f_rel.join x) y))))
(declare f_rel.product term)
(define rel.product (# x term (# y term (apply (apply f_rel.product x) y))))
(declare f_rel.transpose term)
(define rel.transpose (# x term (apply f_rel.transpose x)))
(declare f_rel.tclosure term)
(define rel.tclosure (# x term (apply f_rel.tclosure x)))
(declare f_rel.iden term)
(define rel.iden (# x term (apply f_rel.iden x)))
(declare f_rel.join_image term)
(define rel.join_image (# x term (# y term (apply (apply f_rel.join_image x) y))))
(declare f_set.insert term)
(define set.insert (# x term (# y term (apply (apply f_set.insert x) y))))
(declare f_set.filter term)
(define set.filter (# x term (# y term (apply (apply f_set.filter x) y))))
(declare f_set.map term)
(define set.map (# x term (# y term (apply (apply f_set.map x) y))))
(declare f_set.fold term)
(define set.fold (# x term (# y term (# z term (apply (apply (apply f_set.fold x) y) z)))))

;; ---- Bags
(declare bag.empty (! s sort term))
(declare f_bag.union_max term)
(define bag.union_max (# x term (# y term (apply (apply f_bag.union_max x) y))))
(declare f_bag.union_disjoint term)
(define bag.union_disjoint (# x term (# y term (apply (apply f_bag.union_disjoint x) y))))
(declare f_bag.inter_min term)
(define bag.inter_min (# x term (# y term (apply (apply f_bag.inter_min x) y))))
(declare f_bag.difference_subtract term)
(define bag.difference_subtract (# x term (# y term (apply (apply f_bag.difference_subtract x) y))))
(declare f_bag.difference_remove term)
(define bag.difference_remove (# x term (# y term (apply (apply f_bag.difference_remove x) y))))
(declare f_bag.subbag term)
(define bag.subbag (# x term (# y term (apply (apply f_bag.subbag x) y))))
(declare f_bag.count term)
(define bag.count (# x term (# y term (apply (apply f_bag.count x) y))))
(declare f_bag term)
(define bag (# x term (# y term (apply (apply f_bag x) y))))
(declare f_bag.duplicate_removal term)
(define bag.duplicate_removal (# x term (apply f_bag.duplicate_removal x)))
(declare f_bag.card term)
(define bag.card (# x term (apply f_bag.card x)))
(declare f_bag.choose term)
(define bag.choose (# x term (apply f_bag.choose x)))
(declare f_bag.is_singleton term)
(define bag.is_singleton (# x term (apply f_bag.is_singleton x)))
(declare f_bag.from_set term)
(define bag.from_set (# x term (apply f_bag.from_set x)))
(declare f_bag.to_set term)
(define bag.to_set (# x term (apply f_bag.to_set x)))
(declare f_bag.member term)
(define bag.member (# x term (# y term (apply (apply f_bag.member x) y))))
(declare f_bag.map term)
(define bag.map (# x term (# y term (apply (apply f_bag.map x) y))))
(declare f_bag.filter term)
(define bag.filter (# x term (# y term (apply (apply f_bag.filter x) y))))
(declare f_bag.fold term)
(define bag.fold (# x term (# y term (# z term (apply (apply (apply f_bag.fold x) y) z)))))
(declare f_table.product term)
(define table.product (# x term (# y term (apply (apply f_table.product x) y))))

;; ---- Separation Logic
(declare sep.nil (! s sort term))
(declare f_sep term)
(define sep (# x term (# y term (apply (apply f_sep x) y))))
(declare f_sep_label term)
(define sep_label (# x term (# y term (apply (apply f_sep_label x) y))))
(declare f_wand term)
(define wand (# x term (# y term (apply (apply f_wand x) y))))
(declare f_pto term)
(define pto (# x term (# y term (apply (apply f_pto x) y))))
; the empty heap constraint
(declare sep.emp term)
; internally generated in separation logic reductions
(declare f_SEP_LABEL term)
(define SEP_LABEL (# x term (# y term (apply (apply f_SEP_LABEL x) y))))

;; ---- UF with cardinality
; internally generated for finite model finding. Note this is an indexed constant.
(declare fmf.card (! s sort (! i mpz term)))

;; ---- Finite fields

; A finite field constant is a term having 2 integer children.
(declare f_ff.value term)
(define ff.value (# x term (# y term (apply (apply f_ff.value x) y))))
(declare f_ff.add term)
(define ff.add (# x term (# y term (apply (apply f_ff.add x) y))))
(declare f_ff.neg term)
(define ff.neg (# x term (apply f_ff.neg x)))
(declare f_ff.mul term)
(define ff.mul (# x term (# y term (apply (apply f_ff.mul x) y))))
