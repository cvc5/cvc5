; depends: core_defs.plf

; sorts :
(declare Bool sort)
(declare Int sort)
(declare Real sort)
(declare String sort)
(declare RegLan sort)
(declare Array (! i sort (! e sort sort)))
(declare BitVec (! w mpz sort))
(declare FloatingPoint (! e mpz (! s mpz sort)))
(declare RoundingMode sort)
(declare Set (! e sort sort))
(declare Bag (! e sort sort))
(declare Seq (! e sort sort))

; Arithmetic
; Reals
(declare real (! v mpq term))
(declare f_a.+ term)
(define a.+ (# x term (# y term (apply (apply f_a.+ x) y))))
(declare f_a.- term)
(define a.- (# x term (# y term (apply (apply f_a.- x) y))))
(declare f_a.u- term)
(define a.u- (# x term (apply f_a.u- x)))
(declare f_a.* term)
(define a.* (# x term (# y term (apply (apply f_a.* x) y))))
(declare f_a./ term)
(define a./ (# x term (# y term (apply (apply f_a./ x) y))))
(declare f_a./_total term)
(define a./_total (# x term (# y term (apply (apply f_a./_total x) y))))
(declare f_a.> term)
(define a.> (# x term (# y term (apply (apply f_a.> x) y))))
(declare f_a.>= term)
(define a.>= (# x term (# y term (apply (apply f_a.>= x) y))))
(declare f_a.< term)
(define a.< (# x term (# y term (apply (apply f_a.< x) y))))
(declare f_a.<= term)
(define a.<= (# x term (# y term (apply (apply f_a.<= x) y))))
(declare f_a.^ term)
(define a.^ (# x term (# y term (apply (apply f_a.^ x) y))))
(declare real.pi term)
(declare f_exp term)
(define exp (# x term (apply f_exp x)))
(declare f_sin term)
(define sin (# x term (apply f_sin x)))
(declare f_cos term)
(define cos (# x term (apply f_cos x)))
(declare f_tan term)
(define tan (# x term (apply f_tan x)))
(declare f_csc term)
(define csc (# x term (apply f_csc x)))
(declare f_sec term)
(define sec (# x term (apply f_sec x)))
(declare f_cot term)
(define cot (# x term (apply f_cot x)))
(declare f_arcsin term)
(define arcsin (# x term (apply f_arcsin x)))
(declare f_arccos term)
(define arccos (# x term (apply f_arccos x)))
(declare f_arctan term)
(define arctan (# x term (apply f_arctan x)))
(declare f_arccsc term)
(define arccsc (# x term (apply f_arccsc x)))
(declare f_arcsec term)
(define arcsec (# x term (apply f_arcsec x)))
(declare f_arccot term)
(define arccot (# x term (apply f_arccot x)))
(declare f_sqrt term)
(define sqrt (# x term (apply f_sqrt x)))
; Integers
(declare int (! v mpz term))
(declare f_a.div term)
(define a.div (# x term (# y term (apply (apply f_a.div x) y))))
(declare f_a.mod term)
(define a.mod (# x term (# y term (apply (apply f_a.mod x) y))))
(declare f_a.div_total term)
(define a.div_total (# x term (# y term (apply (apply f_a.div_total x) y))))
(declare f_a.mod_total term)
(define a.mod_total (# x term (# y term (apply (apply f_a.mod_total x) y))))
; Other
(declare f_to_real term)
(define to_real (# x term (apply f_to_real x)))
(declare f_to_int term)
(define to_int (# x term (apply f_to_int x)))
(declare f_is_int term)
(define is_int (# x term (apply f_is_int x)))
(declare f_abs term)
(define abs (# x term (apply f_abs x)))
(declare f_iand (! x mpz term))
(define iand (# x mpz (# y term (# z term (apply (apply (f_iand x) y) z)))))

; Arrays
(declare f_select term)
(define select (# x term (# y term (apply (apply f_select x) y))))
(declare f_store term)
(define store (# x term (# y term (# z term (apply (apply (apply f_store x) y) z)))))
(declare f_array_const (! s sort term))
(define array_const (# x sort (# y term (apply (f_array_const x) y)))
(declare f_eqrange term)
(define eqrange (# x term (# y term (# z term (# w term (apply (apply (apply (apply f_eqrange x) y) z) w))))))

; Datatypes
; tester
(declare is (! c term term))
; updater
(declare update (! s term term))
; shared selector for (sort, index)
(declare sel (! s sort (! z mpz term)))

; Strings
(declare emptystr term)
(declare char (! v mpz term))
(declare f_str.len term)
(define str.len (# x term (apply f_str.len x)))
(declare f_str.++ term)
(define str.++ (# x term (# y term (apply (apply f_str.++ x) y))))
(declare f_str.substr term)
(define str.substr (# x term (# y term (# z term (apply (apply (apply f_str.substr x) y) z)))))
(declare f_str.contains term)
(define str.contains (# x term (# y term (apply (apply f_str.contains x) y))))
(declare f_str.replace term)
(define str.replace (# x term (# y term (# z term (apply (apply (apply f_str.replace x) y) z)))))
(declare f_str.indexof term)
(define str.indexof (# x term (# y term (# z term (apply (apply (apply f_str.indexof x) y) z)))))
(declare f_str.at term)
(define str.at (# x term (# y term (apply (apply f_str.at x) y))))
(declare f_str.prefixof term)
(define str.prefixof (# x term (# y term (apply (apply f_str.prefixof x) y))))
(declare f_str.suffixof term)
(define str.suffixof (# x term (# y term (apply (apply f_str.suffixof x) y))))
(declare f_str.rev term)
(define str.rev (# x term (apply f_str.rev x)))
(declare f_str.update term)
(define str.update (# x term (# y term (# z term (apply (apply (apply f_str.update x) y) z)))))
(declare f_str.tolower term)
(define str.tolower (# x term (apply f_str.tolower x)))
(declare f_str.toupper term)
(define str.toupper (# x term (apply f_str.toupper x)))
(declare f_str.to_code term)
(define str.to_code (# x term (apply f_str.to_code x)))
(declare f_str.from_code term)
(define str.from_code (# x term (apply f_str.from_code x)))
(declare f_str.is_digit term)
(define str.is_digit (# x term (apply f_str.is_digit x)))
(declare f_str.to_int term)
(define str.to_int (# x term (apply f_str.to_int x)))
(declare f_str.from_int term)
(define str.from_int (# x term (apply f_str.from_int x)))
(declare f_str.< term)
(define str.< (# x term (# y term (apply (apply f_str.< x) y))))
(declare f_str.<= term)
(define str.<= (# x term (# y term (apply (apply f_str.<= x) y))))
(declare f_str.indexof_re term)
(define str.indexof_re (# x term (# y term (# z term (apply (apply (apply f_str.indexof_re x) y) z)))))
(declare f_str.replace_re term)
(define str.replace_re (# x term (# y term (# z term (apply (apply (apply f_str.replace_re x) y) z)))))
(declare f_str.replace_re_all term)
(define str.replace_re_all (# x term (# y term (# z term (apply (apply (apply f_str.replace_re_all x) y) z)))))
; Regular expressions
(declare re.allchar term)
(declare re.none term)
(declare re.all term)
(declare re.empty term) ; singleton RE containing empty string, used as null terminator
(declare f_str.to_re term)
(define str.to_re (# x term (apply f_str.to_re x)))
(declare f_re.* term)
(define re.* (# x term (apply f_re.* x)))
(declare f_re.+ term)
(define re.+ (# x term (apply f_re.+ x)))
(declare f_re.opt term)
(define re.opt (# x term (apply f_re.opt x)))
(declare f_re.comp term)
(define re.comp (# x term (apply f_re.comp x)))
(declare f_re.range term)
(define re.range (# x term (# y term (apply (apply f_re.range x) y))))
(declare f_re.++ term)
(define re.++ (# x term (# y term (apply (apply f_re.++ x) y))))
(declare f_re.inter term)
(define re.inter (# x term (# y term (apply (apply f_re.inter x) y))))
(declare f_re.union term)
(define re.union (# x term (# y term (apply (apply f_re.union x) y))))
(declare f_re.diff term)
(define re.diff (# x term (# y term (apply (apply f_re.diff x) y))))
(declare f_re.loop (! n1 mpz (! n2 mpz term)))
(define re.loop (# n1 mpz (# n2 mpz (# x term (apply (f_re.loop n1 n2) x)))))
(declare f_str.in_re term)
(define str.in_re (# x term (# y term (apply (apply f_str.in_re x) y))))
; Sequences
(declare seq.empty (! s sort term))
(declare f_seq.unit term)
(define seq.unit (# x term (apply f_seq.unit x)))
(declare f_seq.nth term)
(define seq.nth (# x term (# y term (apply (apply f_seq.nth x) y))))
(declare f_seq.len term)
(define seq.len (# x term (apply f_seq.len x)))
(declare f_seq.++ term)
(define seq.++ (# x term (# y term (apply (apply f_seq.++ x) y))))
(declare f_seq.extract term)
(define seq.extract (# x term (# y term (# z term (apply (apply (apply f_seq.extract x) y) z)))))
(declare f_seq.contains term)
(define seq.contains (# x term (# y term (apply (apply f_seq.contains x) y))))
(declare f_seq.replace term)
(define seq.replace (# x term (# y term (# z term (apply (apply (apply f_seq.replace x) y) z)))))
(declare f_seq.indexof term)
(define seq.indexof (# x term (# y term (# z term (apply (apply (apply f_seq.indexof x) y) z)))))
(declare f_seq.prefixof term)
(define seq.prefixof (# x term (# y term (apply (apply f_seq.prefixof x) y))))
(declare f_seq.suffixof term)
(define seq.suffixof (# x term (# y term (apply (apply f_seq.suffixof x) y))))
(declare f_seq.rev term)
(define seq.rev (# x term (apply f_seq.rev x)))
(declare f_seq.update term)
(define seq.update (# x term (# y term (# z term (apply (apply (apply f_seq.update x) y) z)))))
; skolem types
(declare skolem_re_unfold_pos (! t term (! r term (! z mpz term))))

; Bit-vectors
(declare bv (! b bitvec term))
(declare f_bvnot term)
(define bvnot (# x term (apply f_bvnot x)))
(declare f_bvand term)
(define bvand (# x term (# y term (apply (apply f_bvand x) y))))
(declare f_bvor term)
(define bvor (# x term (# y term (apply (apply f_bvor x) y))))
(declare f_bvxor term)
(define bvxor (# x term (# y term (apply (apply f_bvxor x) y))))
(declare f_bvnand term)
(define bvnand (# x term (# y term (apply (apply f_bvnand x) y))))
(declare f_bvnor term)
(define bvnor (# x term (# y term (apply (apply f_bvnor x) y))))
(declare f_bvxnor term)
(define bvxnor (# x term (# y term (apply (apply f_bvxnor x) y))))
(declare f_bvmul term)
(define bvmul (# x term (# y term (apply (apply f_bvmul x) y))))
(declare f_bvneg term)
(define bvneg (# x term (apply f_bvneg x)))
(declare f_bvadd term)
(define bvadd (# x term (# y term (apply (apply f_bvadd x) y))))
(declare f_bvsub term)
(define bvsub (# x term (# y term (apply (apply f_bvsub x) y))))
(declare f_bvudiv term)
(define bvudiv (# x term (# y term (apply (apply f_bvudiv x) y))))
(declare f_bvurem term)
(define bvurem (# x term (# y term (apply (apply f_bvurem x) y))))
(declare f_bvsdiv term)
(define bvsdiv (# x term (# y term (apply (apply f_bvsdiv x) y))))
(declare f_bvsrem term)
(define bvsrem (# x term (# y term (apply (apply f_bvsrem x) y))))
(declare f_bvsmod term)
(define bvsmod (# x term (# y term (apply (apply f_bvsmod x) y))))
(declare f_bvshl term)
(define bvshl (# x term (# y term (apply (apply f_bvshl x) y))))
(declare f_bvlshr term)
(define bvlshr (# x term (# y term (apply (apply f_bvlshr x) y))))
(declare f_bvashr term)
(define bvashr (# x term (# y term (apply (apply f_bvashr x) y))))
(declare f_bvult term)
(define bvult (# x term (# y term (apply (apply f_bvult x) y))))
(declare f_bvule term)
(define bvule (# x term (# y term (apply (apply f_bvule x) y))))
(declare f_bvugt term)
(define bvugt (# x term (# y term (apply (apply f_bvugt x) y))))
(declare f_bvuge term)
(define bvuge (# x term (# y term (apply (apply f_bvuge x) y))))
(declare f_bvslt term)
(define bvslt (# x term (# y term (apply (apply f_bvslt x) y))))
(declare f_bvsle term)
(define bvsle (# x term (# y term (apply (apply f_bvsle x) y))))
(declare f_bvsgt term)
(define bvsgt (# x term (# y term (apply (apply f_bvsgt x) y))))
(declare f_bvsge term)
(define bvsge (# x term (# y term (apply (apply f_bvsge x) y))))
(declare f_bvcomp term)
(define bvcomp (# x term (# y term (apply (apply f_bvcomp x) y))))
(declare f_concat term)
(define concat (# x term (# y term (apply (apply f_concat x) y))))
(declare f_rotate_left (! v mpz term))
(define rotate_left (# x mpz (# y term (apply (f_rotate_left x) y))))
(declare f_rotate_right (! v mpz term))
(define rotate_right (# x mpz (# y term (apply (f_rotate_right x) y))))
(declare f_zero_extend (! v mpz term))
(define zero_extend (# x mpz (# y term (apply (f_zero_extend x) y))))
(declare f_sign_extend (! v mpz term))
(define sign_extend (# x mpz (# y term (apply (f_sign_extend x) y))))
(declare f_repeat (! v mpz term))
(define repeat (# x mpz (# y term (apply (f_repeat x) y))))
(declare f_extract (! i mpz (! j mpz term)))
(define extract (# x mpz (# y mpz (# z term (apply (f_extract x y) z)))))
(declare f_bv2nat term)
(define bv2nat (# x term (apply f_bv2nat x)))
(declare f_int2bv (! i mpz term))
(define int2bv (# x mpz (# y term (apply (f_int2bv x) y))))
; Bitblasting
(declare f_bbT term)
(define bbT (# x term (# y term (apply (apply f_bbT x) y))))
(declare f_bitOf (! b mpz term))
(define bitOf (# b mpz (# x term (apply (f_bitOf b) x))))
; The empty bitvector, which is used as the null terminator of bvconcat chains
(declare emptybv term)

; Sets
(declare emptyset (! s sort term))
(declare univset (! s sort term))
(declare f_singleton term)
(define singleton (# x term (apply f_singleton x)))
(declare f_union term)
(define union (# x term (# y term (apply (apply f_union x) y))))
(declare f_intersection term)
(define intersection (# x term (# y term (apply (apply f_intersection x) y))))
(declare f_setminus term)
(define setminus (# x term (# y term (apply (apply f_setminus x) y))))
(declare f_complement term)
(define complement (# x term (apply f_complement x)))
(declare f_member term)
(define member (# x term (# y term (apply (apply f_member x) y))))
(declare f_subset term)
(define subset (# x term (# y term (apply (apply f_subset x) y))))
(declare f_card term)
(define card (# x term (apply f_card x)))
(declare f_choose term)
(define choose (# x term (apply f_choose x)))
(declare f_is_singleton term)
(define is_singleton (# x term (apply f_is_singleton x)))
(declare f_join term)
(define join (# x term (# y term (apply (apply f_join x) y))))
(declare f_product term)
(define product (# x term (# y term (apply (apply f_product x) y))))
(declare f_transpose term)
(define transpose (# x term (apply f_transpose x)))
(declare f_tclosure term)
(define tclosure (# x term (apply f_tclosure x)))
(declare f_iden term)
(define iden (# x term (apply f_iden x)))
(declare f_join_image term)
(define join_image (# x term (# y term (apply (apply f_join_image x) y))))
(declare f_insert term)
(define insert (# x term (# y term (apply (apply f_insert x) y))))

; Bags
(declare emptybag (! s sort term))
(declare f_union_max term)
(define union_max (# x term (# y term (apply (apply f_union_max x) y))))
(declare f_union_disjoint term)
(define union_disjoint (# x term (# y term (apply (apply f_union_disjoint x) y))))
(declare f_intersection_min term)
(define intersection_min (# x term (# y term (apply (apply f_intersection_min x) y))))
(declare f_difference_subtract term)
(define difference_subtract (# x term (# y term (apply (apply f_difference_subtract x) y))))
(declare f_difference_remove term)
(define difference_remove (# x term (# y term (apply (apply f_difference_remove x) y))))
(declare f_subbag term)
(define subbag (# x term (# y term (apply (apply f_subbag x) y))))
(declare f_bag.count term)
(define bag.count (# x term (# y term (apply (apply f_bag.count x) y))))
(declare f_bag term)
(define bag (# x term (# y term (apply (apply f_bag x) y))))
(declare f_duplicate_removal term)
(define duplicate_removal (# x term (apply f_duplicate_removal x)))

; Separation Logic
(declare sep.nil (! s sort term))
(declare f_sep term)
(define sep (# x term (# y term (apply (apply f_sep x) y))))
(declare f_sep_label term)
(define sep_label (# x term (# y term (apply (apply f_sep_label x) y))))
(declare f_wand term)
(define wand (# x term (# y term (apply (apply f_wand x) y))))
(declare f_pto term)
(define pto (# x term (# y term (apply (apply f_pto x) y))))
(declare f_emp term)
(define emp (# x term (# y term (apply (apply f_emp x) y))))


; non-standard definitions (temporary)
(declare f_BITVECTOR_EAGER_ATOM term)
(define BITVECTOR_EAGER_ATOM (# x term (apply f_BITVECTOR_EAGER_ATOM x)))
(declare f_SEP_LABEL term)
(define SEP_LABEL (# x term (# y term (apply (apply f_SEP_LABEL x) y))))
(declare f_fmf.card term)
(define fmf.card (# x term (# y term (apply (apply f_fmf.card x) y))))
