; COMMAND-LINE: --dt-stc-ind
; EXPECT: unsat
(set-info :smt-lib-version 2.6)
(set-logic UFDTLIA)
(set-info :source |
Generated by: Andrew Reynolds
Generated on: 2017-04-28
Generator: Leon, converted to v2.6 by CVC4
Application: Inductive theorem proving
Target solver: CVC4, Z3
Publications: "Induction for SMT Solvers" by Andrew Reynolds, and Viktor Kuncak, VMCAI 2015.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unknown)


(declare-datatypes ((Nat 0)) (((succ (pred Nat)) (zero))
))
(declare-datatypes ((Lst 0)) (((cons (head Nat) (tail Lst)) (nil))
))
(declare-datatypes ((Tree 0)) (((node (data Nat) (left Tree) (right Tree)) (leaf))
))
(declare-datatypes ((Pair 0)(ZLst 0)) (((mkpair (first Nat) (second Nat)))
((zcons (zhead Pair) (ztail ZLst)) (znil))
))
(declare-fun P (Nat) Bool)
(declare-fun f (Nat) Nat)
(declare-fun less (Nat Nat) Bool)
(declare-fun plus (Nat Nat) Nat)
(declare-fun minus (Nat Nat) Nat)
(declare-fun mult (Nat Nat) Nat)
(declare-fun nmax (Nat Nat) Nat)
(declare-fun nmin (Nat Nat) Nat)
(declare-fun nat-to-int (Nat) Int)
(declare-fun append (Lst Lst) Lst)
(declare-fun len (Lst) Nat)
(declare-fun drop (Nat Lst) Lst)
(declare-fun take (Nat Lst) Lst)
(declare-fun count (Nat Lst) Nat)
(declare-fun last (Lst) Nat)
(declare-fun butlast (Lst) Lst)
(declare-fun mem (Nat Lst) Bool)
(declare-fun delete (Nat Lst) Lst)
(declare-fun rev (Lst) Lst)
(declare-fun lmap (Lst) Lst)
(declare-fun filter (Lst) Lst)
(declare-fun dropWhile (Lst) Lst)
(declare-fun takeWhile (Lst) Lst)
(declare-fun ins1 (Nat Lst) Lst)
(declare-fun insort (Nat Lst) Lst)
(declare-fun sorted (Lst) Bool)
(declare-fun sort (Lst) Lst)
(declare-fun zip (Lst Lst) ZLst)
(declare-fun zappend (ZLst ZLst) ZLst)
(declare-fun zdrop (Nat ZLst) ZLst)
(declare-fun ztake (Nat ZLst) ZLst)
(declare-fun zrev (ZLst) ZLst)
(declare-fun mirror (Tree) Tree)
(declare-fun height (Tree) Nat)
(define-fun leq ((x Nat) (y Nat)) Bool (or (= x y) (less x y)))
(assert (forall ((x Nat)) (>= (nat-to-int x) 0) ))
(assert (forall ((x Nat) (y Nat)) (=> (= (nat-to-int x) (nat-to-int y)) (= x y)) ))
(assert (= (nat-to-int zero) 0))
(assert (forall ((x Nat)) (= (nat-to-int (succ x)) (+ 1 (nat-to-int x))) ))
(assert (forall ((x Lst)) (= (append nil x) x) ))
(assert (forall ((x Nat) (y Lst) (z Lst)) (= (append (cons x y) z) (cons x (append y z))) ))
(assert (forall ((x Nat)) (= (count x nil) zero) ))
(assert (forall ((x Nat) (y Nat) (z Lst)) (= (count x (cons y z)) (ite (= x y) (succ (count x z)) (count x z))) ))
(assert (not (forall ((n Nat) (x Lst)) (= (count n (append x (cons n nil))) (succ (count n x))) )))
(check-sat)
(exit)

