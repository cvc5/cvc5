(set-logic HO_ALL)
(set-info :status sat)
(set-option :finite-model-find true)
(set-option :uf-lazy-ll true)
(set-option :fmf-bound true)
(declare-const time (Set (Tuple Int)))
(declare-const A (Set (Tuple Int)))
(declare-const not_A (Set (Tuple Int Int)))
(declare-const B (Set (Tuple Int)))
(declare-const not_B (Set (Tuple Int Int)))
(declare-const C (Set (Tuple Int)))
(declare-const not_C (Set (Tuple Int Int)))
(declare-const Measure (Set (Tuple Int Int)))
(assert (exists ((x Int) (y Int) (z Int)) (and (= x y) (and (set.member (tuple y z) Measure) (set.member (tuple x) A)))))
(assert 
 (set.all
  (lambda ((t1 (Tuple Int)))
    (let ((x ((_ tuple.select 0) t1)))
     (set.some 
      (lambda ((t2 (Tuple Int Int)))
       (let ((y ((_ tuple.select 0) t2)) (z ((_ tuple.select 1) t2)))
        (and 
         (set.some 
          (lambda ((t3 (Tuple Int))) 
            (let ((w ((_ tuple.select 0) t3)))
             (and (>= w (+ x 0)) (<= w (+ x 7))))
          )
          B)
         (= x y))
        )
      ) 
      Measure))) 
  A))
(assert (forall ((B_time_Int_15 Int)) (=> (set.member (tuple B_time_Int_15) B) (exists ((Measure_time_Int_16 Int) (Measure_m1_Int_17 Int)) (and (and (exists ((C_time_Int_18 Int)) (and (and (>= C_time_Int_18 (+ B_time_Int_15 0)) (<= C_time_Int_18 (+ B_time_Int_15 7))) (set.member (tuple C_time_Int_18) C))) (= B_time_Int_15 Measure_time_Int_16)) (set.member (tuple Measure_time_Int_16 Measure_m1_Int_17) Measure))))))
(assert (forall ((A_time_Int_29 Int)) (=> (set.member (tuple A_time_Int_29) A) (exists ((Measure_time_Int_30 Int) (z1 Int)) (and (and (or (exists ((C_time_Int_32 Int)) (and (and (>= C_time_Int_32 (+ A_time_Int_29 0)) (<= C_time_Int_32 (+ A_time_Int_29 15))) (set.member (tuple C_time_Int_32) C))) (not (< z1 20))) (= A_time_Int_29 Measure_time_Int_30)) (set.member (tuple Measure_time_Int_30 z1) Measure))))))
(assert (forall ((A_time_Int_49 Int)) (=> (set.member (tuple A_time_Int_49) A) (exists ((Measure_time_Int_50 Int) (Measure_m1_Int_51 Int)) (and (and (exists ((not_C_start_time_Int_53 Int) (not_C_end_time_Int_54 Int)) (and (and (= not_C_end_time_Int_54 (+ A_time_Int_49 11)) (= not_C_start_time_Int_53 (+ A_time_Int_49 0))) (set.member (tuple not_C_start_time_Int_53 not_C_end_time_Int_54) not_C))) (= A_time_Int_49 Measure_time_Int_50)) (set.member (tuple Measure_time_Int_50 Measure_m1_Int_51) Measure))))))
(assert (and (and (= (as set.empty (Set (Tuple Int Int Int))) (set.filter (lambda ((tuple_3 (Tuple Int Int Int))) (not (not (and (<= ((_ tuple.select 0) tuple_3) ((_ tuple.select 2) tuple_3)) (<= ((_ tuple.select 1) tuple_3) ((_ tuple.select 0) tuple_3)))))) (rel.product C not_C))) (and (= (as set.empty (Set (Tuple Int Int Int))) (set.filter (lambda ((tuple_2 (Tuple Int Int Int))) (not (not (and (<= ((_ tuple.select 0) tuple_2) ((_ tuple.select 2) tuple_2)) (<= ((_ tuple.select 1) tuple_2) ((_ tuple.select 0) tuple_2)))))) (rel.product B not_B))) (= (as set.empty (Set (Tuple Int Int Int))) (set.filter (lambda ((tuple_1 (Tuple Int Int Int))) (not (not (and (<= ((_ tuple.select 0) tuple_1) ((_ tuple.select 2) tuple_1)) (<= ((_ tuple.select 1) tuple_1) ((_ tuple.select 0) tuple_1)))))) (rel.product A not_A))))) (forall ((Measure_time_Int_79 Int) (Measure_m1_Int_80 Int) (Measure_time_Int_81 Int) (Measure_m1_Int_82 Int)) (=> (and (set.member (tuple Measure_time_Int_81 Measure_m1_Int_82) Measure) (set.member (tuple Measure_time_Int_79 Measure_m1_Int_80) Measure)) (=> (= Measure_time_Int_79 Measure_time_Int_81) (and (= Measure_m1_Int_80 Measure_m1_Int_82) (= Measure_time_Int_79 Measure_time_Int_81)))))))
(assert (forall ((B_time_Int_71 Int)) (=> (set.member (tuple B_time_Int_71) B) (or (exists ((B_time_Int_73 Int)) (and (and (forall ((B_time_Int_74 Int)) (=> (set.member (tuple B_time_Int_74) B) (<= B_time_Int_74 B_time_Int_71))) (> B_time_Int_73 B_time_Int_71)) (set.member (tuple B_time_Int_73) B))) (forall ((B_time_Int_72 Int)) (=> (set.member (tuple B_time_Int_72) B) (<= B_time_Int_72 B_time_Int_71)))))))
(check-sat)
