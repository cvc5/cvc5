; EXPECT: unsat
(set-logic AUFLIA)
(declare-sort A$ 0)
(declare-sort B$ 0)
(declare-sort Real$ 0)
(declare-sort B_list$ 0)
(declare-sort Real_a_fun$ 0)
(declare-fun uu$ () Real_a_fun$)
(declare-fun nil$ () B_list$)
(declare-fun cons$ (B$ B_list$) B_list$)
(declare-fun zero$ () A$)
(declare-fun fun_app$ (Real_a_fun$ Real$) A$)
(declare-fun rec_join$ (B_list$) Real_a_fun$)
(declare-fun joinpaths$ (Real_a_fun$ Real_a_fun$) Real_a_fun$)
(declare-fun coeff_cube_to_path$ (B$) Real_a_fun$)
(assert (! (forall ((?v0 Real$)) (! (= (fun_app$ uu$ ?v0) zero$) :pattern ((fun_app$ uu$ ?v0)))) :named a0))
(assert (! (not (=> (forall ((?v0 Real_a_fun$) (?v1 B_list$)) (= (=> (and (= (rec_join$ ?v1) ?v0) (and (=> (and (= ?v1 nil$) (= uu$ ?v0)) false) (and (forall ((?v2 B$)) (=> (and (= ?v1 (cons$ ?v2 nil$)) (= ?v0 (coeff_cube_to_path$ ?v2))) false)) (forall ((?v2 B$) (?v3 B$) (?v4 B_list$)) (=> (and (= ?v1 (cons$ ?v2 (cons$ ?v3 ?v4))) (= ?v0 (joinpaths$ (coeff_cube_to_path$ ?v2) (rec_join$ (cons$ ?v3 ?v4))))) false))))) false) (=> (and (= (rec_join$ ?v1) (rec_join$ ?v1)) (and (=> (and (= ?v1 nil$) (= uu$ (rec_join$ ?v1))) false) (and (forall ((?v2 B$)) (=> (and (= ?v1 (cons$ ?v2 nil$)) (= (rec_join$ ?v1) (coeff_cube_to_path$ ?v2))) false)) (forall ((?v2 B$) (?v3 B$) (?v4 B_list$)) (=> (and (= ?v1 (cons$ ?v2 (cons$ ?v3 ?v4))) (= (rec_join$ ?v1) (joinpaths$ (coeff_cube_to_path$ ?v2) (rec_join$ (cons$ ?v3 ?v4))))) false))))) false))) (= (forall ((?v0 B_list$) (?v1 Real_a_fun$)) (=> (and (= (rec_join$ ?v0) ?v1) (and (=> (and (= ?v0 nil$) (= uu$ ?v1)) false) (and (forall ((?v2 B$)) (=> (and (= ?v0 (cons$ ?v2 nil$)) (= ?v1 (coeff_cube_to_path$ ?v2))) false)) (forall ((?v2 B$) (?v3 B$) (?v4 B_list$)) (=> (and (= ?v0 (cons$ ?v2 (cons$ ?v3 ?v4))) (= ?v1 (joinpaths$ (coeff_cube_to_path$ ?v2) (rec_join$ (cons$ ?v3 ?v4))))) false))))) false)) (forall ((?v0 B_list$)) (=> (and (= (rec_join$ ?v0) (rec_join$ ?v0)) (and (=> (and (= ?v0 nil$) (= uu$ (rec_join$ ?v0))) false) (and (forall ((?v1 B$)) (=> (and (= ?v0 (cons$ ?v1 nil$)) (= (rec_join$ ?v0) (coeff_cube_to_path$ ?v1))) false)) (forall ((?v1 B$) (?v2 B$) (?v3 B_list$)) (=> (and (= ?v0 (cons$ ?v1 (cons$ ?v2 ?v3))) (= (rec_join$ ?v0) (joinpaths$ (coeff_cube_to_path$ ?v1) (rec_join$ (cons$ ?v2 ?v3))))) false))))) false))))) :named a1))
(check-sat)
